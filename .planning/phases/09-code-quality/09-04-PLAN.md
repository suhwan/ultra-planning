---
phase: 09-code-quality
plan: 04
type: execute
wave: 4
depends_on:
  - "09-01"
  - "09-02"
  - "09-03"
files_modified:
  - src/quality/pipeline/types.ts
  - src/quality/pipeline/executor.ts
  - src/quality/pipeline/integration.ts
  - src/quality/pipeline/index.ts
  - src/quality/index.ts
autonomous: true

must_haves:
  truths:
    - "runQualityPipeline() executes LSP -> AST -> Review sequence"
    - "Pipeline fails fast if LSP diagnostics find errors (configurable)"
    - "PipelineResult aggregates all stage results with overall status"
    - "onTaskComplete hook integrates pipeline into task completion workflow"
  artifacts:
    - path: "src/quality/pipeline/types.ts"
      provides: "Pipeline types (PipelineResult, PipelineStage, PipelineOptions)"
      exports: ["PipelineResult", "PipelineStage", "PipelineOptions", "PipelineStatus"]
      min_lines: 40
    - path: "src/quality/pipeline/executor.ts"
      provides: "runQualityPipeline orchestrating all quality stages"
      exports: ["runQualityPipeline", "runStage"]
      min_lines: 80
    - path: "src/quality/pipeline/integration.ts"
      provides: "Task completion hook and state integration"
      exports: ["onTaskComplete", "saveQualityResult", "loadQualityResult"]
      min_lines: 50
    - path: "src/quality/pipeline/index.ts"
      provides: "Module barrel export"
      min_lines: 5
  key_links:
    - from: "src/quality/pipeline/executor.ts"
      to: "src/quality/lsp/diagnostics.ts"
      via: "import runDiagnostics"
      pattern: "runDiagnostics"
    - from: "src/quality/pipeline/executor.ts"
      to: "src/quality/ast/analyzer.ts"
      via: "import analyzeDirectory"
      pattern: "analyzeDirectory"
    - from: "src/quality/pipeline/executor.ts"
      to: "src/quality/review/analyzer.ts"
      via: "import runReview"
      pattern: "runReview"
    - from: "src/quality/pipeline/integration.ts"
      to: "src/state/state-manager.ts"
      via: "import StateManager for quality state persistence"
      pattern: "StateManager"
---

<objective>
Implement integrated quality pipeline: Task Complete -> LSP -> AST -> Review.

Purpose: Orchestrate all quality checks into a single pipeline that runs after task completion.
Output: `src/quality/pipeline/` module with executor and task completion integration.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Dependencies from previous plans
@src/quality/lsp/diagnostics.ts (runDiagnostics)
@src/quality/ast/analyzer.ts (analyzeDirectory)
@src/quality/review/analyzer.ts (runReview)
@src/state/state-manager.ts (StateManager for persistence)
@src/state/event-system.ts (EventSystem for notifications)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define pipeline types</name>
  <files>src/quality/pipeline/types.ts</files>
  <action>
```typescript
/**
 * Quality Pipeline Types
 *
 * Types for orchestrating LSP -> AST -> Review quality checks.
 */

import type { DiagnosticResult } from '../lsp/types.js';
import type { FileAnalysis } from '../ast/types.js';
import type { ReviewResult } from '../review/types.js';

// ============================================================================
// Pipeline Stage Types
// ============================================================================

export type PipelineStage = 'lsp' | 'ast' | 'review';

export type PipelineStatus = 'pending' | 'running' | 'passed' | 'failed' | 'skipped';

export interface StageResult<T> {
  stage: PipelineStage;
  status: PipelineStatus;
  data?: T;
  duration: number;
  error?: string;
}

// ============================================================================
// Pipeline Result Types
// ============================================================================

export interface PipelineResult {
  /** Overall pipeline status */
  status: PipelineStatus;

  /** Whether all stages passed */
  passed: boolean;

  /** Stage that caused failure (if any) */
  failedAt?: PipelineStage;

  /** Individual stage results */
  stages: {
    lsp?: StageResult<DiagnosticResult>;
    ast?: StageResult<FileAnalysis[]>;
    review?: StageResult<ReviewResult>;
  };

  /** Total pipeline duration (ms) */
  totalDuration: number;

  /** Summary for quick reference */
  summary: PipelineSummary;
}

export interface PipelineSummary {
  errors: number;
  warnings: number;
  reviewIssues: number;
  filesAnalyzed: number;
  recommendation: 'PASS' | 'WARN' | 'FAIL';
}

// ============================================================================
// Pipeline Options
// ============================================================================

export interface PipelineOptions {
  /** Directory to analyze (default: current working directory) */
  directory?: string;

  /** Files to focus on (if empty, analyze all) */
  files?: string[];

  /** Skip stages */
  skip?: PipelineStage[];

  /** Fail fast on LSP errors (default: true) */
  failOnLspErrors?: boolean;

  /** Fail fast on critical review issues (default: true) */
  failOnCritical?: boolean;

  /** Timeout per stage in ms (default: 60000) */
  stageTimeout?: number;

  /** Save result to state file (default: true) */
  persistResult?: boolean;
}

// ============================================================================
// Task Integration Types
// ============================================================================

export interface TaskCompleteContext {
  /** Task identifier */
  taskId: string;

  /** Phase identifier */
  phase: string;

  /** Plan number */
  plan: number;

  /** Files modified by the task */
  modifiedFiles: string[];
}

export interface QualityCheckResult {
  /** Context of the triggering task */
  context: TaskCompleteContext;

  /** Pipeline execution result */
  pipeline: PipelineResult;

  /** Timestamp of check */
  timestamp: string;
}
```
  </action>
  <verify>npm run build passes with types.ts</verify>
  <done>Pipeline types defined with stage results and options</done>
</task>

<task type="auto">
  <name>Task 2: Implement pipeline executor</name>
  <files>src/quality/pipeline/executor.ts</files>
  <action>
```typescript
/**
 * Quality Pipeline Executor
 *
 * Orchestrates: LSP diagnostics -> AST analysis -> Code review
 */

import type {
  PipelineResult,
  PipelineOptions,
  PipelineStage,
  PipelineStatus,
  StageResult,
  PipelineSummary,
} from './types.js';
import { runDiagnostics, type DiagnosticResult } from '../lsp/index.js';
import { analyzeDirectory, type FileAnalysis } from '../ast/index.js';
import { runReview, type ReviewResult } from '../review/index.js';

/**
 * Run the full quality pipeline
 *
 * Flow:
 * 1. LSP Diagnostics - Check for type errors
 * 2. AST Analysis - Extract code structure and metrics
 * 3. Code Review - Run checklist-based quality review
 *
 * By default, fails fast if LSP finds errors.
 */
export async function runQualityPipeline(
  options?: PipelineOptions
): Promise<PipelineResult> {
  const startTime = Date.now();
  const dir = options?.directory ?? process.cwd();
  const skipStages = new Set(options?.skip ?? []);
  const failOnLsp = options?.failOnLspErrors ?? true;
  const failOnCritical = options?.failOnCritical ?? true;

  const stages: PipelineResult['stages'] = {};
  let failedAt: PipelineStage | undefined;
  let overallStatus: PipelineStatus = 'passed';

  // Stage 1: LSP Diagnostics
  if (!skipStages.has('lsp')) {
    const lspResult = await runStage('lsp', async () => {
      return runDiagnostics(dir, { type: 'auto', timeout: options?.stageTimeout });
    });

    stages.lsp = lspResult;

    // Check fail-fast condition
    if (lspResult.status === 'failed') {
      failedAt = 'lsp';
      overallStatus = 'failed';
    } else if (failOnLsp && lspResult.data && lspResult.data.summary.errorCount > 0) {
      failedAt = 'lsp';
      overallStatus = 'failed';
      stages.lsp.status = 'failed';
    }
  }

  // Stage 2: AST Analysis (skip if LSP failed and failFast)
  if (!skipStages.has('ast') && !failedAt) {
    const astResult = await runStage('ast', async () => {
      return analyzeDirectory(dir, {
        extensions: ['.ts', '.tsx'],
        exclude: ['node_modules', 'dist', '.git'],
      });
    });

    stages.ast = astResult;

    if (astResult.status === 'failed') {
      failedAt = 'ast';
      overallStatus = 'failed';
    }
  }

  // Stage 3: Code Review (skip if earlier stages failed)
  if (!skipStages.has('review') && !failedAt) {
    const files = options?.files ?? (stages.ast?.data?.map(a => a.file) ?? []);

    const reviewResult = await runStage('review', async () => {
      return runReview(files, { includeMetrics: true });
    });

    stages.review = reviewResult;

    if (reviewResult.status === 'failed') {
      failedAt = 'review';
      overallStatus = 'failed';
    } else if (failOnCritical && reviewResult.data) {
      if (reviewResult.data.recommendation === 'REQUEST_CHANGES') {
        failedAt = 'review';
        overallStatus = 'failed';
        stages.review.status = 'failed';
      }
    }
  }

  const summary = calculateSummary(stages);

  return {
    status: overallStatus,
    passed: overallStatus === 'passed',
    failedAt,
    stages,
    totalDuration: Date.now() - startTime,
    summary,
  };
}

/**
 * Run a single pipeline stage with error handling
 */
export async function runStage<T>(
  stage: PipelineStage,
  fn: () => Promise<T>
): Promise<StageResult<T>> {
  const start = Date.now();

  try {
    const data = await fn();
    return {
      stage,
      status: 'passed',
      data,
      duration: Date.now() - start,
    };
  } catch (error) {
    return {
      stage,
      status: 'failed',
      duration: Date.now() - start,
      error: error instanceof Error ? error.message : String(error),
    };
  }
}

/**
 * Calculate pipeline summary from stage results
 */
function calculateSummary(stages: PipelineResult['stages']): PipelineSummary {
  const errors = stages.lsp?.data?.summary.errorCount ?? 0;
  const warnings = stages.lsp?.data?.summary.warningCount ?? 0;
  const reviewIssues = stages.review?.data?.summary.total ?? 0;
  const filesAnalyzed = stages.ast?.data?.length ?? 0;

  let recommendation: 'PASS' | 'WARN' | 'FAIL' = 'PASS';
  if (errors > 0 || (stages.review?.data?.summary.critical ?? 0) > 0) {
    recommendation = 'FAIL';
  } else if (warnings > 0 || (stages.review?.data?.summary.high ?? 0) > 0) {
    recommendation = 'WARN';
  }

  return {
    errors,
    warnings,
    reviewIssues,
    filesAnalyzed,
    recommendation,
  };
}
```
  </action>
  <verify>npm run build passes</verify>
  <done>runQualityPipeline orchestrates all stages with fail-fast logic</done>
</task>

<task type="auto">
  <name>Task 3: Implement integration hooks and module export</name>
  <files>src/quality/pipeline/integration.ts, src/quality/pipeline/index.ts, src/quality/index.ts</files>
  <action>
**integration.ts** - Task completion hook:
```typescript
/**
 * Quality Pipeline Integration
 *
 * Integrates quality checks with task completion workflow.
 *
 * Note: StateManager API is synchronous and requires name in constructor.
 * EventSystem exports standalone functions, not a class.
 */

import { StateManager } from '../../state/state-manager.js';
import { emitEvent } from '../../state/event-system.js';
import type { TaskCompleteContext, QualityCheckResult, PipelineOptions } from './types.js';
import { runQualityPipeline } from './executor.js';

const QUALITY_STATE_NAME = 'quality-results';

// Type for persisted quality state
interface QualityState {
  checks: QualityCheckResult[];
}

/**
 * Hook to run quality pipeline after task completion
 *
 * Usage:
 * ```typescript
 * await onTaskComplete({
 *   taskId: '09-01-01',
 *   phase: '09-code-quality',
 *   plan: 1,
 *   modifiedFiles: ['src/quality/lsp/types.ts'],
 * });
 * ```
 */
export async function onTaskComplete(
  context: TaskCompleteContext,
  options?: Partial<PipelineOptions>
): Promise<QualityCheckResult> {
  // Focus on modified files if specified
  const pipelineOptions: PipelineOptions = {
    ...options,
    files: context.modifiedFiles.length > 0 ? context.modifiedFiles : undefined,
  };

  // Run pipeline
  const pipeline = await runQualityPipeline(pipelineOptions);

  const result: QualityCheckResult = {
    context,
    pipeline,
    timestamp: new Date().toISOString(),
  };

  // Persist result
  if (options?.persistResult !== false) {
    saveQualityResult(result);
  }

  // Emit event using standalone function
  try {
    emitEvent({
      type: 'task_completed',
      source: 'quality-pipeline',
      payload: {
        taskId: context.taskId,
        phase: context.phase,
        plan: context.plan,
        qualityStatus: pipeline.status,
        summary: pipeline.summary,
      },
    });
  } catch {
    // Event emission failure is non-fatal
  }

  return result;
}

/**
 * Save quality result to state file
 *
 * Note: StateManager.write() is synchronous
 */
export function saveQualityResult(result: QualityCheckResult): void {
  const state = new StateManager<QualityState>(QUALITY_STATE_NAME);

  // Load existing results
  const existing = loadQualityResult();
  const results = existing ?? { checks: [] };

  // Add new result (keep last 50)
  results.checks.unshift(result);
  if (results.checks.length > 50) {
    results.checks = results.checks.slice(0, 50);
  }

  state.write(results);
}

/**
 * Load quality results from state
 *
 * Note: StateManager.read() is synchronous, returns StateReadResult
 */
export function loadQualityResult(): QualityState | undefined {
  const state = new StateManager<QualityState>(QUALITY_STATE_NAME);
  const result = state.read();
  return result.exists ? result.data : undefined;
}

/**
 * Get latest quality check result
 */
export function getLatestQualityResult(): QualityCheckResult | undefined {
  const results = loadQualityResult();
  return results?.checks[0];
}

/**
 * Get quality results for a specific task
 */
export function getQualityResultForTask(taskId: string): QualityCheckResult | undefined {
  const results = loadQualityResult();
  return results?.checks.find(r => r.context.taskId === taskId);
}
```

**index.ts**:
```typescript
export * from './types.js';
export * from './executor.js';
export * from './integration.js';
```

**Update src/quality/index.ts**:
```typescript
// Quality module - code quality automation

// LSP diagnostics (09-01)
export * from './lsp/index.js';

// AST analysis (09-02)
export * from './ast/index.js';

// Code review (09-03)
export * from './review/index.js';

// Quality pipeline (09-04)
export * from './pipeline/index.js';
```
  </action>
  <verify>npm run build && node -e "import('./dist/quality/pipeline/index.js').then(m => m.runQualityPipeline().then(r => console.log(JSON.stringify(r.summary, null, 2))))"</verify>
  <done>Pipeline module complete with task completion integration</done>
</task>

</tasks>

<verification>
1. `npm run build` - No compilation errors
2. runQualityPipeline() executes all 3 stages in order
3. onTaskComplete() persists results to state file
4. All exports available from quality/pipeline and main index
</verification>

<success_criteria>
- types.ts defines PipelineResult, PipelineStage, PipelineOptions, TaskCompleteContext
- executor.ts exports runQualityPipeline with fail-fast logic
- integration.ts exports onTaskComplete, saveQualityResult, loadQualityResult
- Pipeline executes: LSP -> AST -> Review
- Results persisted to .ultraplan/state/quality-results.json
- Full module exported from src/index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/09-code-quality/09-04-SUMMARY.md`
</output>

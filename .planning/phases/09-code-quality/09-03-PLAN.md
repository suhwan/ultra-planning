---
phase: 09-code-quality
plan: 03
type: execute
wave: 3
depends_on:
  - "09-02"
files_modified:
  - src/quality/review/types.ts
  - src/quality/review/checklist.ts
  - src/quality/review/analyzer.ts
  - src/quality/review/reporter.ts
  - src/quality/review/index.ts
  - src/quality/index.ts
autonomous: true

must_haves:
  truths:
    - "runReview() performs 2-stage review: spec compliance then code quality"
    - "ReviewIssue includes severity (CRITICAL/HIGH/MEDIUM/LOW), category, file, line, description, fix"
    - "generateReport() outputs markdown summary with issues grouped by severity"
  artifacts:
    - path: "src/quality/review/types.ts"
      provides: "Review types (ReviewResult, ReviewIssue, ReviewSeverity, ReviewChecklist)"
      exports: ["ReviewResult", "ReviewIssue", "ReviewSeverity", "ReviewCategory", "ReviewChecklist"]
      min_lines: 50
    - path: "src/quality/review/checklist.ts"
      provides: "Default checklists for security, quality, performance, best practices"
      exports: ["DEFAULT_CHECKLIST", "SECURITY_CHECKS", "QUALITY_CHECKS"]
      min_lines: 60
    - path: "src/quality/review/analyzer.ts"
      provides: "runReview function performing 2-stage code review"
      exports: ["runReview", "checkSpecCompliance", "checkCodeQuality"]
      min_lines: 80
    - path: "src/quality/review/reporter.ts"
      provides: "generateReport creating markdown review summary"
      exports: ["generateReport", "formatIssue", "countBySeverity"]
      min_lines: 50
    - path: "src/quality/review/index.ts"
      provides: "Module barrel export"
      min_lines: 5
  key_links:
    - from: "src/quality/review/analyzer.ts"
      to: "src/quality/ast/analyzer.ts"
      via: "import { analyzeFile } for code structure"
      pattern: "analyzeFile"
    - from: "src/quality/review/analyzer.ts"
      to: "src/quality/lsp/diagnostics.ts"
      via: "import { runDiagnostics } for type errors"
      pattern: "runDiagnostics"
---

<objective>
Implement code review agent logic with 2-stage review process.

Purpose: Automate code quality assessment with severity-rated feedback following the Code Reviewer agent pattern.
Output: `src/quality/review/` module with checklist-based analysis and markdown report generation.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Reference patterns
@references/oh-my-claudecode/agents/code-reviewer.md (2-stage review process)

# Dependencies from Wave 1
@src/quality/ast/types.ts (CodeStructure, CodeMetrics)
@src/quality/ast/analyzer.ts (analyzeFile)
@src/quality/lsp/diagnostics.ts (runDiagnostics)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define review types and checklist</name>
  <files>src/quality/review/types.ts, src/quality/review/checklist.ts</files>
  <action>
**types.ts** - Review type definitions:
```typescript
// ============================================================================
// Review Severity and Categories
// ============================================================================

export type ReviewSeverity = 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';

export type ReviewCategory =
  | 'security'
  | 'quality'
  | 'performance'
  | 'best-practices'
  | 'spec-compliance';

// ============================================================================
// Review Issue Types
// ============================================================================

export interface ReviewIssue {
  severity: ReviewSeverity;
  category: ReviewCategory;
  file: string;
  line: number;
  column?: number;
  code: string;  // rule identifier (e.g., 'SEC001', 'QUAL002')
  description: string;
  fix: string;
  snippet?: string;  // relevant code excerpt
}

// ============================================================================
// Review Result Types
// ============================================================================

export type ReviewRecommendation = 'APPROVE' | 'REQUEST_CHANGES' | 'COMMENT';

export interface ReviewSummary {
  critical: number;
  high: number;
  medium: number;
  low: number;
  total: number;
  filesReviewed: number;
}

export interface ReviewResult {
  success: boolean;
  recommendation: ReviewRecommendation;
  stage1Passed: boolean;  // spec compliance
  stage2Passed: boolean;  // code quality
  issues: ReviewIssue[];
  summary: ReviewSummary;
  duration: number;
}

// ============================================================================
// Checklist Types
// ============================================================================

export interface ChecklistItem {
  code: string;
  severity: ReviewSeverity;
  category: ReviewCategory;
  name: string;
  description: string;
  pattern?: string;  // ast-grep pattern or regex
  fixTemplate: string;
}

export interface ReviewChecklist {
  security: ChecklistItem[];
  quality: ChecklistItem[];
  performance: ChecklistItem[];
  bestPractices: ChecklistItem[];
}

// ============================================================================
// Review Options
// ============================================================================

export interface ReviewOptions {
  checklist?: Partial<ReviewChecklist>;
  minSeverity?: ReviewSeverity;
  includeMetrics?: boolean;
  maxIssues?: number;
}
```

**checklist.ts** - Default checklist definitions:
```typescript
import type { ChecklistItem, ReviewChecklist } from './types.js';

// Security checks (CRITICAL priority)
export const SECURITY_CHECKS: ChecklistItem[] = [
  {
    code: 'SEC001',
    severity: 'CRITICAL',
    category: 'security',
    name: 'Hardcoded Credentials',
    description: 'API keys, passwords, or tokens hardcoded in source',
    pattern: '(api_key|apiKey|password|secret|token)\\s*[=:]\\s*["\'][^"\']+["\']',
    fixTemplate: 'Move to environment variable: process.env.{NAME}',
  },
  {
    code: 'SEC002',
    severity: 'CRITICAL',
    category: 'security',
    name: 'SQL Injection Risk',
    description: 'String concatenation in SQL queries',
    pattern: 'query\\s*\\(\\s*[`"\'].*\\$\\{',
    fixTemplate: 'Use parameterized queries',
  },
  // Add more security checks
];

// Quality checks (HIGH priority)
export const QUALITY_CHECKS: ChecklistItem[] = [
  {
    code: 'QUAL001',
    severity: 'HIGH',
    category: 'quality',
    name: 'Large Function',
    description: 'Function exceeds 50 lines',
    fixTemplate: 'Split into smaller, focused functions',
  },
  {
    code: 'QUAL002',
    severity: 'HIGH',
    category: 'quality',
    name: 'Console.log Statement',
    description: 'Debug console.log left in code',
    pattern: 'console\\.log\\(',
    fixTemplate: 'Remove or replace with proper logging',
  },
  {
    code: 'QUAL003',
    severity: 'HIGH',
    category: 'quality',
    name: 'Missing Error Handling',
    description: 'Async operation without try/catch',
    fixTemplate: 'Wrap in try/catch block',
  },
];

// Performance checks (MEDIUM priority)
export const PERFORMANCE_CHECKS: ChecklistItem[] = [
  {
    code: 'PERF001',
    severity: 'MEDIUM',
    category: 'performance',
    name: 'Nested Loops',
    description: 'O(n^2) complexity from nested loops',
    fixTemplate: 'Consider using Map/Set for O(n) lookup',
  },
];

// Best practice checks (LOW priority)
export const BEST_PRACTICE_CHECKS: ChecklistItem[] = [
  {
    code: 'BP001',
    severity: 'LOW',
    category: 'best-practices',
    name: 'Magic Number',
    description: 'Unexplained numeric literal',
    fixTemplate: 'Extract to named constant',
  },
  {
    code: 'BP002',
    severity: 'LOW',
    category: 'best-practices',
    name: 'TODO Without Ticket',
    description: 'TODO comment without issue reference',
    pattern: '//\\s*TODO(?!.*#\\d)',
    fixTemplate: 'Add ticket reference: TODO(#123): ...',
  },
];

export const DEFAULT_CHECKLIST: ReviewChecklist = {
  security: SECURITY_CHECKS,
  quality: QUALITY_CHECKS,
  performance: PERFORMANCE_CHECKS,
  bestPractices: BEST_PRACTICE_CHECKS,
};
```
  </action>
  <verify>npm run build passes with new types</verify>
  <done>Review types and comprehensive checklist defined</done>
</task>

<task type="auto">
  <name>Task 2: Implement review analyzer</name>
  <files>src/quality/review/analyzer.ts</files>
  <action>
```typescript
import { readFileSync } from 'fs';
import type {
  ReviewResult,
  ReviewIssue,
  ReviewOptions,
  ReviewSummary,
  ReviewRecommendation,
  ChecklistItem,
} from './types.js';
import { DEFAULT_CHECKLIST } from './checklist.js';
import { analyzeFile, type CodeMetrics } from '../ast/index.js';
import { runDiagnostics } from '../lsp/index.js';

/**
 * Run 2-stage code review on files
 *
 * Stage 1: Spec compliance (via LSP diagnostics - type errors = spec failure)
 * Stage 2: Code quality (via checklist analysis)
 */
export async function runReview(
  files: string[],
  options?: ReviewOptions
): Promise<ReviewResult> {
  const start = Date.now();
  const issues: ReviewIssue[] = [];
  const checklist = { ...DEFAULT_CHECKLIST, ...options?.checklist };

  // Stage 1: Spec Compliance (type errors from diagnostics)
  const stage1Passed = await checkSpecCompliance(files, issues);

  // Stage 2: Code Quality (only if stage 1 passes, or run anyway for full report)
  const stage2Passed = await checkCodeQuality(files, checklist, issues, options);

  const summary = calculateSummary(issues, files.length);
  const recommendation = determineRecommendation(summary, stage1Passed);

  return {
    success: true,
    recommendation,
    stage1Passed,
    stage2Passed,
    issues: options?.maxIssues ? issues.slice(0, options.maxIssues) : issues,
    summary,
    duration: Date.now() - start,
  };
}

/**
 * Stage 1: Check spec compliance via type checking
 */
export async function checkSpecCompliance(
  files: string[],
  issues: ReviewIssue[]
): Promise<boolean> {
  // Use LSP diagnostics to check for type errors
  const dir = process.cwd();
  const result = await runDiagnostics(dir, { type: 'auto' });

  // Filter to only files we're reviewing
  const fileSet = new Set(files.map(f => f.replace(/^\.\//, '')));

  for (const diag of result.diagnostics) {
    if (fileSet.has(diag.file) || fileSet.size === 0) {
      if (diag.severity === 'error') {
        issues.push({
          severity: 'CRITICAL',
          category: 'spec-compliance',
          file: diag.file,
          line: diag.line,
          column: diag.column,
          code: `TS${diag.code}`,
          description: diag.message,
          fix: 'Fix type error to match specification',
        });
      }
    }
  }

  return result.summary.errorCount === 0;
}

/**
 * Stage 2: Check code quality via checklist
 */
export async function checkCodeQuality(
  files: string[],
  checklist: typeof DEFAULT_CHECKLIST,
  issues: ReviewIssue[],
  options?: ReviewOptions
): Promise<boolean> {
  let hasHighOrCritical = false;

  for (const filePath of files) {
    try {
      const content = readFileSync(filePath, 'utf-8');
      const analysis = await analyzeFile(filePath);

      // Run pattern-based checks
      for (const category of ['security', 'quality', 'performance', 'bestPractices'] as const) {
        for (const check of checklist[category]) {
          const found = runCheck(check, filePath, content, analysis.metrics);
          issues.push(...found);
          if (found.some(i => i.severity === 'CRITICAL' || i.severity === 'HIGH')) {
            hasHighOrCritical = true;
          }
        }
      }

      // Metrics-based checks
      if (options?.includeMetrics !== false) {
        issues.push(...checkMetrics(filePath, analysis.metrics));
      }
    } catch {
      // Skip files that can't be analyzed
    }
  }

  return !hasHighOrCritical;
}

// Run a single checklist item check
function runCheck(
  check: ChecklistItem,
  file: string,
  content: string,
  metrics: CodeMetrics
): ReviewIssue[] {
  const issues: ReviewIssue[] = [];

  // Pattern-based check
  if (check.pattern) {
    const regex = new RegExp(check.pattern, 'gi');
    const lines = content.split('\n');

    for (let i = 0; i < lines.length; i++) {
      if (regex.test(lines[i])) {
        issues.push({
          severity: check.severity,
          category: check.category,
          file,
          line: i + 1,
          code: check.code,
          description: check.description,
          fix: check.fixTemplate,
          snippet: lines[i].trim(),
        });
      }
      regex.lastIndex = 0;  // Reset regex state
    }
  }

  return issues;
}

// Check code metrics thresholds
function checkMetrics(file: string, metrics: CodeMetrics): ReviewIssue[] {
  const issues: ReviewIssue[] = [];

  if (metrics.maxFunctionSize > 50) {
    issues.push({
      severity: 'HIGH',
      category: 'quality',
      file,
      line: 1,
      code: 'QUAL001',
      description: `Function "${metrics.largestFunction}" has ${metrics.maxFunctionSize} lines (max recommended: 50)`,
      fix: 'Split into smaller functions',
    });
  }

  if (metrics.totalLines > 800) {
    issues.push({
      severity: 'MEDIUM',
      category: 'quality',
      file,
      line: 1,
      code: 'QUAL004',
      description: `File has ${metrics.totalLines} lines (max recommended: 800)`,
      fix: 'Consider splitting into multiple modules',
    });
  }

  return issues;
}

function calculateSummary(issues: ReviewIssue[], fileCount: number): ReviewSummary {
  return {
    critical: issues.filter(i => i.severity === 'CRITICAL').length,
    high: issues.filter(i => i.severity === 'HIGH').length,
    medium: issues.filter(i => i.severity === 'MEDIUM').length,
    low: issues.filter(i => i.severity === 'LOW').length,
    total: issues.length,
    filesReviewed: fileCount,
  };
}

function determineRecommendation(summary: ReviewSummary, stage1Passed: boolean): ReviewRecommendation {
  if (!stage1Passed || summary.critical > 0 || summary.high > 0) {
    return 'REQUEST_CHANGES';
  }
  if (summary.medium > 0) {
    return 'COMMENT';
  }
  return 'APPROVE';
}
```
  </action>
  <verify>npm run build passes</verify>
  <done>runReview performs 2-stage review with checklist and metrics analysis</done>
</task>

<task type="auto">
  <name>Task 3: Implement reporter and integrate module</name>
  <files>src/quality/review/reporter.ts, src/quality/review/index.ts, src/quality/index.ts</files>
  <action>
**reporter.ts** - Markdown report generation:
```typescript
import type { ReviewResult, ReviewIssue, ReviewSummary, ReviewSeverity } from './types.js';

/**
 * Generate markdown review report
 */
export function generateReport(result: ReviewResult): string {
  const lines: string[] = [];

  lines.push('## Code Review Summary');
  lines.push('');
  lines.push(`**Files Reviewed:** ${result.summary.filesReviewed}`);
  lines.push(`**Total Issues:** ${result.summary.total}`);
  lines.push(`**Duration:** ${result.duration}ms`);
  lines.push('');

  // Stage status
  lines.push('### Review Stages');
  lines.push(`- Stage 1 (Spec Compliance): ${result.stage1Passed ? 'PASS' : 'FAIL'}`);
  lines.push(`- Stage 2 (Code Quality): ${result.stage2Passed ? 'PASS' : 'FAIL'}`);
  lines.push('');

  // By severity
  lines.push('### Issues by Severity');
  lines.push(`- CRITICAL: ${result.summary.critical} (must fix)`);
  lines.push(`- HIGH: ${result.summary.high} (should fix)`);
  lines.push(`- MEDIUM: ${result.summary.medium} (consider fixing)`);
  lines.push(`- LOW: ${result.summary.low} (optional)`);
  lines.push('');

  // Recommendation
  lines.push('### Recommendation');
  lines.push(`**${result.recommendation}**`);
  lines.push('');

  // Issues list
  if (result.issues.length > 0) {
    lines.push('### Issues');
    lines.push('');

    // Group by severity
    for (const severity of ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'] as const) {
      const severityIssues = result.issues.filter(i => i.severity === severity);
      if (severityIssues.length > 0) {
        lines.push(`#### ${severity}`);
        lines.push('');
        for (const issue of severityIssues) {
          lines.push(formatIssue(issue));
          lines.push('');
        }
      }
    }
  }

  return lines.join('\n');
}

/**
 * Format a single issue for display
 */
export function formatIssue(issue: ReviewIssue): string {
  const lines: string[] = [];

  lines.push(`**[${issue.code}] ${issue.description}**`);
  lines.push(`File: \`${issue.file}:${issue.line}\``);
  if (issue.snippet) {
    lines.push('```');
    lines.push(issue.snippet);
    lines.push('```');
  }
  lines.push(`Fix: ${issue.fix}`);

  return lines.join('\n');
}

/**
 * Count issues by severity
 */
export function countBySeverity(issues: ReviewIssue[]): Record<ReviewSeverity, number> {
  return {
    CRITICAL: issues.filter(i => i.severity === 'CRITICAL').length,
    HIGH: issues.filter(i => i.severity === 'HIGH').length,
    MEDIUM: issues.filter(i => i.severity === 'MEDIUM').length,
    LOW: issues.filter(i => i.severity === 'LOW').length,
  };
}
```

**index.ts**:
```typescript
export * from './types.js';
export * from './checklist.js';
export * from './analyzer.js';
export * from './reporter.js';
```

**Update src/quality/index.ts**:
```typescript
// Quality module - code quality automation

// LSP diagnostics (09-01)
export * from './lsp/index.js';

// AST analysis (09-02)
export * from './ast/index.js';

// Code review (09-03)
export * from './review/index.js';
```
  </action>
  <verify>npm run build; Test: `npx ts-node -e "import {runReview, generateReport} from './src/quality/review/index.js'; runReview(['./src/types.ts']).then(r => console.log(generateReport(r)))"`</verify>
  <done>Review module complete with reporter generating markdown output</done>
</task>

</tasks>

<verification>
1. `npm run build` - No compilation errors
2. runReview(['./src/types.ts']) returns ReviewResult
3. generateReport() produces valid markdown with severity sections
4. 2-stage process: diagnostics (stage1) then checklist (stage2)
</verification>

<success_criteria>
- types.ts defines ReviewResult, ReviewIssue, ReviewSeverity, ReviewChecklist
- checklist.ts exports DEFAULT_CHECKLIST with security, quality, performance, best-practices
- analyzer.ts exports runReview(files, options) with 2-stage process
- reporter.ts exports generateReport(result) returning markdown
- Module integrated into src/quality/index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/09-code-quality/09-03-SUMMARY.md`
</output>

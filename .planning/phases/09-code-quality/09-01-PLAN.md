---
phase: 09-code-quality
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/quality/lsp/types.ts
  - src/quality/lsp/diagnostics.ts
  - src/quality/lsp/parser.ts
  - src/quality/lsp/index.ts
autonomous: true

must_haves:
  truths:
    - "runDiagnostics() returns structured error/warning counts"
    - "parseDiagnosticOutput() extracts file, line, severity, message"
    - "DiagnosticResult includes per-file breakdown and summary"
  artifacts:
    - path: "src/quality/lsp/types.ts"
      provides: "LSP diagnostic types (DiagnosticItem, DiagnosticResult, DiagnosticStrategy)"
      exports: ["DiagnosticItem", "DiagnosticResult", "DiagnosticStrategy", "DiagnosticSeverity"]
      min_lines: 40
    - path: "src/quality/lsp/diagnostics.ts"
      provides: "runDiagnostics function wrapping tsc/lsp strategies"
      exports: ["runDiagnostics"]
      min_lines: 60
    - path: "src/quality/lsp/parser.ts"
      provides: "parseDiagnosticOutput parsing tsc --noEmit output"
      exports: ["parseDiagnosticOutput", "groupByFile", "countBySeverity"]
      min_lines: 50
    - path: "src/quality/lsp/index.ts"
      provides: "Module barrel export"
      min_lines: 5
  key_links:
    - from: "src/quality/lsp/diagnostics.ts"
      to: "child_process"
      via: "execa or spawn for tsc --noEmit"
      pattern: "exec.*tsc"
---

<objective>
Implement LSP diagnostics wrapper for project-level type checking.

Purpose: Enable automated code quality checks after task completion by wrapping TypeScript compiler diagnostics.
Output: `src/quality/lsp/` module with types, runner, and output parser.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Reference patterns
@references/oh-my-claudecode/src/tools/lsp-tools.ts (lspDiagnosticsDirectoryTool pattern)
@src/types.ts (existing type conventions)
@src/state/types.ts (StateEvent patterns for future integration)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define LSP diagnostic types</name>
  <files>src/quality/lsp/types.ts</files>
  <action>
Create type definitions for LSP diagnostics:

```typescript
// DiagnosticSeverity enum matching LSP/tsc levels
export type DiagnosticSeverity = 'error' | 'warning' | 'info' | 'hint';

// Individual diagnostic item
export interface DiagnosticItem {
  file: string;
  line: number;
  column: number;
  severity: DiagnosticSeverity;
  code: string | number;
  message: string;
}

// Strategy configuration
export interface DiagnosticStrategy {
  type: 'tsc' | 'lsp' | 'auto';
  timeout?: number;  // default 60000ms
  minSeverity?: DiagnosticSeverity;  // filter threshold
}

// Result of running diagnostics
export interface DiagnosticResult {
  success: boolean;
  strategy: 'tsc' | 'lsp';
  diagnostics: DiagnosticItem[];
  summary: DiagnosticSummary;
  duration: number;  // ms
  error?: string;
}

export interface DiagnosticSummary {
  errorCount: number;
  warningCount: number;
  infoCount: number;
  hintCount: number;
  fileCount: number;
}
```

Use JSDoc comments for all exports. Follow existing src/types.ts conventions (sections with `// ============`).
  </action>
  <verify>npm run build passes with no type errors in new file</verify>
  <done>types.ts exports all diagnostic-related interfaces</done>
</task>

<task type="auto">
  <name>Task 2: Implement diagnostic runner and parser</name>
  <files>src/quality/lsp/diagnostics.ts, src/quality/lsp/parser.ts</files>
  <action>
**parser.ts** - Parse tsc output:
```typescript
import { DiagnosticItem, DiagnosticSeverity, DiagnosticSummary } from './types.js';

// Parse tsc --noEmit output
// Format: "src/file.ts(10,5): error TS2322: Type 'string' is not assignable..."
export function parseDiagnosticOutput(output: string): DiagnosticItem[] {
  const lines = output.split('\n');
  const items: DiagnosticItem[] = [];
  const regex = /^(.+)\((\d+),(\d+)\):\s+(error|warning)\s+(TS\d+):\s+(.+)$/;
  // ... parse each line
}

export function groupByFile(items: DiagnosticItem[]): Map<string, DiagnosticItem[]>;
export function countBySeverity(items: DiagnosticItem[]): DiagnosticSummary;
```

**diagnostics.ts** - Run diagnostics:
```typescript
import { execSync, spawn } from 'child_process';
import { existsSync } from 'fs';
import { join } from 'path';
import { DiagnosticResult, DiagnosticStrategy } from './types.js';
import { parseDiagnosticOutput, countBySeverity } from './parser.js';

// Auto-detect: use tsc if tsconfig.json exists
function detectStrategy(directory: string): 'tsc' | 'lsp' {
  return existsSync(join(directory, 'tsconfig.json')) ? 'tsc' : 'lsp';
}

// Main entry point
export async function runDiagnostics(
  directory: string,
  options?: Partial<DiagnosticStrategy>
): Promise<DiagnosticResult> {
  const strategy = options?.type === 'auto' || !options?.type
    ? detectStrategy(directory)
    : options.type;

  const start = Date.now();

  if (strategy === 'tsc') {
    return runTscDiagnostics(directory, options?.timeout ?? 60000);
  }
  // LSP fallback (stub for now - just return empty)
  return { success: true, strategy: 'lsp', diagnostics: [], summary: {...}, duration: Date.now() - start };
}

async function runTscDiagnostics(directory: string, timeout: number): Promise<DiagnosticResult>;
```

Use `child_process.execSync` with `{ cwd: directory, encoding: 'utf-8', stdio: ['pipe', 'pipe', 'pipe'] }` to capture both stdout and stderr. TypeScript errors go to stderr.
  </action>
  <verify>Create test file with type error, run manually: `npx ts-node -e "import {runDiagnostics} from './src/quality/lsp/diagnostics.js'; runDiagnostics('.').then(console.log)"`</verify>
  <done>runDiagnostics returns parsed DiagnosticResult with accurate error counts</done>
</task>

<task type="auto">
  <name>Task 3: Create module index and integrate</name>
  <files>src/quality/lsp/index.ts, src/quality/index.ts, src/index.ts</files>
  <action>
**src/quality/lsp/index.ts**:
```typescript
export * from './types.js';
export * from './diagnostics.js';
export * from './parser.js';
```

**src/quality/index.ts** (create new):
```typescript
// Quality module - code quality automation
export * from './lsp/index.js';
```

**src/index.ts** - Add quality module export:
```typescript
// Add after sync module
// Quality module (Phase 9: code quality automation)
export * from './quality/index.js';
```
  </action>
  <verify>npm run build succeeds; exports visible: `npm run build && node -e "import * as u from './dist/index.js'; console.log(Object.keys(u).filter(k => k.includes('Diagnostic')))"`</verify>
  <done>Quality module exported from main index, build passes</done>
</task>

</tasks>

<verification>
1. `npm run build` - No compilation errors
2. All exports available from `ultra-planner` package
3. runDiagnostics('.') returns valid DiagnosticResult structure
</verification>

<success_criteria>
- types.ts defines DiagnosticItem, DiagnosticResult, DiagnosticStrategy, DiagnosticSummary
- diagnostics.ts exports runDiagnostics(directory, options?) returning Promise<DiagnosticResult>
- parser.ts exports parseDiagnosticOutput, groupByFile, countBySeverity
- Module exported from src/index.ts
- tsc strategy detects tsconfig.json and runs `tsc --noEmit`
</success_criteria>

<output>
After completion, create `.planning/phases/09-code-quality/09-01-SUMMARY.md`
</output>

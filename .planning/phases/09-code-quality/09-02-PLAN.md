---
phase: 09-code-quality
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - package.json
  - src/quality/ast/types.ts
  - src/quality/ast/analyzer.ts
  - src/quality/ast/patterns.ts
  - src/quality/ast/metrics.ts
  - src/quality/ast/index.ts
  - src/quality/index.ts
autonomous: true

must_haves:
  truths:
    - "analyzeFile() extracts functions, classes, and exports from TypeScript files"
    - "calculateMetrics() returns line counts, function sizes, complexity estimates"
    - "PATTERNS constant provides reusable ast-grep patterns for common structures"
  artifacts:
    - path: "src/quality/ast/types.ts"
      provides: "AST analysis types (CodeStructure, FunctionInfo, ClassInfo, CodeMetrics)"
      exports: ["CodeStructure", "FunctionInfo", "ClassInfo", "ExportInfo", "ImportInfo", "CodeMetrics"]
      min_lines: 50
    - path: "src/quality/ast/analyzer.ts"
      provides: "analyzeFile and analyzeDirectory functions"
      exports: ["analyzeFile", "analyzeDirectory"]
      min_lines: 80
    - path: "src/quality/ast/patterns.ts"
      provides: "AST patterns for TypeScript constructs"
      exports: ["PATTERNS", "getPatternForLanguage"]
      min_lines: 40
    - path: "src/quality/ast/metrics.ts"
      provides: "Code metrics calculation"
      exports: ["calculateMetrics", "calculateComplexity"]
      min_lines: 50
    - path: "src/quality/ast/index.ts"
      provides: "Module barrel export"
      min_lines: 5
  key_links:
    - from: "src/quality/ast/analyzer.ts"
      to: "@ast-grep/napi"
      via: "dynamic import for ESM compatibility"
      pattern: "import.*@ast-grep/napi"
---

<objective>
Implement AST parser for TypeScript code structure analysis.

Purpose: Extract code structure information (functions, classes, exports) and calculate metrics for quality assessment.
Output: `src/quality/ast/` module with analyzer, patterns, and metrics.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Reference patterns
@references/oh-my-claudecode/src/tools/ast-tools.ts (ast-grep integration pattern)
@src/types.ts (existing type conventions)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define AST types and patterns</name>
  <files>src/quality/ast/types.ts, src/quality/ast/patterns.ts</files>
  <action>
**types.ts** - Code structure types:
```typescript
// ============================================================================
// Code Structure Types
// ============================================================================

export interface FunctionInfo {
  name: string;
  file: string;
  startLine: number;
  endLine: number;
  lineCount: number;
  params: string[];
  isAsync: boolean;
  isExported: boolean;
}

export interface ClassInfo {
  name: string;
  file: string;
  startLine: number;
  endLine: number;
  lineCount: number;
  methods: string[];
  properties: string[];
  isExported: boolean;
}

export interface ExportInfo {
  name: string;
  type: 'function' | 'class' | 'const' | 'type' | 'interface' | 'default';
  file: string;
  line: number;
}

export interface ImportInfo {
  source: string;
  names: string[];
  isDefault: boolean;
  file: string;
  line: number;
}

export interface CodeStructure {
  functions: FunctionInfo[];
  classes: ClassInfo[];
  exports: ExportInfo[];
  imports: ImportInfo[];
}

// ============================================================================
// Code Metrics Types
// ============================================================================

export interface CodeMetrics {
  totalLines: number;
  codeLines: number;  // excluding blank/comments
  functionCount: number;
  classCount: number;
  exportCount: number;
  importCount: number;
  avgFunctionSize: number;
  maxFunctionSize: number;
  largestFunction: string | null;
  complexity: number;  // cyclomatic complexity estimate
}

export interface FileAnalysis {
  file: string;
  structure: CodeStructure;
  metrics: CodeMetrics;
}
```

**patterns.ts** - AST patterns:
```typescript
// AST-grep patterns for TypeScript analysis
// See: https://ast-grep.github.io/guide/pattern-syntax.html

export const PATTERNS = {
  // Functions
  functionDeclaration: 'function $NAME($$$PARAMS) { $$$BODY }',
  asyncFunction: 'async function $NAME($$$PARAMS) { $$$BODY }',
  arrowFunction: 'const $NAME = ($$$PARAMS) => $BODY',
  asyncArrowFunction: 'const $NAME = async ($$$PARAMS) => $BODY',
  methodDefinition: '$NAME($$$PARAMS) { $$$BODY }',

  // Classes
  classDeclaration: 'class $NAME { $$$BODY }',
  classWithExtends: 'class $NAME extends $PARENT { $$$BODY }',

  // Exports
  exportDefault: 'export default $EXPR',
  exportNamed: 'export { $$$NAMES }',
  exportConst: 'export const $NAME = $VALUE',
  exportFunction: 'export function $NAME($$$PARAMS) { $$$BODY }',
  exportClass: 'export class $NAME { $$$BODY }',
  exportType: 'export type $NAME = $TYPE',
  exportInterface: 'export interface $NAME { $$$BODY }',

  // Imports
  importDefault: "import $NAME from '$SOURCE'",
  importNamed: "import { $$$NAMES } from '$SOURCE'",
  importAll: "import * as $NAME from '$SOURCE'",
} as const;

export type PatternKey = keyof typeof PATTERNS;

// Get patterns applicable to a language
export function getPatternForLanguage(language: 'typescript' | 'javascript'): typeof PATTERNS {
  // Same patterns work for both TS and JS in ast-grep
  return PATTERNS;
}
```

Use JSDoc comments for documentation.
  </action>
  <verify>npm i @ast-grep/napi && npm run build passes with types.ts and patterns.ts</verify>
  <done>AST types and patterns defined with full exports</done>
</task>

<task type="auto">
  <name>Task 2: Implement AST analyzer and metrics</name>
  <files>src/quality/ast/analyzer.ts, src/quality/ast/metrics.ts</files>
  <action>
**analyzer.ts** - Core analysis functions:
```typescript
import { readFileSync, readdirSync, statSync } from 'fs';
import { join, extname } from 'path';
import type { CodeStructure, FunctionInfo, ClassInfo, ExportInfo, ImportInfo, FileAnalysis } from './types.js';
import { PATTERNS } from './patterns.js';
import { calculateMetrics } from './metrics.js';

// Dynamic import for ESM module
let sgModule: typeof import('@ast-grep/napi') | null = null;

async function getSgModule() {
  if (!sgModule) {
    sgModule = await import('@ast-grep/napi');
  }
  return sgModule;
}

// Analyze a single file
export async function analyzeFile(filePath: string): Promise<FileAnalysis> {
  const sg = await getSgModule();
  const content = readFileSync(filePath, 'utf-8');

  const ext = extname(filePath).toLowerCase();
  const lang = ext === '.tsx' ? sg.Lang.Tsx
    : ext === '.ts' ? sg.Lang.TypeScript
    : sg.Lang.JavaScript;

  const root = sg.parse(lang, content).root();

  const structure: CodeStructure = {
    functions: extractFunctions(root, filePath, content),
    classes: extractClasses(root, filePath, content),
    exports: extractExports(root, filePath),
    imports: extractImports(root, filePath),
  };

  return {
    file: filePath,
    structure,
    metrics: calculateMetrics(content, structure),
  };
}

// Analyze directory recursively
export async function analyzeDirectory(
  dirPath: string,
  options?: { extensions?: string[]; exclude?: string[] }
): Promise<FileAnalysis[]> {
  const extensions = options?.extensions ?? ['.ts', '.tsx', '.js', '.jsx'];
  const exclude = options?.exclude ?? ['node_modules', 'dist', '.git'];

  const files = collectFiles(dirPath, extensions, exclude);
  const results: FileAnalysis[] = [];

  for (const file of files) {
    try {
      results.push(await analyzeFile(file));
    } catch {
      // Skip files that fail to parse
    }
  }

  return results;
}

// Helper: collect files recursively
function collectFiles(dir: string, extensions: string[], exclude: string[]): string[];

// Helper: extract functions using ast-grep
function extractFunctions(root: any, filePath: string, content: string): FunctionInfo[];

// Helper: extract classes using ast-grep
function extractClasses(root: any, filePath: string, content: string): ClassInfo[];

// Helper: extract exports
function extractExports(root: any, filePath: string): ExportInfo[];

// Helper: extract imports
function extractImports(root: any, filePath: string): ImportInfo[];
```

Implement each helper function. Use `root.findAll(pattern)` for matching. Calculate line counts from `match.range()`.

**metrics.ts** - Metrics calculation:
```typescript
import type { CodeStructure, CodeMetrics } from './types.js';

export function calculateMetrics(content: string, structure: CodeStructure): CodeMetrics {
  const lines = content.split('\n');
  const totalLines = lines.length;

  // Count non-blank, non-comment lines (simple heuristic)
  const codeLines = lines.filter(l => {
    const trimmed = l.trim();
    return trimmed && !trimmed.startsWith('//') && !trimmed.startsWith('/*') && !trimmed.startsWith('*');
  }).length;

  const functionSizes = structure.functions.map(f => f.lineCount);
  const maxFunctionSize = Math.max(0, ...functionSizes);
  const avgFunctionSize = functionSizes.length > 0
    ? functionSizes.reduce((a, b) => a + b, 0) / functionSizes.length
    : 0;

  return {
    totalLines,
    codeLines,
    functionCount: structure.functions.length,
    classCount: structure.classes.length,
    exportCount: structure.exports.length,
    importCount: structure.imports.length,
    avgFunctionSize: Math.round(avgFunctionSize * 10) / 10,
    maxFunctionSize,
    largestFunction: maxFunctionSize > 0
      ? structure.functions.find(f => f.lineCount === maxFunctionSize)?.name ?? null
      : null,
    complexity: calculateComplexity(structure),
  };
}

// Simple cyclomatic complexity estimate
export function calculateComplexity(structure: CodeStructure): number {
  // Base complexity: 1 per function + estimated branches
  // This is a rough estimate without full AST branch analysis
  return structure.functions.length + structure.classes.length;
}
```
  </action>
  <verify>Test: `npx ts-node -e "import {analyzeFile} from './src/quality/ast/analyzer.js'; analyzeFile('./src/types.ts').then(r => console.log(JSON.stringify(r.metrics, null, 2)))"`</verify>
  <done>analyzeFile returns FileAnalysis with structure and metrics</done>
</task>

<task type="auto">
  <name>Task 3: Create AST module index and integrate</name>
  <files>src/quality/ast/index.ts, src/quality/index.ts</files>
  <action>
**src/quality/ast/index.ts**:
```typescript
export * from './types.js';
export * from './patterns.js';
export * from './analyzer.js';
export * from './metrics.js';
```

**src/quality/index.ts** - Update to include AST:
```typescript
// Quality module - code quality automation

// LSP diagnostics (09-01)
export * from './lsp/index.js';

// AST analysis (09-02)
export * from './ast/index.js';
```

Note: This depends on 09-01 completing first, but both are Wave 1. If 09-01 hasn't run yet, create the quality/index.ts file fresh without the LSP export, then it will be added by 09-01.
  </action>
  <verify>npm run build succeeds; `node -e "import {analyzeFile, PATTERNS} from './dist/index.js'; console.log('OK')"`</verify>
  <done>AST module fully exported from main package</done>
</task>

</tasks>

<verification>
1. `npm i @ast-grep/napi` - Install ast-grep dependency first
2. `npm run build` - No compilation errors
3. analyzeFile('./src/types.ts') returns valid FileAnalysis
4. All AST types and patterns exported from package
</verification>

<success_criteria>
- types.ts defines CodeStructure, FunctionInfo, ClassInfo, CodeMetrics
- patterns.ts exports PATTERNS with ast-grep patterns for TS/JS
- analyzer.ts exports analyzeFile(path) and analyzeDirectory(dir, options)
- metrics.ts exports calculateMetrics and calculateComplexity
- Module exported from src/quality/index.ts and src/index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/09-code-quality/09-02-SUMMARY.md`
</output>

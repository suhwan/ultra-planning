---
phase: 14-artifact-pattern
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - src/prompts/worker.ts
  - src/prompts/orchestrator.ts
  - src/prompts/types.ts
autonomous: true

must_haves:
  truths:
    - "generateWorkerPrompt outputs artifact references instead of full context strings"
    - "Worker prompt includes 'use Read tool' instruction for JIT loading"
    - "PromptContext type accepts ArtifactReference[] instead of string"
  artifacts:
    - path: "src/prompts/worker.ts"
      provides: "Updated worker prompt with artifact references"
      exports: ["generateWorkerPrompt", "generateWorkerPromptString"]
    - path: "src/prompts/orchestrator.ts"
      provides: "Updated orchestrator prompt with artifact references"
      exports: ["generateOrchestratorPrompt", "generateOrchestratorPromptString"]
    - path: "src/prompts/types.ts"
      provides: "Updated types with artifact support"
      exports: ["WorkerPromptConfig", "PromptContext"]
  key_links:
    - from: "src/prompts/worker.ts"
      to: "src/artifacts/index.ts"
      via: "import formatArtifactList"
      pattern: "import.*formatArtifactList"
    - from: "src/prompts/types.ts"
      to: "src/artifacts/types.ts"
      via: "ArtifactReference type"
      pattern: "ArtifactReference"
---

<objective>
Modify generate_worker_prompt to use artifact references instead of embedding full context.

Purpose: Transform worker prompts from context dumping (full file contents) to JIT loading (paths + summaries). Workers will use Read tool to load files on-demand, reducing prompt tokens by ~50%.

Output: Updated worker/orchestrator prompts that output artifact references.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/v4.0-VISION.md
@.planning/phases/14-artifact-pattern/14-01-SUMMARY.md
@src/prompts/types.ts
@src/prompts/worker.ts
@src/prompts/orchestrator.ts
@src/artifacts/types.ts
@src/artifacts/reference.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update PromptContext type to support artifacts</name>
  <files>src/prompts/types.ts</files>
  <action>
Update the PromptContext interface to support both legacy string context and new artifact references:

Add import at top:
```typescript
import type { ArtifactReference, ArtifactCollection } from '../artifacts/types.js';
```

Update PromptContext interface:
```typescript
/**
 * Context to inject into prompts
 *
 * Supports two modes:
 * 1. Legacy: String-based context (full content embedded)
 * 2. Artifact: Reference-based context (JIT loading)
 *
 * Use artifacts for token efficiency (~50% savings).
 */
export interface PromptContext {
  /** Project-level context (PROJECT.md summary) - LEGACY */
  project?: string;
  /** Current phase context (ROADMAP.md) - LEGACY */
  phase?: string;
  /** Accumulated wisdom (learnings, decisions) - LEGACY */
  wisdom?: string;
  /** Current plan context (PLAN.md) - LEGACY */
  plan?: string;
  /** Additional context - LEGACY */
  extra?: Record<string, string>;

  /**
   * Artifact references for JIT loading (preferred)
   *
   * When provided, generates artifact list instead of embedding content.
   * Agents use Read tool to load files on-demand.
   */
  artifacts?: ArtifactReference[];

  /**
   * Grouped artifact collections
   *
   * For organizing related artifacts (e.g., project vs phase context).
   */
  artifactCollections?: ArtifactCollection[];
}
```

Add new interface for artifact-only context:
```typescript
/**
 * Context using only artifact references (no embedded content)
 *
 * Use this for maximum token efficiency.
 */
export interface ArtifactPromptContext {
  /** Artifact references for JIT loading */
  artifacts: ArtifactReference[];
  /** Optional grouped collections */
  collections?: ArtifactCollection[];
  /** Wisdom summary (brief, not full content) */
  wisdomSummary?: string;
}
```
  </action>
  <verify>
Run `npx tsc --noEmit src/prompts/types.ts` - should compile with no errors.
  </verify>
  <done>
PromptContext now supports both legacy string fields and new artifacts/artifactCollections fields. New ArtifactPromptContext type added for artifact-only usage.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update generateWorkerPrompt for artifact-based context</name>
  <files>src/prompts/worker.ts</files>
  <action>
Update worker prompt generation to use artifact references when available:

Add imports at top:
```typescript
import { formatArtifactList, formatArtifactCollection } from '../artifacts/index.js';
```

Add helper function to format context (either legacy or artifact-based):
```typescript
/**
 * Format context section for prompt
 *
 * Uses artifact references if available, falls back to legacy string embedding.
 */
function formatContextSection(config: WorkerPromptConfig): string {
  const sections: string[] = [];

  // Prefer artifact-based context (JIT loading)
  if (config.context?.artifacts && config.context.artifacts.length > 0) {
    sections.push(formatArtifactList(config.context.artifacts));
  }

  if (config.context?.artifactCollections) {
    for (const collection of config.context.artifactCollections) {
      sections.push(formatArtifactCollection(collection));
    }
  }

  // If no artifacts, fall back to legacy string context
  if (sections.length === 0) {
    if (config.context?.wisdom) {
      sections.push(`## Accumulated Wisdom\n\n${config.context.wisdom}`);
    }
    if (config.context?.project) {
      sections.push(`## Project Context\n\n${config.context.project}`);
    }
  }

  return sections.join('\n\n');
}
```

Update the main generateWorkerPrompt function to use artifact-based context section.

Replace the hardcoded context sections at the end of the prompt template:
```typescript
// OLD (remove these lines):
// ${config.learnings ? `## Relevant Learnings (from previous sessions)\n\n${config.learnings}` : ''}
// ${config.context?.wisdom ? `## Accumulated Wisdom\n\n${config.context.wisdom}` : ''}
// ${config.context?.project ? `## Project Context\n\n${config.context.project}` : ''}

// NEW (replace with):
${formatContextSection(config)}

${config.learnings ? `## Relevant Learnings (from previous sessions)\n\n${config.learnings}` : ''}
```

The key change is that when config.context.artifacts is provided, we output:
```
## Artifacts (use Read tool to load when needed)

- **PROJECT.md** (REQUIRED): `.planning/PROJECT.md`
  Project overview and goals
  (~150 lines)

- **ROADMAP.md**: `.planning/ROADMAP.md`
  Phase definitions and progress
  ...
```

Instead of:
```
## Project Context

[FULL 10,000 character content of PROJECT.md embedded here]
```
  </action>
  <verify>
Run `npx tsc --noEmit src/prompts/worker.ts` - should compile with no errors.
  </verify>
  <done>
generateWorkerPrompt now outputs artifact references when config.context.artifacts is provided. Falls back to legacy string context when artifacts not available.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update generateOrchestratorPrompt for artifact-based context</name>
  <files>src/prompts/orchestrator.ts</files>
  <action>
Apply the same artifact-based context pattern to orchestrator prompts:

Add imports at top:
```typescript
import { formatArtifactList, formatArtifactCollection } from '../artifacts/index.js';
```

Add the same formatContextSection helper (or import from a shared location - for simplicity, duplicate is fine here):
```typescript
/**
 * Format context section for prompt
 */
function formatContextSection(context?: PromptContext): string {
  if (!context) return '';

  const sections: string[] = [];

  // Prefer artifact-based context (JIT loading)
  if (context.artifacts && context.artifacts.length > 0) {
    sections.push(formatArtifactList(context.artifacts));
  }

  if (context.artifactCollections) {
    for (const collection of context.artifactCollections) {
      sections.push(formatArtifactCollection(collection));
    }
  }

  // If no artifacts, fall back to legacy string context
  if (sections.length === 0) {
    if (context.wisdom) {
      sections.push(`## Accumulated Wisdom\n\n${context.wisdom}`);
    }
    if (context.project) {
      sections.push(`## Project Context\n\n${context.project}`);
    }
  }

  return sections.join('\n\n');
}
```

Update the orchestrator prompt template to use formatContextSection:
```typescript
// Replace:
// ${config.context?.wisdom ? `## Accumulated Wisdom\n\n${config.context.wisdom}` : ''}
// ${config.context?.project ? `## Project Context\n\n${config.context.project}` : ''}

// With:
${formatContextSection(config.context)}
```

Add import for PromptContext type if not already imported.
  </action>
  <verify>
Run `npx tsc --noEmit src/prompts/orchestrator.ts` - should compile with no errors.
  </verify>
  <done>
generateOrchestratorPrompt now outputs artifact references when config.context.artifacts is provided. Falls back to legacy string context when artifacts not available.
  </done>
</task>

</tasks>

<verification>
1. All TypeScript files compile without errors: `npm run build`
2. PromptContext type accepts both legacy strings and ArtifactReference[]
3. generateWorkerPrompt with artifacts produces "use Read tool" section
4. generateOrchestratorPrompt with artifacts produces "use Read tool" section
5. Backward compatibility maintained - legacy string context still works
</verification>

<success_criteria>
- [ ] src/prompts/types.ts exports updated PromptContext with artifacts field
- [ ] src/prompts/worker.ts uses formatArtifactList when artifacts provided
- [ ] src/prompts/orchestrator.ts uses formatArtifactList when artifacts provided
- [ ] Both prompt generators fall back to legacy string context when no artifacts
- [ ] `npm run build` passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/14-artifact-pattern/14-02-SUMMARY.md`
</output>

---
phase: 14-artifact-pattern
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/artifacts/types.ts
  - src/artifacts/reference.ts
  - src/artifacts/index.ts
autonomous: true

must_haves:
  truths:
    - "ArtifactReference type contains path, description, and optional summary"
    - "Artifact references can be created from file paths with auto-generated summaries"
    - "Artifact references serialize to JIT-loading format (path only, no content)"
  artifacts:
    - path: "src/artifacts/types.ts"
      provides: "ArtifactReference and related type definitions"
      exports: ["ArtifactReference", "ArtifactSummary", "ArtifactType"]
    - path: "src/artifacts/reference.ts"
      provides: "Artifact reference creation and formatting utilities"
      exports: ["createArtifactReference", "formatArtifactList", "summarizeFile"]
    - path: "src/artifacts/index.ts"
      provides: "Module barrel export"
      exports: ["*"]
  key_links:
    - from: "src/artifacts/reference.ts"
      to: "src/artifacts/types.ts"
      via: "type import"
      pattern: "import.*ArtifactReference"
---

<objective>
Define Artifact Reference types and utilities for JIT loading pattern.

Purpose: Replace context dumping (embedding full file contents) with artifact references (paths + summaries) that agents can Read on demand. This is the foundation for 50% token reduction.

Output: TypeScript types for artifact references and utilities to create/format them.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/v4.0-VISION.md
@src/context/types.ts
@src/prompts/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create artifact types</name>
  <files>src/artifacts/types.ts</files>
  <action>
Create TypeScript type definitions for the artifact reference system:

```typescript
/**
 * Artifact Types - JIT Loading Pattern
 *
 * Artifacts are file references that agents can load on-demand using Read tool.
 * Instead of embedding full content, we provide paths + brief summaries.
 *
 * Based on Google ADK Artifact Pattern for token efficiency.
 */

/**
 * Type of artifact (affects summary generation)
 */
export type ArtifactType =
  | 'project'      // PROJECT.md - project overview
  | 'roadmap'      // ROADMAP.md - phase planning
  | 'plan'         // PLAN.md - task definitions
  | 'summary'      // SUMMARY.md - execution results
  | 'research'     // RESEARCH.md - discovery findings
  | 'source'       // Source code file
  | 'config'       // Configuration file
  | 'other';       // Other files

/**
 * Brief summary of artifact contents
 */
export interface ArtifactSummary {
  /** One-line description of what this file contains */
  description: string;
  /** Key sections or exports (optional) */
  highlights?: string[];
  /** Approximate line count */
  lineCount?: number;
  /** Last modified timestamp */
  modified?: string;
}

/**
 * Reference to an artifact for JIT loading
 *
 * Agents receive this instead of full file contents.
 * They use Read tool to load content when needed.
 */
export interface ArtifactReference {
  /** Absolute or relative path to the file */
  path: string;
  /** Type of artifact (for context) */
  type: ArtifactType;
  /** Brief summary (not full content) */
  summary: ArtifactSummary;
  /** Whether this artifact is required reading */
  required?: boolean;
  /** Tags for filtering */
  tags?: string[];
}

/**
 * Collection of related artifacts
 */
export interface ArtifactCollection {
  /** Human-readable name for this collection */
  name: string;
  /** Artifacts in this collection */
  artifacts: ArtifactReference[];
  /** Usage hint for agents */
  hint?: string;
}

/**
 * Artifact loading instruction for agents
 */
export interface ArtifactLoadingInstruction {
  /** When to load (always, on-demand, conditional) */
  loadStrategy: 'always' | 'on-demand' | 'conditional';
  /** Condition for conditional loading */
  condition?: string;
  /** Priority for on-demand loading (lower = load first) */
  priority?: number;
}
```
  </action>
  <verify>
Run `npx tsc --noEmit src/artifacts/types.ts` - should compile with no errors.
  </verify>
  <done>
Types compile successfully and export ArtifactReference, ArtifactSummary, ArtifactType, ArtifactCollection, ArtifactLoadingInstruction interfaces.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create artifact reference utilities</name>
  <files>src/artifacts/reference.ts</files>
  <action>
Create utilities for creating and formatting artifact references:

```typescript
/**
 * Artifact Reference Utilities
 *
 * Functions to create artifact references from files and format them
 * for inclusion in agent prompts.
 */

import { existsSync, readFileSync, statSync } from 'fs';
import { basename, extname } from 'path';
import type {
  ArtifactReference,
  ArtifactSummary,
  ArtifactType,
  ArtifactCollection,
} from './types.js';

/**
 * Infer artifact type from file path
 */
export function inferArtifactType(filePath: string): ArtifactType {
  const name = basename(filePath).toUpperCase();
  const ext = extname(filePath).toLowerCase();

  if (name === 'PROJECT.MD') return 'project';
  if (name === 'ROADMAP.MD' || name === 'ROADMAP-V2.MD') return 'roadmap';
  if (name.endsWith('-PLAN.MD')) return 'plan';
  if (name.endsWith('-SUMMARY.MD')) return 'summary';
  if (name.endsWith('-RESEARCH.MD')) return 'research';
  if (['.json', '.yaml', '.yml', '.toml', '.env'].includes(ext)) return 'config';
  if (['.ts', '.tsx', '.js', '.jsx', '.py', '.go', '.rs'].includes(ext)) return 'source';

  return 'other';
}

/**
 * Generate a brief summary for a file
 *
 * Reads first few lines and extracts key info without loading full content.
 * For markdown, extracts headings. For code, extracts exports.
 */
export function summarizeFile(filePath: string): ArtifactSummary {
  if (!existsSync(filePath)) {
    return {
      description: 'File not found',
      lineCount: 0,
    };
  }

  const stat = statSync(filePath);
  const content = readFileSync(filePath, 'utf-8');
  const lines = content.split('\n');
  const ext = extname(filePath).toLowerCase();

  // Extract highlights based on file type
  const highlights: string[] = [];

  if (['.md', '.markdown'].includes(ext)) {
    // For markdown, extract top-level headings
    lines.forEach(line => {
      if (line.startsWith('# ') || line.startsWith('## ')) {
        const heading = line.replace(/^#+\s*/, '').trim();
        if (heading && highlights.length < 5) {
          highlights.push(heading);
        }
      }
    });
  } else if (['.ts', '.tsx', '.js', '.jsx'].includes(ext)) {
    // For TypeScript/JavaScript, extract exports
    lines.forEach(line => {
      const exportMatch = line.match(/^export\s+(function|const|class|interface|type)\s+(\w+)/);
      if (exportMatch && highlights.length < 5) {
        highlights.push(`${exportMatch[1]} ${exportMatch[2]}`);
      }
    });
  }

  // Generate description from first non-empty, non-comment line
  let description = basename(filePath);
  for (const line of lines.slice(0, 20)) {
    const trimmed = line.trim();
    if (trimmed && !trimmed.startsWith('#') && !trimmed.startsWith('//') && !trimmed.startsWith('/*')) {
      description = trimmed.slice(0, 100);
      break;
    }
  }

  return {
    description,
    highlights: highlights.length > 0 ? highlights : undefined,
    lineCount: lines.length,
    modified: stat.mtime.toISOString(),
  };
}

/**
 * Create an artifact reference from a file path
 */
export function createArtifactReference(
  filePath: string,
  options?: {
    type?: ArtifactType;
    required?: boolean;
    tags?: string[];
    summary?: Partial<ArtifactSummary>;
  }
): ArtifactReference {
  const type = options?.type ?? inferArtifactType(filePath);
  const autoSummary = summarizeFile(filePath);

  return {
    path: filePath,
    type,
    summary: {
      ...autoSummary,
      ...options?.summary,
    },
    required: options?.required,
    tags: options?.tags,
  };
}

/**
 * Format a single artifact reference for prompt inclusion
 */
export function formatArtifactReference(ref: ArtifactReference): string {
  const required = ref.required ? ' (REQUIRED)' : '';
  const lines = [`- **${basename(ref.path)}**${required}: \`${ref.path}\``];

  lines.push(`  ${ref.summary.description}`);

  if (ref.summary.highlights && ref.summary.highlights.length > 0) {
    lines.push(`  Contains: ${ref.summary.highlights.join(', ')}`);
  }

  if (ref.summary.lineCount) {
    lines.push(`  (~${ref.summary.lineCount} lines)`);
  }

  return lines.join('\n');
}

/**
 * Format multiple artifact references for prompt inclusion
 *
 * Output format optimized for agent consumption:
 * ```
 * ## Artifacts (use Read tool to load when needed)
 *
 * - **PROJECT.md** (REQUIRED): `.planning/PROJECT.md`
 *   Project overview and goals
 *   Contains: Overview, Tech Stack, Success Criteria
 *   (~150 lines)
 *
 * - **ROADMAP.md**: `.planning/ROADMAP.md`
 *   Phase definitions and progress
 *   ...
 * ```
 */
export function formatArtifactList(refs: ArtifactReference[]): string {
  if (refs.length === 0) {
    return '## Artifacts\n\nNo artifacts available.';
  }

  const lines = [
    '## Artifacts (use Read tool to load when needed)',
    '',
  ];

  // Sort: required first, then by type
  const sorted = [...refs].sort((a, b) => {
    if (a.required && !b.required) return -1;
    if (!a.required && b.required) return 1;
    return a.type.localeCompare(b.type);
  });

  for (const ref of sorted) {
    lines.push(formatArtifactReference(ref));
    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Format an artifact collection for prompt inclusion
 */
export function formatArtifactCollection(collection: ArtifactCollection): string {
  const lines = [
    `## ${collection.name}`,
    '',
  ];

  if (collection.hint) {
    lines.push(`> ${collection.hint}`);
    lines.push('');
  }

  lines.push(formatArtifactList(collection.artifacts));

  return lines.join('\n');
}

/**
 * Create a standard project context collection
 */
export function createProjectArtifacts(planningDir: string = '.planning'): ArtifactCollection {
  const artifacts: ArtifactReference[] = [];

  // PROJECT.md - always required
  const projectPath = `${planningDir}/PROJECT.md`;
  if (existsSync(projectPath)) {
    artifacts.push(createArtifactReference(projectPath, { required: true }));
  }

  // ROADMAP.md
  const roadmapV2Path = `${planningDir}/ROADMAP-v2.md`;
  const roadmapPath = `${planningDir}/ROADMAP.md`;
  if (existsSync(roadmapV2Path)) {
    artifacts.push(createArtifactReference(roadmapV2Path));
  } else if (existsSync(roadmapPath)) {
    artifacts.push(createArtifactReference(roadmapPath));
  }

  // REQUIREMENTS.md
  const reqPath = `${planningDir}/REQUIREMENTS.md`;
  if (existsSync(reqPath)) {
    artifacts.push(createArtifactReference(reqPath));
  }

  return {
    name: 'Project Context',
    artifacts,
    hint: 'Load PROJECT.md first for overview. Use ROADMAP.md for phase context.',
  };
}
```
  </action>
  <verify>
Run `npx tsc --noEmit src/artifacts/reference.ts` - should compile with no errors.
  </verify>
  <done>
Reference utilities compile and export createArtifactReference, formatArtifactList, summarizeFile, inferArtifactType, formatArtifactCollection, createProjectArtifacts functions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create module barrel export</name>
  <files>src/artifacts/index.ts</files>
  <action>
Create barrel export for the artifacts module:

```typescript
/**
 * Artifacts Module - JIT Loading Pattern
 *
 * Implements Google ADK Artifact Pattern for token efficiency.
 * Instead of embedding full file contents in prompts, we provide:
 * - File paths (for Read tool)
 * - Brief summaries (for context)
 * - Loading hints (when to read)
 *
 * Token savings: ~50% reduction in prompt size for typical projects.
 *
 * Usage:
 * ```typescript
 * import { createProjectArtifacts, formatArtifactList } from './artifacts';
 *
 * const artifacts = createProjectArtifacts('.planning');
 * const promptSection = formatArtifactList(artifacts.artifacts);
 * // Insert promptSection into worker prompt instead of full file contents
 * ```
 */

// Types
export type {
  ArtifactType,
  ArtifactSummary,
  ArtifactReference,
  ArtifactCollection,
  ArtifactLoadingInstruction,
} from './types.js';

// Reference utilities
export {
  inferArtifactType,
  summarizeFile,
  createArtifactReference,
  formatArtifactReference,
  formatArtifactList,
  formatArtifactCollection,
  createProjectArtifacts,
} from './reference.js';
```
  </action>
  <verify>
Run `npx tsc --noEmit src/artifacts/index.ts` - should compile with no errors.
  </verify>
  <done>
Module exports all types and functions from types.ts and reference.ts.
  </done>
</task>

</tasks>

<verification>
1. All TypeScript files compile without errors: `npm run build`
2. Types are properly exported and can be imported from `src/artifacts/index.js`
3. formatArtifactList produces JIT-loading format with paths (not content)
4. summarizeFile extracts key info without loading full content into prompts
</verification>

<success_criteria>
- [ ] src/artifacts/types.ts exports ArtifactReference, ArtifactSummary, ArtifactType
- [ ] src/artifacts/reference.ts exports createArtifactReference, formatArtifactList, summarizeFile
- [ ] src/artifacts/index.ts barrel exports all types and functions
- [ ] formatArtifactList output contains paths, descriptions, and "use Read tool" hint
- [ ] `npm run build` passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/14-artifact-pattern/14-01-SUMMARY.md`
</output>

---
phase: 14-artifact-pattern
plan: 03
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - src/context/collector.ts
  - src/context/index.ts
autonomous: true

must_haves:
  truths:
    - "collectProjectContext has summary mode that returns ArtifactReference[] instead of full content"
    - "Summary mode reduces output size by ~90% compared to full content mode"
    - "Both modes available via options parameter for backward compatibility"
  artifacts:
    - path: "src/context/collector.ts"
      provides: "Updated collector with summary/artifact mode"
      exports: ["collectProjectContext", "collectProjectContextAsArtifacts"]
    - path: "src/context/index.ts"
      provides: "Updated module exports"
      exports: ["collectProjectContextAsArtifacts"]
  key_links:
    - from: "src/context/collector.ts"
      to: "src/artifacts/index.ts"
      via: "createArtifactReference import"
      pattern: "import.*createArtifactReference"
---

<objective>
Modify collect_project_context to support summary-only mode returning artifact references.

Purpose: Add an alternative mode to collectProjectContext that returns ArtifactReference[] instead of full file contents. This enables callers to choose between full context (legacy) and JIT-loading (artifact references) based on token budget.

Output: Updated collector with collectProjectContextAsArtifacts function.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/v4.0-VISION.md
@.planning/phases/14-artifact-pattern/14-01-SUMMARY.md
@src/context/collector.ts
@src/context/types.ts
@src/artifacts/types.ts
@src/artifacts/reference.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add artifact-based collection functions</name>
  <files>src/context/collector.ts</files>
  <action>
Add new functions to collect context as artifact references instead of full content:

Add imports at top:
```typescript
import type { ArtifactReference, ArtifactCollection } from '../artifacts/types.js';
import { createArtifactReference, createProjectArtifacts } from '../artifacts/index.js';
```

Add new interface for artifact-based context:
```typescript
/**
 * Project context as artifact references (for JIT loading)
 */
export interface ProjectContextArtifacts {
  /** All project-level artifacts */
  artifacts: ArtifactReference[];
  /** Planning directory */
  planningDir: string;
  /** Whether planning directory exists */
  exists: boolean;
  /** Estimated token savings vs full content */
  tokenSavings?: {
    fullContentTokens: number;
    artifactRefTokens: number;
    savingsPercent: number;
  };
}
```

Add function to collect project context as artifacts:
```typescript
/**
 * Collect project-level context as artifact references
 *
 * Returns paths + summaries instead of full content.
 * Use for token efficiency when agents can use Read tool.
 *
 * Token savings: ~90% reduction compared to full content.
 *
 * @param planningDir - Path to .planning directory
 * @returns ProjectContextArtifacts with file references
 *
 * @example
 * ```typescript
 * const ctx = collectProjectContextAsArtifacts();
 * // Returns artifact references, not full content
 * // Agents use Read tool to load files on-demand
 * ```
 */
export function collectProjectContextAsArtifacts(
  planningDir: string = DEFAULT_PLANNING_DIR
): ProjectContextArtifacts {
  const result: ProjectContextArtifacts = {
    artifacts: [],
    planningDir,
    exists: existsSync(planningDir),
  };

  if (!result.exists) {
    return result;
  }

  // Collect PROJECT.md as artifact
  const projectPath = join(planningDir, 'PROJECT.md');
  if (existsSync(projectPath)) {
    result.artifacts.push(
      createArtifactReference(projectPath, { required: true })
    );
  }

  // Collect ROADMAP.md (try v2 first, then v1)
  const roadmapV2Path = join(planningDir, 'ROADMAP-v2.md');
  const roadmapPath = join(planningDir, 'ROADMAP.md');
  if (existsSync(roadmapV2Path)) {
    result.artifacts.push(createArtifactReference(roadmapV2Path));
  } else if (existsSync(roadmapPath)) {
    result.artifacts.push(createArtifactReference(roadmapPath));
  }

  // Collect REQUIREMENTS.md
  const reqPath = join(planningDir, 'REQUIREMENTS.md');
  if (existsSync(reqPath)) {
    result.artifacts.push(createArtifactReference(reqPath));
  }

  // Calculate token savings estimate
  const fullCtx = collectProjectContext(planningDir);
  const fullContentChars =
    (fullCtx.projectMd?.length || 0) +
    (fullCtx.roadmapMd?.length || 0) +
    (fullCtx.requirementsMd?.length || 0);

  // Artifact refs are typically ~200 chars per file
  const artifactRefChars = result.artifacts.length * 200;

  if (fullContentChars > 0) {
    result.tokenSavings = {
      fullContentTokens: Math.ceil(fullContentChars / 4),
      artifactRefTokens: Math.ceil(artifactRefChars / 4),
      savingsPercent: Math.round(
        ((fullContentChars - artifactRefChars) / fullContentChars) * 100
      ),
    };
  }

  return result;
}
```

Add function to collect phase context as artifacts:
```typescript
/**
 * Collect phase-level context as artifact references
 *
 * @param phaseNumber - Phase number
 * @param planningDir - Path to .planning directory
 * @returns Array of artifact references for the phase
 */
export function collectPhaseContextAsArtifacts(
  phaseNumber: number,
  planningDir: string = DEFAULT_PLANNING_DIR
): ArtifactReference[] {
  const artifacts: ArtifactReference[] = [];
  const phaseDir = findPhaseDir(phaseNumber, planningDir);

  if (!phaseDir) {
    return artifacts;
  }

  // Collect RESEARCH.md
  const paddedNum = String(phaseNumber).padStart(2, '0');
  const researchPath = join(phaseDir, `${paddedNum}-RESEARCH.md`);
  if (existsSync(researchPath)) {
    artifacts.push(createArtifactReference(researchPath));
  }

  // Collect PLAN.md files (don't read content, just references)
  for (let i = 1; i <= 20; i++) {
    const planNum = String(i).padStart(2, '0');
    const planPath = join(phaseDir, `${paddedNum}-${planNum}-PLAN.md`);
    if (existsSync(planPath)) {
      artifacts.push(createArtifactReference(planPath));
    }
  }

  // Collect SUMMARY.md files
  for (let i = 1; i <= 20; i++) {
    const planNum = String(i).padStart(2, '0');
    const summaryPath = join(phaseDir, `${paddedNum}-${planNum}-SUMMARY.md`);
    if (existsSync(summaryPath)) {
      artifacts.push(createArtifactReference(summaryPath));
    }
  }

  return artifacts;
}
```

Add function to collect all context as artifacts:
```typescript
/**
 * Collect all relevant context as artifact references
 *
 * Combines project and phase artifacts for JIT loading.
 *
 * @param options - Collection options
 * @returns ArtifactCollection with all references
 */
export function collectContextAsArtifacts(options: {
  planId?: string;
  phaseNumber?: number;
  includeProject?: boolean;
  includePhase?: boolean;
  planningDir?: string;
}): ArtifactCollection {
  const {
    planId,
    phaseNumber,
    includeProject = true,
    includePhase = true,
    planningDir = DEFAULT_PLANNING_DIR,
  } = options;

  const artifacts: ArtifactReference[] = [];

  // Collect project artifacts
  if (includeProject) {
    const projectCtx = collectProjectContextAsArtifacts(planningDir);
    artifacts.push(...projectCtx.artifacts);
  }

  // Determine phase number
  let phase = phaseNumber;
  if (!phase && planId) {
    const [phaseStr] = planId.split('-');
    phase = parseInt(phaseStr, 10);
  }

  // Collect phase artifacts
  if (includePhase && phase) {
    const phaseArtifacts = collectPhaseContextAsArtifacts(phase, planningDir);
    artifacts.push(...phaseArtifacts);
  }

  // Collect task-specific artifact
  if (planId) {
    const taskCtx = collectTaskContext(planId, planningDir);
    if (taskCtx.exists && taskCtx.planPath) {
      // Add specific plan as required
      const planArtifact = createArtifactReference(taskCtx.planPath, {
        required: true,
        tags: ['current-task'],
      });
      // Move to front of list
      const filtered = artifacts.filter(a => a.path !== taskCtx.planPath);
      artifacts.length = 0;
      artifacts.push(planArtifact, ...filtered);
    }
  }

  return {
    name: 'Execution Context',
    artifacts,
    hint: 'Load required artifacts first. Use Read tool for others as needed.',
  };
}
```
  </action>
  <verify>
Run `npx tsc --noEmit src/context/collector.ts` - should compile with no errors.
  </verify>
  <done>
Collector now exports collectProjectContextAsArtifacts, collectPhaseContextAsArtifacts, and collectContextAsArtifacts functions that return artifact references instead of full content.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update module barrel export</name>
  <files>src/context/index.ts</files>
  <action>
Update the context module's index.ts to export the new artifact-based collection functions.

If the file doesn't exist, create it. If it exists, add these exports:

```typescript
/**
 * Context Module
 *
 * Provides context collection and monitoring for AI agent consumption.
 *
 * Two modes:
 * 1. Full content: Legacy mode, embeds file contents (high token usage)
 * 2. Artifact references: JIT loading mode, paths + summaries (low token usage)
 *
 * Use artifact mode for token efficiency:
 * ```typescript
 * import { collectProjectContextAsArtifacts } from './context';
 * const ctx = collectProjectContextAsArtifacts();
 * // ~90% token savings vs full content mode
 * ```
 */

// Types
export type {
  ContextConfig,
  ThresholdStatus,
  ContextAction,
  ContextState,
  ContextUsageResult,
} from './types.js';

export {
  CHARS_PER_TOKEN,
  CLAUDE_DEFAULT_CONTEXT_LIMIT,
  WARNING_THRESHOLD,
  CRITICAL_THRESHOLD,
} from './types.js';

// Collector - Full content mode (legacy)
export type {
  ProjectContext,
  PhaseContext,
  TaskContext,
  CollectedContext,
} from './collector.js';

export {
  collectProjectContext,
  collectPhaseContext,
  collectTaskContext,
  collectContext,
  estimateContextTokens,
  formatContextSummary,
} from './collector.js';

// Collector - Artifact mode (preferred)
export type { ProjectContextArtifacts } from './collector.js';

export {
  collectProjectContextAsArtifacts,
  collectPhaseContextAsArtifacts,
  collectContextAsArtifacts,
} from './collector.js';

// Estimator
export { estimateTokens, createContextTracker } from './estimator.js';

// Monitor
export { ContextMonitor } from './monitor.js';

// Thresholds
export { checkThreshold, getThresholdAction } from './thresholds.js';

// Checkpoint Return
export type { CheckpointReturn } from './checkpoint-return.js';
export { CheckpointReturnBuilder } from './checkpoint-return.js';
```
  </action>
  <verify>
Run `npx tsc --noEmit src/context/index.ts` - should compile with no errors.
  </verify>
  <done>
Module exports all artifact-based collection functions alongside legacy full-content functions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add type export for ProjectContextArtifacts</name>
  <files>src/context/collector.ts</files>
  <action>
Ensure the ProjectContextArtifacts interface is properly exported at the end of the exports section.

The interface should already be defined from Task 1. Verify it's exported:

```typescript
// Near the existing exports, ensure this is present:
export type { ProjectContextArtifacts };
```

Or if using inline export in the interface definition:
```typescript
export interface ProjectContextArtifacts {
  // ... definition from Task 1
}
```

This ensures the type can be imported by other modules.
  </action>
  <verify>
Run `npx tsc --noEmit` on the full project - should have no errors related to ProjectContextArtifacts export.
  </verify>
  <done>
ProjectContextArtifacts type is properly exported from collector.ts and can be imported via context/index.ts.
  </done>
</task>

</tasks>

<verification>
1. All TypeScript files compile without errors: `npm run build`
2. collectProjectContextAsArtifacts returns ArtifactReference[] not full strings
3. Token savings estimate is calculated and included in result
4. Both legacy (full content) and artifact (references) modes work
5. Module exports both modes for backward compatibility
</verification>

<success_criteria>
- [ ] src/context/collector.ts exports collectProjectContextAsArtifacts function
- [ ] src/context/collector.ts exports collectPhaseContextAsArtifacts function
- [ ] src/context/collector.ts exports collectContextAsArtifacts function
- [ ] ProjectContextArtifacts includes tokenSavings estimate
- [ ] src/context/index.ts exports all new functions and types
- [ ] `npm run build` passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/14-artifact-pattern/14-03-SUMMARY.md`
</output>

---
phase: 02-state-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/state/types.ts
  - src/state/state-manager.ts
  - src/state/index.ts
autonomous: true

must_haves:
  truths:
    - "StateManager can read non-existent state files without crashing"
    - "StateManager can write and read back state data correctly"
    - "StateManager update function atomically modifies state"
    - "State files are valid JSON after writes"
  artifacts:
    - path: "src/state/types.ts"
      provides: "State-related type definitions"
      exports: ["StateLocation", "StateReadResult", "StateWriteResult"]
      min_lines: 50
    - path: "src/state/state-manager.ts"
      provides: "Generic StateManager class"
      exports: ["StateManager"]
      min_lines: 60
    - path: "src/state/index.ts"
      provides: "Re-exports for state module"
      exports: ["StateManager", "StateLocation"]
  key_links:
    - from: "src/state/state-manager.ts"
      to: "src/state/types.ts"
      via: "import"
      pattern: "import.*from.*types"
    - from: "src/state/index.ts"
      to: "src/state/state-manager.ts"
      via: "re-export"
      pattern: "export.*from.*state-manager"
---

<objective>
Implement the foundational StateManager class for type-safe file-based state persistence.

Purpose: Provides the core read/write/update operations that all other state management components will use. This is the foundation for event system, mode registry, and checkpoint manager.

Output: A working `StateManager<T>` generic class that can persist any typed state to JSON files in `.ultraplan/state/`.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-state-management/02-RESEARCH.md
@src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create state types</name>
  <files>src/state/types.ts</files>
  <action>
Create state-related type definitions following the patterns from 02-RESEARCH.md.

Include:
1. `StateLocation` enum with LOCAL and GLOBAL values
2. `StateReadResult<T>` interface with exists, data, foundAt fields
3. `StateWriteResult` interface with success, path, error fields
4. `StateClearResult` interface for batch clearing
5. Constants: `STATE_DIR = '.ultraplan/state'`, `STALE_MARKER_THRESHOLD_MS = 60 * 60 * 1000`

Use JSDoc comments for all exports. Do NOT duplicate types already in src/types.ts (ExecutionMode, SessionState are already there).
  </action>
  <verify>
`npx tsc --noEmit` passes without errors
  </verify>
  <done>
src/state/types.ts exists with StateLocation enum and all result interfaces exported
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement StateManager class</name>
  <files>src/state/state-manager.ts</files>
  <action>
Create the generic StateManager class following OMC patterns from research.

Implementation requirements:
1. Constructor takes `name: string` and optional `location: StateLocation` (default LOCAL)
2. `read(): StateReadResult<T>` - reads and parses JSON file, returns {exists: false} if not found
3. `write(data: T): StateWriteResult` - writes data as formatted JSON, ensures directory exists
4. `update(updater: (current: T | undefined) => T): boolean` - atomic read-modify-write
5. `clear(): boolean` - deletes the state file if it exists
6. Private `getPath(): string` - resolves full path based on name and location

Use atomic write pattern: write to .tmp file first, then rename. This prevents corruption.

Use synchronous fs operations (readFileSync, writeFileSync, renameSync) - Claude Code runs synchronously.

Import path, fs from node builtins. Use `mkdirSync({ recursive: true })` for directory creation.
  </action>
  <verify>
`npx tsc --noEmit` passes without errors
  </verify>
  <done>
StateManager class with read/write/update/clear methods, using atomic writes
  </done>
</task>

<task type="auto">
  <name>Task 3: Create index and integration test</name>
  <files>src/state/index.ts</files>
  <action>
Create the module index file that re-exports all state utilities:

```typescript
export * from './types.js';
export * from './state-manager.js';
```

Then update src/index.ts to export the state module:

```typescript
export * from './state/index.js';
```

Finally, verify integration by running a quick smoke test via ts-node or direct compilation check.
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds
3. State module exports are visible from main index
  </verify>
  <done>
State module properly integrated into main package exports
  </done>
</task>

</tasks>

<verification>
All checks must pass:

1. **Type check:** `npx tsc --noEmit` completes without errors
2. **Build:** `npm run build` produces dist/state/*.js files
3. **Exports:** StateManager and StateLocation are exported from package root
4. **File structure:** src/state/ contains types.ts, state-manager.ts, index.ts
</verification>

<success_criteria>
- StateManager<T> class exists and compiles
- Can read non-existent files without error (returns {exists: false})
- Can write and read back typed data
- Atomic write pattern prevents corruption
- All types properly exported
</success_criteria>

<output>
After completion, create `.planning/phases/02-state-management/02-01-SUMMARY.md`
</output>

---
phase: 02-state-management
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/state/types.ts
  - src/state/mode-registry.ts
  - src/state/index.ts
autonomous: true

must_haves:
  truths:
    - "canStartMode returns false when conflicting mode is active"
    - "startMode activates mode and creates state file"
    - "endMode deactivates mode and cleans up state"
    - "getActiveModes returns list of currently active modes"
  artifacts:
    - path: "src/state/mode-registry.ts"
      provides: "Mode registry for mutual exclusion"
      exports: ["canStartMode", "startMode", "endMode", "getActiveModes"]
      min_lines: 100
    - path: "src/state/types.ts"
      provides: "Mode-related types"
      contains: "ModeConfig"
  key_links:
    - from: "src/state/mode-registry.ts"
      to: "src/state/state-manager.ts"
      via: "StateManager usage"
      pattern: "new StateManager"
---

<objective>
Implement mode registry for tracking active execution modes with mutual exclusion.

Purpose: Prevents incompatible modes from running simultaneously (e.g., planning and executing). Provides centralized mode tracking that the orchestrator uses to coordinate agent activities.

Output: Functions to check, start, and end execution modes with automatic conflict detection.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-state-management/02-RESEARCH.md
@.planning/phases/02-state-management/02-01-SUMMARY.md
@src/types.ts
@src/state/types.ts
@src/state/state-manager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mode registry types</name>
  <files>src/state/types.ts</files>
  <action>
Add mode registry types to src/state/types.ts:

1. `ModeConfig` interface:
   - name: string (display name)
   - stateFile: string (filename like 'planning-state.json')
   - markerFile?: string (optional marker file)
   - activeProperty?: string (property to check, default 'active')
   - hasGlobalState?: boolean

2. `ModeStatus` interface:
   - mode: ExecutionMode (import from src/types.ts)
   - active: boolean
   - stateFilePath: string
   - startedAt?: string
   - metadata?: Record<string, unknown>

3. `CanStartResult` interface:
   - allowed: boolean
   - blockedBy?: ExecutionMode
   - message?: string

4. `ModeStateData` interface (internal state file structure):
   - active: boolean
   - startedAt: string
   - pid?: number
   - metadata?: Record<string, unknown>

Import ExecutionMode from '../types.js'.
  </action>
  <verify>
`npx tsc --noEmit` passes without errors
  </verify>
  <done>
Mode registry types added to src/state/types.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement mode registry</name>
  <files>src/state/mode-registry.ts</files>
  <action>
Create mode registry with mutual exclusion following OMC patterns:

1. Define MODE_CONFIGS constant:
   ```typescript
   const MODE_CONFIGS: Partial<Record<ExecutionMode, ModeConfig>> = {
     planning: { name: 'Planning', stateFile: 'planning-state.json', activeProperty: 'active' },
     executing: { name: 'Executing', stateFile: 'execution-state.json', activeProperty: 'active' },
     verifying: { name: 'Verifying', stateFile: 'verification-state.json', activeProperty: 'active' }
   };
   ```

2. Define EXCLUSIVE_MODES array (modes that cannot run together):
   ```typescript
   const EXCLUSIVE_MODES: ExecutionMode[] = ['planning', 'executing', 'verifying'];
   ```

3. `isModeActive(mode: ExecutionMode): boolean`
   - Use StateManager to read mode's state file
   - Check activeProperty value
   - Handle stale markers (older than STALE_MARKER_THRESHOLD_MS)

4. `canStartMode(mode: ExecutionMode): CanStartResult`
   - Check if any EXCLUSIVE_MODE is active
   - Return { allowed: true } or { allowed: false, blockedBy, message }

5. `startMode(mode: ExecutionMode, metadata?: Record<string, unknown>): boolean`
   - Check canStartMode first
   - Write state file with active: true, startedAt, metadata
   - Return success

6. `endMode(mode: ExecutionMode): boolean`
   - Read current state, set active: false
   - Or delete state file entirely
   - Return success

7. `getActiveModes(): ModeStatus[]`
   - Check all configured modes
   - Return array of active ModeStatus objects

8. `getModeConfig(mode: ExecutionMode): ModeConfig | undefined`
   - Return config for given mode
  </action>
  <verify>
`npx tsc --noEmit` passes without errors
  </verify>
  <done>
Mode registry with mutual exclusion implemented
  </done>
</task>

<task type="auto">
  <name>Task 3: Export and integration</name>
  <files>src/state/index.ts</files>
  <action>
Add mode registry exports to src/state/index.ts:

```typescript
export * from './mode-registry.js';
```

Verify the exports are accessible from the main package.
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds
3. canStartMode, startMode, endMode, getActiveModes exported from package
  </verify>
  <done>
Mode registry integrated and exported
  </done>
</task>

</tasks>

<verification>
All checks must pass:

1. **Type check:** `npx tsc --noEmit` completes without errors
2. **Build:** `npm run build` produces dist/state/mode-registry.js
3. **Exports:** All mode registry functions exported from package
4. **Types:** ModeConfig, ModeStatus, CanStartResult types available
</verification>

<success_criteria>
- canStartMode detects conflicting exclusive modes
- startMode creates state file with active flag and timestamp
- endMode cleans up mode state
- Stale marker detection prevents deadlocks from crashed processes
- All mode registry functions work with StateManager
</success_criteria>

<output>
After completion, create `.planning/phases/02-state-management/02-03-SUMMARY.md`
</output>

---
phase: 18-hook-system
plan: 04
type: execute
wave: 3
depends_on: ["18-01"]
files_modified:
  - src/hooks/core/background-notification.ts
  - src/hooks/core/session-recovery.ts
  - src/hooks/core/index.ts
autonomous: true

must_haves:
  truths:
    - "Background task completion triggers notification"
    - "Batch notifications for multiple completions"
    - "Session errors trigger recovery hook"
    - "Retry logic for transient failures"
    - "Session state cleanup on deletion"
  artifacts:
    - path: "src/hooks/core/background-notification.ts"
      provides: "Background task notification hook"
      exports: ["createBackgroundNotificationHook", "BackgroundNotificationOptions"]
    - path: "src/hooks/core/session-recovery.ts"
      provides: "Session error recovery hook"
      exports: ["createSessionRecoveryHook", "SessionRecoveryOptions"]
  key_links:
    - from: "src/hooks/core/background-notification.ts"
      to: "src/state/event-system.ts"
      via: "Emits notification events"
      pattern: "emitEvent"
    - from: "src/hooks/core/session-recovery.ts"
      to: "src/state/checkpoint.ts"
      via: "Uses checkpoint for recovery"
      pattern: "CheckpointManager"
---

<objective>
Implement background-notification and session-recovery hooks for task completion alerts and error recovery.

Purpose: Ensure orchestrator is notified of background task completions and can recover from transient errors.
Output: Two production-ready hooks for notifications and recovery.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/18-hook-system/18-RESEARCH.md
@.planning/phases/18-hook-system/18-01-SUMMARY.md

# Reference implementation
@references/oh-my-opencode/src/hooks/background-notification/index.ts

# Existing infrastructure
@src/state/event-system.ts
@src/state/checkpoint.ts
@src/hooks/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Background notification hook</name>
  <files>src/hooks/core/background-notification.ts</files>
  <action>
Create the background-notification hook for task completion alerts:

1. **Configuration**:
   ```typescript
   export interface BackgroundNotificationOptions {
     batchWindow?: number;     // ms to batch notifications (default: 1000)
     maxBatchSize?: number;    // Max notifications per batch (default: 5)
   }
   ```

2. **Task tracking**:
   ```typescript
   interface CompletedTask {
     taskId: string;
     sessionId: string;
     status: 'completed' | 'failed';
     result?: string;
     error?: string;
     completedAt: number;
   }

   interface NotificationState {
     pendingTasks: CompletedTask[];
     batchTimer?: ReturnType<typeof setTimeout>;
   }

   const state: NotificationState = {
     pendingTasks: [],
   };
   ```

3. **Event handling**:
   ```typescript
   // Listen for background task completion events
   const eventHandler = async ({ event }) => {
     if (event.type === 'background_task_completed') {
       const task: CompletedTask = {
         taskId: event.properties?.taskId,
         sessionId: event.properties?.sessionId,
         status: event.properties?.status,
         result: event.properties?.result,
         completedAt: Date.now(),
       };

       addToPendingBatch(task);
     }

     if (event.type === 'session.deleted') {
       // Clear pending notifications for deleted session
       const sessionId = event.properties?.info?.id;
       if (sessionId) {
         state.pendingTasks = state.pendingTasks.filter(
           t => t.sessionId !== sessionId
         );
       }
     }
   };
   ```

4. **Batch notification logic**:
   ```typescript
   function addToPendingBatch(task: CompletedTask): void {
     state.pendingTasks.push(task);

     if (state.pendingTasks.length >= maxBatchSize) {
       // Immediate flush if batch is full
       flushNotifications();
     } else if (!state.batchTimer) {
       // Start batch timer
       state.batchTimer = setTimeout(() => {
         flushNotifications();
       }, batchWindow);
     }
   }

   function flushNotifications(): void {
     if (state.batchTimer) {
       clearTimeout(state.batchTimer);
       state.batchTimer = undefined;
     }

     if (state.pendingTasks.length === 0) return;

     const tasks = [...state.pendingTasks];
     state.pendingTasks = [];

     // Emit batch notification event
     emitEvent({
       type: 'background_tasks_notification',
       payload: {
         tasks,
         count: tasks.length,
         completedCount: tasks.filter(t => t.status === 'completed').length,
         failedCount: tasks.filter(t => t.status === 'failed').length,
       },
       source: 'hook:background-notification',
     });
   }
   ```

5. **Factory function**:
   ```typescript
   export function createBackgroundNotificationHook(
     ctx: HookContext,
     options: BackgroundNotificationOptions = {}
   ): HookHandlers {
     const batchWindow = options.batchWindow ?? 1000;
     const maxBatchSize = options.maxBatchSize ?? 5;

     // Implementation
     return {
       event: eventHandler,
     };
   }
   ```
  </action>
  <verify>npm run build passes; hook batches and emits notification events</verify>
  <done>Background notification hook implemented with batching logic</done>
</task>

<task type="auto">
  <name>Task 2: Session recovery hook</name>
  <files>src/hooks/core/session-recovery.ts</files>
  <action>
Create the session-recovery hook for error recovery:

1. **Configuration**:
   ```typescript
   export interface SessionRecoveryOptions {
     maxRetries?: number;           // Default: 3
     retryDelayMs?: number;         // Default: 1000
     recoverableErrors?: string[];  // Error types to recover from
   }

   const DEFAULT_RECOVERABLE_ERRORS = [
     'RateLimitError',
     'NetworkError',
     'TimeoutError',
     'TransientError',
   ];
   ```

2. **Recovery state tracking**:
   ```typescript
   interface RecoveryState {
     retryCount: number;
     lastError?: string;
     lastErrorAt?: number;
     recovering: boolean;
   }

   const sessionRecovery = new Map<string, RecoveryState>();
   ```

3. **Event handling**:
   ```typescript
   const eventHandler = async ({ event }) => {
     if (event.type === 'session.error') {
       const sessionId = event.properties?.sessionID;
       const error = event.properties?.error as { name?: string; message?: string };

       if (!sessionId || !error) return;

       // Check if error is recoverable
       if (!isRecoverableError(error.name)) {
         emitEvent({
           type: 'session_recovery_failed',
           payload: {
             sessionId,
             error: error.name,
             reason: 'non_recoverable_error',
           },
           source: 'hook:session-recovery',
         });
         return;
       }

       const state = getRecoveryState(sessionId);

       if (state.retryCount >= maxRetries) {
         emitEvent({
           type: 'session_recovery_failed',
           payload: {
             sessionId,
             error: error.name,
             reason: 'max_retries_exceeded',
             retryCount: state.retryCount,
           },
           source: 'hook:session-recovery',
         });
         return;
       }

       // Attempt recovery
       state.retryCount++;
       state.lastError = error.name;
       state.lastErrorAt = Date.now();
       state.recovering = true;

       await attemptRecovery(sessionId, state);
     }

     if (event.type === 'session.deleted') {
       const sessionId = event.properties?.info?.id;
       if (sessionId) sessionRecovery.delete(sessionId);
     }
   };
   ```

4. **Recovery logic**:
   ```typescript
   async function attemptRecovery(
     sessionId: string,
     state: RecoveryState
   ): Promise<void> {
     // Delay before retry
     await new Promise(resolve => setTimeout(resolve, retryDelayMs));

     // Emit recovery attempt event
     emitEvent({
       type: 'session_recovery_attempt',
       payload: {
         sessionId,
         retryCount: state.retryCount,
         lastError: state.lastError,
       },
       source: 'hook:session-recovery',
     });

     // Note: Actual retry would be triggered by orchestrator
     // listening to this event. The hook signals the attempt,
     // the orchestrator decides how to retry.

     state.recovering = false;
   }

   function isRecoverableError(errorName?: string): boolean {
     if (!errorName) return false;
     return recoverableErrors.includes(errorName);
   }
   ```

5. **Checkpoint integration** (optional):
   ```typescript
   // If checkpoint exists, include in recovery event
   async function getCheckpointInfo(sessionId: string): Promise<unknown> {
     try {
       const checkpointManager = new CheckpointManager();
       const checkpoint = checkpointManager.getLatest(sessionId);
       return checkpoint?.data;
     } catch {
       return undefined;
     }
   }
   ```

6. **Factory function**:
   ```typescript
   export function createSessionRecoveryHook(
     ctx: HookContext,
     options: SessionRecoveryOptions = {}
   ): HookHandlers {
     const maxRetries = options.maxRetries ?? 3;
     const retryDelayMs = options.retryDelayMs ?? 1000;
     const recoverableErrors = options.recoverableErrors ?? DEFAULT_RECOVERABLE_ERRORS;

     // Implementation
     return {
       event: eventHandler,
     };
   }
   ```
  </action>
  <verify>npm run build passes; hook handles session.error and emits recovery events</verify>
  <done>Session recovery hook implemented with retry logic and event emission</done>
</task>

<task type="auto">
  <name>Task 3: Update core hooks index</name>
  <files>src/hooks/core/index.ts</files>
  <action>
Update the core hooks barrel export to include new hooks:

```typescript
/**
 * Core Hooks
 *
 * Essential hooks for agent orchestration:
 * - todo-continuation-enforcer: Auto-continue on incomplete tasks
 * - context-window-monitor: Token usage tracking and warnings
 * - background-notification: Task completion alerts with batching
 * - session-recovery: Error recovery with retry logic
 */
export * from './todo-continuation-enforcer.js';
export * from './context-window-monitor-hook.js';
export * from './background-notification.js';
export * from './session-recovery.js';
```

Verify all hooks can be imported:
```typescript
import {
  createTodoContinuationEnforcerHook,
  createContextWindowMonitorHook,
  createBackgroundNotificationHook,
  createSessionRecoveryHook,
} from './hooks';
```
  </action>
  <verify>npm run build passes; all 4 core hooks importable</verify>
  <done>Core hooks index updated with background-notification and session-recovery</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` passes with no errors
2. Both hooks can be created and return valid HookHandlers
3. Background notification batches tasks correctly
4. Session recovery tracks retry counts per session
5. Events emitted to EventSystem
</verification>

<success_criteria>
- Background notification batches completions (1s window, 5 max)
- Notification event includes completed/failed counts
- Session recovery tracks retry count per session
- Recoverable errors configurable
- Recovery events emitted for orchestrator to act on
- Session cleanup on session.deleted for both hooks
</success_criteria>

<output>
After completion, create `.planning/phases/18-hook-system/18-04-SUMMARY.md`
</output>

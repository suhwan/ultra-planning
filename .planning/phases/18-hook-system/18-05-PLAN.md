---
phase: 18-hook-system
plan: 05
type: execute
wave: 3
depends_on: ["18-01"]
files_modified:
  - src/hooks/tool/tool-output-truncator.ts
  - src/hooks/tool/empty-task-response-detector.ts
  - src/hooks/tool/edit-error-recovery.ts
  - src/hooks/tool/delegate-task-retry.ts
  - src/hooks/tool/index.ts
  - src/hooks/context/compaction-context-injector.ts
  - src/hooks/context/keyword-detector.ts
  - src/hooks/context/directory-agents-injector.ts
  - src/hooks/context/index.ts
  - src/hooks/session/session-notification.ts
  - src/hooks/session/auto-slash-command.ts
  - src/hooks/session/index.ts
  - src/hooks/index.ts
autonomous: true

must_haves:
  truths:
    - "Tool hooks process tool execution events"
    - "Context hooks inject content during compaction/prompts"
    - "Session hooks handle session lifecycle"
    - "10+ additional hooks implemented and registered"
    - "All hooks follow factory pattern"
  artifacts:
    - path: "src/hooks/tool/index.ts"
      provides: "Tool-related hooks barrel"
      exports: ["createToolOutputTruncatorHook", "createEmptyTaskResponseDetectorHook", "createEditErrorRecoveryHook", "createDelegateTaskRetryHook"]
    - path: "src/hooks/context/index.ts"
      provides: "Context injection hooks barrel"
      exports: ["createCompactionContextInjectorHook", "createKeywordDetectorHook", "createDirectoryAgentsInjectorHook"]
    - path: "src/hooks/session/index.ts"
      provides: "Session lifecycle hooks barrel"
      exports: ["createSessionNotificationHook", "createAutoSlashCommandHook"]
  key_links:
    - from: "src/hooks/index.ts"
      to: "src/hooks/tool/index.ts"
      via: "Exports all tool hooks"
      pattern: "export.*tool"
    - from: "src/hooks/index.ts"
      to: "src/hooks/context/index.ts"
      via: "Exports all context hooks"
      pattern: "export.*context"
---

<objective>
Implement 10 additional hooks across tool, context, and session categories to complete the core hook system.

Purpose: Provide comprehensive extensibility covering tool execution, context management, and session lifecycle.
Output: 10 production-ready hooks organized by category.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/18-hook-system/18-RESEARCH.md
@.planning/phases/18-hook-system/18-01-SUMMARY.md

# Hook types and registry
@src/hooks/types.ts
@src/hooks/registry.ts

# Existing patterns
@src/orchestration/keywords/patterns.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Tool hooks (4 hooks)</name>
  <files>src/hooks/tool/tool-output-truncator.ts, src/hooks/tool/empty-task-response-detector.ts, src/hooks/tool/edit-error-recovery.ts, src/hooks/tool/delegate-task-retry.ts, src/hooks/tool/index.ts</files>
  <action>
Create 4 tool-related hooks:

**1. tool-output-truncator.ts**:
Truncates large tool outputs to prevent context bloat.
```typescript
export interface ToolOutputTruncatorOptions {
  maxOutputLength?: number;  // Default: 50000 chars
  truncationMessage?: string;
}

export function createToolOutputTruncatorHook(
  ctx: HookContext,
  options: ToolOutputTruncatorOptions = {}
): HookHandlers {
  const maxLength = options.maxOutputLength ?? 50000;
  const truncationMsg = options.truncationMessage ??
    '\n\n[Output truncated - exceeded {max} characters]';

  return {
    'tool.execute.after': async (input, output) => {
      if (output.output.length > maxLength) {
        output.output = output.output.slice(0, maxLength) +
          truncationMsg.replace('{max}', String(maxLength));

        emitEvent({
          type: 'tool_output_truncated',
          payload: {
            tool: input.tool,
            originalLength: output.output.length,
            truncatedTo: maxLength,
          },
          source: 'hook:tool-output-truncator',
        });
      }
    },
  };
}
```

**2. empty-task-response-detector.ts**:
Detects when subagent returns empty/minimal response.
```typescript
export interface EmptyTaskResponseDetectorOptions {
  minResponseLength?: number;  // Default: 50 chars
}

export function createEmptyTaskResponseDetectorHook(
  ctx: HookContext,
  options: EmptyTaskResponseDetectorOptions = {}
): HookHandlers {
  const minLength = options.minResponseLength ?? 50;

  return {
    'tool.execute.after': async (input, output) => {
      if (input.tool === 'Task' && output.output.trim().length < minLength) {
        emitEvent({
          type: 'empty_task_response',
          payload: {
            sessionId: input.sessionID,
            responseLength: output.output.trim().length,
            minExpected: minLength,
          },
          source: 'hook:empty-task-response-detector',
        });

        // Add warning to output
        output.output += `\n\n[WARNING: Task response appears empty or minimal. Consider retrying.]`;
      }
    },
  };
}
```

**3. edit-error-recovery.ts**:
Provides recovery guidance for Edit tool errors.
```typescript
export function createEditErrorRecoveryHook(
  ctx: HookContext
): HookHandlers {
  const EDIT_RECOVERY_HINTS: Record<string, string> = {
    'old_text_not_found': 'The old_text was not found. Try:\n- Reading the file first to get exact content\n- Using smaller, unique text snippets',
    'file_not_found': 'File does not exist. Create it with Write tool first.',
    'permission_denied': 'Permission denied. Check file permissions.',
  };

  return {
    'tool.execute.after': async (input, output) => {
      if (input.tool !== 'Edit') return;

      // Detect error patterns in output
      for (const [errorType, hint] of Object.entries(EDIT_RECOVERY_HINTS)) {
        if (output.output.toLowerCase().includes(errorType.replace(/_/g, ' '))) {
          output.output += `\n\n[Recovery Hint: ${hint}]`;
          emitEvent({
            type: 'edit_error_recovery',
            payload: { errorType, sessionId: input.sessionID },
            source: 'hook:edit-error-recovery',
          });
          break;
        }
      }
    },
  };
}
```

**4. delegate-task-retry.ts**:
Provides fix hints for delegation failures.
```typescript
export function createDelegateTaskRetryHook(
  ctx: HookContext
): HookHandlers {
  const DELEGATION_HINTS: Record<string, string> = {
    'model_not_found': 'Model unavailable. Try: haiku, sonnet, or opus',
    'context_overflow': 'Context too large. Split into smaller tasks.',
    'timeout': 'Task timed out. Consider simpler scope or retry.',
  };

  return {
    'tool.execute.after': async (input, output) => {
      if (input.tool !== 'Task') return;

      for (const [errorType, hint] of Object.entries(DELEGATION_HINTS)) {
        if (output.output.toLowerCase().includes(errorType.replace(/_/g, ' '))) {
          output.output += `\n\n[Delegation Hint: ${hint}]`;
          emitEvent({
            type: 'delegate_task_retry',
            payload: { errorType, sessionId: input.sessionID },
            source: 'hook:delegate-task-retry',
          });
          break;
        }
      }
    },
  };
}
```

**5. Create src/hooks/tool/index.ts**:
```typescript
/**
 * Tool Hooks
 *
 * Hooks for tool execution enhancement:
 * - tool-output-truncator: Limit large outputs
 * - empty-task-response-detector: Detect empty subagent responses
 * - edit-error-recovery: Recovery hints for Edit errors
 * - delegate-task-retry: Hints for delegation failures
 */
export * from './tool-output-truncator.js';
export * from './empty-task-response-detector.js';
export * from './edit-error-recovery.js';
export * from './delegate-task-retry.js';
```
  </action>
  <verify>npm run build passes; all 4 tool hooks export correctly</verify>
  <done>4 tool hooks implemented with proper error detection and hints</done>
</task>

<task type="auto">
  <name>Task 2: Context hooks (3 hooks)</name>
  <files>src/hooks/context/compaction-context-injector.ts, src/hooks/context/keyword-detector.ts, src/hooks/context/directory-agents-injector.ts, src/hooks/context/index.ts</files>
  <action>
Create 3 context injection hooks:

**1. compaction-context-injector.ts**:
Injects critical context during session compaction.
```typescript
export interface CompactionContextInjectorOptions {
  includeDecisions?: boolean;   // Default: true
  includeProgress?: boolean;    // Default: true
  includePendingTasks?: boolean; // Default: true
}

export function createCompactionContextInjectorHook(
  ctx: HookContext,
  options: CompactionContextInjectorOptions = {}
): HookHandlers {
  return {
    'experimental.session.compacting': async (input, output) => {
      const contextParts: string[] = [];

      // Inject from STATE.md if exists
      if (options.includeDecisions !== false) {
        contextParts.push('[Preserved Decisions from STATE.md]');
      }

      if (options.includeProgress !== false) {
        contextParts.push('[Current Progress: Check ROADMAP.md]');
      }

      if (options.includePendingTasks !== false) {
        contextParts.push('[Pending Tasks: Continue from PLAN.md]');
      }

      if (contextParts.length > 0) {
        output.output = `${createSystemDirective(SystemDirectiveTypes.COMPACTION_CONTEXT)}

${contextParts.join('\n')}

${output.output}`;
      }
    },
  };
}
```

**2. keyword-detector.ts**:
Detects magic keywords and emits events (leverages existing patterns.ts).
```typescript
import { detectKeywords, type KeywordMatch } from '../../orchestration/keywords/patterns.js';

export function createKeywordDetectorHook(
  ctx: HookContext
): HookHandlers {
  return {
    'chat.message': async (input, output) => {
      if (input.role !== 'user') return;

      const matches = detectKeywords(input.content);

      if (matches.length > 0) {
        emitEvent({
          type: 'keywords_detected',
          payload: {
            sessionId: input.sessionID,
            keywords: matches.map(m => m.keyword),
            triggers: matches.map(m => m.trigger),
          },
          source: 'hook:keyword-detector',
        });
      }
    },
  };
}
```

**3. directory-agents-injector.ts**:
Injects AGENTS.md content for directory context.
```typescript
export interface DirectoryAgentsInjectorOptions {
  searchParents?: boolean;  // Default: true
  maxDepth?: number;        // Default: 3
}

export function createDirectoryAgentsInjectorHook(
  ctx: HookContext,
  options: DirectoryAgentsInjectorOptions = {}
): HookHandlers {
  const agentsCache = new Map<string, string | null>();

  function findAgentsMd(dir: string, depth: number = 0): string | null {
    if (depth > (options.maxDepth ?? 3)) return null;

    const cached = agentsCache.get(dir);
    if (cached !== undefined) return cached;

    const agentsPath = join(dir, 'AGENTS.md');
    if (existsSync(agentsPath)) {
      const content = readFileSync(agentsPath, 'utf-8');
      agentsCache.set(dir, content);
      return content;
    }

    if (options.searchParents !== false) {
      const parent = dirname(dir);
      if (parent !== dir) {
        return findAgentsMd(parent, depth + 1);
      }
    }

    agentsCache.set(dir, null);
    return null;
  }

  return {
    'tool.execute.before': async (input, output) => {
      // Inject AGENTS.md context for file operations
      if (['Read', 'Write', 'Edit'].includes(input.tool)) {
        const filePath = input.params?.path || input.params?.file_path;
        if (filePath) {
          const dir = dirname(filePath);
          const agentsContent = findAgentsMd(dir);
          if (agentsContent) {
            // Emit event for orchestrator to include
            emitEvent({
              type: 'agents_context_available',
              payload: {
                directory: dir,
                contentPreview: agentsContent.slice(0, 500),
              },
              source: 'hook:directory-agents-injector',
            });
          }
        }
      }
    },
  };
}
```

**4. Create src/hooks/context/index.ts**:
```typescript
/**
 * Context Injection Hooks
 *
 * Hooks for context management:
 * - compaction-context-injector: Preserve context during compaction
 * - keyword-detector: Detect magic keywords
 * - directory-agents-injector: Inject AGENTS.md content
 */
export * from './compaction-context-injector.js';
export * from './keyword-detector.js';
export * from './directory-agents-injector.js';
```
  </action>
  <verify>npm run build passes; all 3 context hooks export correctly</verify>
  <done>3 context hooks implemented for injection and detection</done>
</task>

<task type="auto">
  <name>Task 3: Session hooks and main index update</name>
  <files>src/hooks/session/session-notification.ts, src/hooks/session/auto-slash-command.ts, src/hooks/session/index.ts, src/hooks/index.ts</files>
  <action>
Create 2 session hooks and update main index:

**1. session-notification.ts**:
Desktop notification on session events.
```typescript
export interface SessionNotificationOptions {
  notifyOnIdle?: boolean;     // Default: true
  notifyOnError?: boolean;    // Default: true
  idleTimeoutMs?: number;     // Default: 30000 (30s)
}

export function createSessionNotificationHook(
  ctx: HookContext,
  options: SessionNotificationOptions = {}
): HookHandlers {
  const idleTimers = new Map<string, ReturnType<typeof setTimeout>>();

  return {
    event: async ({ event }) => {
      if (event.type === 'session.idle' && options.notifyOnIdle !== false) {
        const sessionId = event.properties?.sessionID;
        if (!sessionId) return;

        // Start idle timer
        if (idleTimers.has(sessionId)) {
          clearTimeout(idleTimers.get(sessionId)!);
        }

        idleTimers.set(sessionId, setTimeout(() => {
          emitEvent({
            type: 'session_idle_notification',
            payload: {
              sessionId,
              idleDuration: options.idleTimeoutMs ?? 30000,
            },
            source: 'hook:session-notification',
          });
          idleTimers.delete(sessionId);
        }, options.idleTimeoutMs ?? 30000));
      }

      if (event.type === 'session.error' && options.notifyOnError !== false) {
        const sessionId = event.properties?.sessionID;
        const error = event.properties?.error;

        emitEvent({
          type: 'session_error_notification',
          payload: { sessionId, error },
          source: 'hook:session-notification',
        });
      }

      if (event.type === 'session.deleted') {
        const sessionId = event.properties?.info?.id;
        if (sessionId && idleTimers.has(sessionId)) {
          clearTimeout(idleTimers.get(sessionId)!);
          idleTimers.delete(sessionId);
        }
      }
    },
  };
}
```

**2. auto-slash-command.ts**:
Detects and triggers slash commands from messages.
```typescript
const SLASH_COMMAND_PATTERN = /^\/([a-zA-Z][a-zA-Z0-9-]*(?::[a-zA-Z][a-zA-Z0-9-]*)?)\s*(.*)?$/;

export function createAutoSlashCommandHook(
  ctx: HookContext
): HookHandlers {
  return {
    'chat.message': async (input, output) => {
      if (input.role !== 'user') return;

      const match = input.content.trim().match(SLASH_COMMAND_PATTERN);
      if (match) {
        const [, command, args] = match;

        emitEvent({
          type: 'slash_command_detected',
          payload: {
            sessionId: input.sessionID,
            command,
            args: args?.trim() || '',
            fullCommand: input.content.trim(),
          },
          source: 'hook:auto-slash-command',
        });
      }
    },
  };
}
```

**3. Create src/hooks/session/index.ts**:
```typescript
/**
 * Session Lifecycle Hooks
 *
 * Hooks for session management:
 * - session-notification: Desktop notifications
 * - auto-slash-command: Slash command detection
 */
export * from './session-notification.js';
export * from './auto-slash-command.js';
```

**4. Update src/hooks/index.ts** (main barrel):
```typescript
/**
 * Hook System
 *
 * Comprehensive hook infrastructure for extensibility:
 * - Core hooks: continuation, context monitoring, notifications, recovery
 * - Tool hooks: output truncation, error recovery, retry hints
 * - Context hooks: compaction injection, keyword detection, agents injection
 * - Session hooks: notifications, slash commands
 * - Orchestrator hooks: file guard, single task, verification
 */

// Core hook system
export * from './types.js';
export * from './registry.js';
export * from './event-bus.js';

// Hook categories
export * from './core/index.js';
export * from './tool/index.js';
export * from './context/index.js';
export * from './session/index.js';

// Existing orchestrator hooks
export * from './orchestrator/index.js';
```
  </action>
  <verify>npm run build passes; all hooks importable from src/hooks</verify>
  <done>Session hooks and main index completed with all 15 hooks accessible</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` passes with no errors
2. All 10 hooks can be created with factory functions
3. Directory structure matches:
   ```
   src/hooks/
   ├── types.ts
   ├── registry.ts
   ├── event-bus.ts
   ├── index.ts
   ├── core/ (4 hooks)
   ├── tool/ (4 hooks)
   ├── context/ (3 hooks)
   ├── session/ (2 hooks)
   └── orchestrator/ (existing)
   ```
4. Total: 15+ hooks (4 core + 4 tool + 3 context + 2 session + 3 orchestrator)
</verification>

<success_criteria>
- 10 new hooks implemented across 3 categories
- All hooks follow factory pattern (createXxxHook)
- Tool hooks handle tool.execute.after events
- Context hooks handle compaction and message events
- Session hooks handle lifecycle events
- All hooks registered via HookRegistry
- Main index exports all hooks
</success_criteria>

<output>
After completion, create `.planning/phases/18-hook-system/18-05-SUMMARY.md`
</output>

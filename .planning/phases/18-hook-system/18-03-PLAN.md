---
phase: 18-hook-system
plan: 03
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - src/hooks/core/context-window-monitor-hook.ts
  - src/hooks/core/index.ts
autonomous: true

must_haves:
  truths:
    - "Hook tracks token usage per session"
    - "Warning emitted at 70% threshold"
    - "Critical warning at 85% threshold"
    - "Integrates with existing ContextMonitor"
    - "Session cleanup on session.deleted"
  artifacts:
    - path: "src/hooks/core/context-window-monitor-hook.ts"
      provides: "Context window monitoring hook"
      exports: ["createContextWindowMonitorHook", "ContextWindowMonitorOptions"]
  key_links:
    - from: "src/hooks/core/context-window-monitor-hook.ts"
      to: "src/context/monitor.ts"
      via: "Uses ContextMonitor for tracking"
      pattern: "ContextMonitor"
    - from: "src/hooks/core/context-window-monitor-hook.ts"
      to: "src/state/event-system.ts"
      via: "Emits threshold events"
      pattern: "emitEvent"
---

<objective>
Implement the context-window-monitor hook that tracks token usage and emits warnings at configurable thresholds.

Purpose: Prevent context exhaustion by warning agents when approaching limits, enabling graceful handoff.
Output: Production-ready hook that monitors context usage and emits threshold events.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/18-hook-system/18-RESEARCH.md
@.planning/phases/18-hook-system/18-01-SUMMARY.md

# Reference implementation
@references/oh-my-opencode/src/hooks/context-window-monitor.ts

# Existing context infrastructure to integrate with
@src/context/monitor.ts
@src/context/thresholds.ts
@src/context/estimator.ts

# Hook types from 18-01
@src/hooks/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Context window monitor hook implementation</name>
  <files>src/hooks/core/context-window-monitor-hook.ts</files>
  <action>
Create the context-window-monitor hook following oh-my-opencode patterns:

1. **Configuration**:
   ```typescript
   export interface ContextWindowMonitorOptions {
     contextLimit?: number;           // Default: 200_000
     warningThreshold?: number;       // Default: 0.70 (70%)
     criticalThreshold?: number;      // Default: 0.85 (85%)
     autoCompactionThreshold?: number; // Default: 0.80 (80%)
   }

   const DEFAULT_CONTEXT_LIMIT = 200_000;
   const WARNING_THRESHOLD = 0.70;
   const CRITICAL_THRESHOLD = 0.85;
   ```

2. **Session tracking**:
   ```typescript
   interface SessionMonitorState {
     warned: boolean;           // Has warning been shown?
     critical: boolean;         // Has critical been shown?
     lastTokenCount: number;    // Last known token count
   }

   const sessionStates = new Map<string, SessionMonitorState>();
   ```

3. **Context reminder message** (use SystemDirectiveTypes.CONTEXT_WINDOW_MONITOR):
   ```typescript
   const CONTEXT_WARNING = `${createSystemDirective(SystemDirectiveTypes.CONTEXT_WINDOW_MONITOR)}

   Context window usage is high. Consider:
   - Completing current task before starting new ones
   - Preparing checkpoint for handoff if needed
   - Avoiding large file reads unless necessary

   [Context Status: {usedPct}% used ({usedTokens}/{limitTokens} tokens)]`;

   const CONTEXT_CRITICAL = `${createSystemDirective(SystemDirectiveTypes.CONTEXT_WINDOW_MONITOR)}

   CRITICAL: Context window nearly full. You should:
   - Complete current task immediately
   - Create checkpoint return for next agent
   - Do NOT start new tasks

   [Context Status: {usedPct}% used - HANDOFF RECOMMENDED]`;
   ```

4. **Integration with existing ContextMonitor**:
   - Use ContextMonitor from src/context/monitor.ts for actual tracking
   - Hook wraps ContextMonitor to add event-driven behavior
   - Leverage detectThreshold() and getThresholdAction() from thresholds.ts

5. **Event handlers**:
   ```typescript
   // tool.execute.after - Check context after each tool execution
   const toolExecuteAfter = async (
     input: { tool: string; sessionID: string; callID: string },
     output: { title: string; output: string; metadata: unknown }
   ) => {
     const state = getState(input.sessionID);

     // Get current usage from ContextMonitor or estimate
     const usage = estimateCurrentUsage(input.sessionID);

     // Check thresholds
     if (usage.ratio >= criticalThreshold && !state.critical) {
       state.critical = true;
       output.output += `\n\n${formatCriticalMessage(usage)}`;
       emitThresholdEvent('critical', input.sessionID, usage);
     } else if (usage.ratio >= warningThreshold && !state.warned) {
       state.warned = true;
       output.output += `\n\n${formatWarningMessage(usage)}`;
       emitThresholdEvent('warning', input.sessionID, usage);
     }
   };

   // event - Handle session cleanup
   const eventHandler = async ({ event }) => {
     if (event.type === 'session.deleted') {
       const sessionId = event.properties?.info?.id;
       if (sessionId) sessionStates.delete(sessionId);
     }
   };
   ```

6. **Event emission**:
   ```typescript
   function emitThresholdEvent(
     level: 'warning' | 'critical',
     sessionId: string,
     usage: { ratio: number; tokens: number }
   ): void {
     emitEvent({
       type: 'context_threshold_hook',
       payload: {
         level,
         sessionId,
         usageRatio: usage.ratio,
         tokens: usage.tokens,
       },
       source: 'hook:context-window-monitor',
     });
   }
   ```

7. **Factory function**:
   ```typescript
   export function createContextWindowMonitorHook(
     ctx: HookContext,
     options: ContextWindowMonitorOptions = {}
   ): HookHandlers {
     // Implementation
     return {
       'tool.execute.after': toolExecuteAfter,
       event: eventHandler,
     };
   }
   ```

Note: For token estimation without actual Claude API:
- Use estimateTokens() from context/estimator.ts
- Track cumulative content length per session
- This provides approximate monitoring until integrated with actual API
  </action>
  <verify>npm run build passes; hook exports HookHandlers with tool.execute.after</verify>
  <done>Context window monitor hook implemented with threshold detection and events</done>
</task>

<task type="auto">
  <name>Task 2: Update core hooks index</name>
  <files>src/hooks/core/index.ts</files>
  <action>
Update the core hooks barrel export to include context-window-monitor:

```typescript
/**
 * Core Hooks
 *
 * Essential hooks for agent orchestration:
 * - todo-continuation-enforcer: Auto-continue on incomplete tasks
 * - context-window-monitor: Token usage tracking and warnings
 */
export * from './todo-continuation-enforcer.js';
export * from './context-window-monitor-hook.js';
```

Verify both hooks can be imported:
```typescript
import {
  createTodoContinuationEnforcerHook,
  createContextWindowMonitorHook,
} from './hooks';
```
  </action>
  <verify>npm run build passes; both hooks importable from src/hooks</verify>
  <done>Core hooks index updated with context-window-monitor export</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` passes with no errors
2. Hook can be created: `const hook = createContextWindowMonitorHook(ctx)`
3. Hook returns HookHandlers with `tool.execute.after` and `event`
4. Threshold events emitted to EventSystem
</verification>

<success_criteria>
- Token usage tracked per session
- Warning at 70% threshold (configurable)
- Critical warning at 85% threshold (configurable)
- System directive format for messages
- Integration with existing ContextMonitor/estimator
- Session cleanup on session.deleted
</success_criteria>

<output>
After completion, create `.planning/phases/18-hook-system/18-03-SUMMARY.md`
</output>

---
phase: 18-hook-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/types.ts
  - src/hooks/registry.ts
  - src/hooks/event-bus.ts
  - src/hooks/index.ts
autonomous: true

must_haves:
  truths:
    - "HookRegistry registers hooks with priority ordering"
    - "HookRegistry dispatches events to all registered handlers"
    - "Hooks follow factory pattern (createXxxHook)"
    - "Event bus integrates with existing EventSystem"
  artifacts:
    - path: "src/hooks/types.ts"
      provides: "Hook interface definitions"
      exports: ["HookDefinition", "HookHandlers", "HookContext", "HookEvent", "HookConfig"]
    - path: "src/hooks/registry.ts"
      provides: "HookRegistry class"
      exports: ["HookRegistry", "createHookRegistry"]
    - path: "src/hooks/event-bus.ts"
      provides: "Event bus for hook event propagation"
      exports: ["HookEventBus", "createHookEventBus"]
  key_links:
    - from: "src/hooks/registry.ts"
      to: "src/hooks/event-bus.ts"
      via: "HookRegistry uses HookEventBus for dispatch"
      pattern: "eventBus\\.dispatch"
    - from: "src/hooks/event-bus.ts"
      to: "src/state/event-system.ts"
      via: "HookEventBus emits to EventSystem"
      pattern: "emitEvent"
---

<objective>
Create the foundational hook system infrastructure including type definitions, HookRegistry, and event bus integration.

Purpose: Establish the extensibility foundation that all 35+ hooks will build upon, following oh-my-opencode patterns.
Output: Core hook infrastructure files that enable registering, managing, and dispatching hooks.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/18-hook-system/18-RESEARCH.md

# Existing infrastructure to integrate with
@src/state/event-system.ts
@src/state/state-manager.ts
@src/hooks/orchestrator/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Hook type definitions</name>
  <files>src/hooks/types.ts</files>
  <action>
Create comprehensive hook type definitions following oh-my-opencode patterns:

1. **HookEvent types** - Define all hook event types:
   - `chat.message` - Message lifecycle
   - `tool.execute.before` - Pre-tool execution
   - `tool.execute.after` - Post-tool execution
   - `event` - Generic event handler
   - `session.idle` - Session becomes idle
   - `session.error` - Session error occurred
   - `session.deleted` - Session cleanup

2. **HookHandlers interface** - Map event types to handler functions:
   ```typescript
   export interface HookHandlers {
     'chat.message'?: ChatMessageHandler;
     'tool.execute.before'?: ToolExecuteBeforeHandler;
     'tool.execute.after'?: ToolExecuteAfterHandler;
     event?: EventHandler;
   }
   ```

3. **HookDefinition** - Hook registration metadata:
   - name: string (unique identifier)
   - enabled: boolean (can be disabled)
   - priority: number (execution order, lower = first)
   - factory: (ctx: HookContext) => HookHandlers

4. **HookContext** - Context passed to hook factories:
   - sessionId: string
   - stateManager: StateManager reference
   - emitEvent: function to emit events
   - config: HookConfig

5. **HookConfig** - Global hook configuration:
   - enabledHooks: string[] (whitelist)
   - disabledHooks: string[] (blacklist)
   - hookOptions: Record<string, unknown>

Reuse existing SystemDirectiveTypes from orchestrator/types.ts. Add new directive types:
- TODO_CONTINUATION
- CONTEXT_WINDOW_MONITOR
- BACKGROUND_NOTIFICATION
- SESSION_RECOVERY

Keep existing types from orchestrator/types.ts - this file extends them for the broader hook system.
  </action>
  <verify>npm run build -- --filter="**/hooks/types.ts" passes with no type errors</verify>
  <done>All hook type definitions exported and type-safe</done>
</task>

<task type="auto">
  <name>Task 2: HookRegistry implementation</name>
  <files>src/hooks/registry.ts</files>
  <action>
Implement the HookRegistry class that manages hook lifecycle:

1. **HookRegistry class**:
   ```typescript
   export class HookRegistry {
     private hooks: Map<string, HookDefinition> = new Map();
     private instances: Map<string, HookHandlers> = new Map();
     private eventBus: HookEventBus;

     constructor(eventBus: HookEventBus) { ... }

     register(hook: HookDefinition): void { ... }
     unregister(name: string): void { ... }
     enable(name: string): void { ... }
     disable(name: string): void { ... }

     initialize(ctx: HookContext): void { ... }

     async dispatch(
       eventType: keyof HookHandlers,
       input: unknown,
       output: unknown
     ): Promise<void> { ... }

     getRegisteredHooks(): string[] { ... }
     isEnabled(name: string): boolean { ... }
   }
   ```

2. **register()** - Add hook definition to registry
   - Validate hook has unique name
   - Store in hooks Map

3. **initialize()** - Create hook instances from factories
   - Sort by priority (ascending)
   - Filter to enabled only
   - Call factory for each, store in instances Map

4. **dispatch()** - Propagate events to all handlers
   - Iterate instances in priority order
   - Call matching handler if exists
   - Wrap in try/catch to prevent one hook from breaking others
   - Log errors but continue

5. **Factory function**:
   ```typescript
   export function createHookRegistry(eventBus: HookEventBus): HookRegistry {
     return new HookRegistry(eventBus);
   }
   ```

Use console.error for hook errors (not logger dependency).
  </action>
  <verify>npm run build passes; registry can register, initialize, and dispatch</verify>
  <done>HookRegistry class fully implemented with priority-ordered dispatch</done>
</task>

<task type="auto">
  <name>Task 3: HookEventBus and index exports</name>
  <files>src/hooks/event-bus.ts, src/hooks/index.ts</files>
  <action>
1. **HookEventBus** (src/hooks/event-bus.ts):

   Create event bus that bridges hooks with existing EventSystem:
   ```typescript
   export class HookEventBus {
     private listeners: Map<string, Set<HookEventListener>> = new Map();

     subscribe(eventType: string, listener: HookEventListener): () => void { ... }

     dispatch(eventType: string, payload: unknown): void { ... }

     // Integration with existing EventSystem
     emitToEventSystem(event: Omit<StateEvent, 'id' | 'timestamp'>): void {
       emitEvent(event);
     }
   }
   ```

   - subscribe() returns unsubscribe function
   - dispatch() calls all listeners for eventType
   - Integrates with emitEvent from state/event-system.ts

2. **Factory function**:
   ```typescript
   export function createHookEventBus(): HookEventBus {
     return new HookEventBus();
   }
   ```

3. **Update src/hooks/index.ts**:

   Export all new hook infrastructure:
   ```typescript
   // Core hook system
   export * from './types.js';
   export * from './registry.js';
   export * from './event-bus.js';

   // Existing orchestrator hooks
   export * from './orchestrator/index.js';
   ```

Ensure backward compatibility - existing orchestrator exports still work.
  </action>
  <verify>npm run build passes; imports work from src/hooks</verify>
  <done>HookEventBus implemented and all exports consolidated in index.ts</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` passes with no errors
2. `npm run test` passes (existing tests)
3. Types can be imported: `import { HookRegistry, HookDefinition, createHookEventBus } from './hooks'`
4. HookRegistry can be instantiated and hooks registered
</verification>

<success_criteria>
- HookRegistry manages hook lifecycle (register/unregister/enable/disable)
- Priority-ordered dispatch works (lower priority = runs first)
- HookEventBus integrates with existing EventSystem
- All types properly exported from src/hooks/index.ts
- Factory pattern established (createXxxHook convention)
</success_criteria>

<output>
After completion, create `.planning/phases/18-hook-system/18-01-SUMMARY.md`
</output>

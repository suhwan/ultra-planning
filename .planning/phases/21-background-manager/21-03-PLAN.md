---
phase: 21-background-manager
plan: 03
type: execute
wave: 3
depends_on: ["21-02"]
files_modified:
  - src/orchestration/background/notifications.ts
  - src/orchestration/background/manager.ts
  - src/orchestration/background/index.ts
autonomous: true

must_haves:
  truths:
    - "Task completion triggers notification to parent session"
    - "Notifications batch within configurable window (default 1000ms)"
    - "Batch flushes immediately when max size reached (default 5)"
    - "Event bus integration emits background_task_completed events"
  artifacts:
    - path: "src/orchestration/background/notifications.ts"
      provides: "NotificationManager for batched parent notifications"
      exports: ["NotificationManager", "createNotificationManager"]
  key_links:
    - from: "src/orchestration/background/manager.ts"
      to: "src/orchestration/background/notifications.ts"
      via: "uses NotificationManager on task complete"
      pattern: "notificationManager\\.notify"
    - from: "src/orchestration/background/notifications.ts"
      to: "src/hooks/event-bus.ts"
      via: "emits events via HookEventBus"
      pattern: "eventBus\\.dispatch"
---

<objective>
Implement notification system for batched parent session notifications on task completion.

Purpose: When background tasks complete, the parent session needs to be notified. This plan implements batched notifications to avoid spamming the parent with individual completions. It integrates with the existing hook event bus for decoupled notification delivery.

Output:
- `src/orchestration/background/notifications.ts` - NotificationManager class
- Updated `src/orchestration/background/manager.ts` - Integration with notifications
- Updated `src/orchestration/background/index.ts` - Add notification exports
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/21-background-manager/21-RESEARCH.md

# From previous plans
@src/orchestration/background/types.ts
@src/orchestration/background/manager.ts

# Existing notification hook (for integration pattern)
@src/hooks/core/background-notification.ts
@src/hooks/event-bus.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement NotificationManager</name>
  <files>src/orchestration/background/notifications.ts</files>
  <action>
Create NotificationManager that batches task completion notifications:

```typescript
import { HookEventBus, createHookEventBus } from '../../hooks/event-bus.js';
import type { BackgroundTask } from './types.js';

export interface NotificationConfig {
  /** Milliseconds to batch notifications (default: 1000) */
  batchWindow?: number;
  /** Maximum notifications per batch before immediate flush (default: 5) */
  maxBatchSize?: number;
}

interface PendingNotification {
  task: BackgroundTask;
  queuedAt: number;
}

const DEFAULT_BATCH_WINDOW = 1000;
const DEFAULT_MAX_BATCH_SIZE = 5;

export class NotificationManager {
  private config: Required<NotificationConfig>;
  private eventBus: HookEventBus;
  private pendingByParent: Map<string, PendingNotification[]> = new Map();
  private timers: Map<string, ReturnType<typeof setTimeout>> = new Map();

  constructor(config?: NotificationConfig, eventBus?: HookEventBus) {
    this.config = {
      batchWindow: config?.batchWindow ?? DEFAULT_BATCH_WINDOW,
      maxBatchSize: config?.maxBatchSize ?? DEFAULT_MAX_BATCH_SIZE,
    };
    this.eventBus = eventBus ?? createHookEventBus();
  }

  /**
   * Queue a task completion notification.
   * Batches notifications per parent session.
   */
  notify(task: BackgroundTask): void {
    const parentId = task.parentSessionId;
    if (!parentId) return;

    const pending = this.pendingByParent.get(parentId) || [];
    pending.push({ task, queuedAt: Date.now() });
    this.pendingByParent.set(parentId, pending);

    // Emit individual event for hook consumption
    this.eventBus.dispatch('background_task_completed', {
      taskId: task.id,
      sessionId: task.sessionId,
      parentSessionId: task.parentSessionId,
      status: task.status,
      result: task.result,
      error: task.error,
    });

    // Check if batch is full
    if (pending.length >= this.config.maxBatchSize) {
      this.flushParent(parentId);
      return;
    }

    // Start batch timer if not already running
    if (!this.timers.has(parentId)) {
      const timer = setTimeout(() => {
        this.flushParent(parentId);
      }, this.config.batchWindow);
      this.timers.set(parentId, timer);
    }
  }

  /**
   * Flush all pending notifications for a parent session.
   */
  flushParent(parentSessionId: string): void {
    // Clear timer
    const timer = this.timers.get(parentSessionId);
    if (timer) {
      clearTimeout(timer);
      this.timers.delete(parentSessionId);
    }

    // Get and clear pending
    const pending = this.pendingByParent.get(parentSessionId);
    if (!pending || pending.length === 0) return;
    this.pendingByParent.delete(parentSessionId);

    // Build batch payload
    const tasks = pending.map(p => p.task);
    const completedCount = tasks.filter(t => t.status === 'completed').length;
    const failedCount = tasks.filter(t => t.status === 'error').length;
    const cancelledCount = tasks.filter(t => t.status === 'cancelled').length;

    // Emit batch notification event
    this.eventBus.dispatch('background_tasks_batch', {
      parentSessionId,
      tasks,
      count: tasks.length,
      completedCount,
      failedCount,
      cancelledCount,
      allComplete: this.getAllPendingForParent(parentSessionId).length === 0,
    });

    // Also emit to state event system for persistence
    this.eventBus.emitToEventSystem({
      type: 'background_tasks_notification',
      payload: {
        parentSessionId,
        taskIds: tasks.map(t => t.id),
        count: tasks.length,
        completedCount,
        failedCount,
      },
      source: 'background-manager',
    });
  }

  /**
   * Get all pending notifications for a parent (across all batches).
   */
  private getAllPendingForParent(parentSessionId: string): PendingNotification[] {
    return this.pendingByParent.get(parentSessionId) || [];
  }

  /**
   * Flush all pending notifications for all parents.
   */
  flushAll(): void {
    for (const parentId of this.pendingByParent.keys()) {
      this.flushParent(parentId);
    }
  }

  /**
   * Clear all pending notifications without flushing.
   */
  clear(): void {
    for (const timer of this.timers.values()) {
      clearTimeout(timer);
    }
    this.timers.clear();
    this.pendingByParent.clear();
  }

  /**
   * Get the event bus for external subscription.
   */
  getEventBus(): HookEventBus {
    return this.eventBus;
  }
}

/**
 * Factory function for creating NotificationManager.
 */
export function createNotificationManager(
  config?: NotificationConfig,
  eventBus?: HookEventBus
): NotificationManager {
  return new NotificationManager(config, eventBus);
}

/**
 * Format a human-readable notification message.
 */
export function formatBatchNotification(
  count: number,
  completedCount: number,
  failedCount: number
): string {
  if (failedCount === 0) {
    return `${count} background task${count > 1 ? 's' : ''} completed successfully.`;
  }
  if (completedCount === 0) {
    return `${count} background task${count > 1 ? 's' : ''} failed.`;
  }
  return `${count} background task${count > 1 ? 's' : ''} finished: ${completedCount} completed, ${failedCount} failed.`;
}
```

Key features:
1. **Per-parent batching**: Each parent session has its own batch
2. **Dual emission**: Individual events + batch events for flexibility
3. **Configurable timing**: batchWindow and maxBatchSize
4. **State event integration**: Persists to state event system
5. **Human-readable formatting**: formatBatchNotification helper
  </action>
  <verify>
1. notify() queues task for batch
2. Batch flushes after batchWindow ms
3. Batch flushes immediately at maxBatchSize
4. Events dispatched via HookEventBus
  </verify>
  <done>NotificationManager batches and emits completion events</done>
</task>

<task type="auto">
  <name>Task 2: Integrate with BackgroundManager</name>
  <files>src/orchestration/background/manager.ts</files>
  <action>
Update BackgroundManager to use NotificationManager:

1. Add NotificationManager import:
```typescript
import { NotificationManager, createNotificationManager } from './notifications.js';
```

2. Add to constructor:
```typescript
private notificationManager: NotificationManager;

constructor(config?: Partial<BackgroundConfig>) {
  this.config = { ...DEFAULT_BACKGROUND_CONFIG, ...config };
  this.concurrencyManager = new ConcurrencyManager(this.config);
  this.notificationManager = createNotificationManager({
    batchWindow: config?.notificationBatchWindow ?? 1000,
    maxBatchSize: config?.notificationMaxBatch ?? 5,
  });
  this.loadState();
}
```

3. Update completeTask to notify:
```typescript
completeTask(taskId: string, result?: string): boolean {
  const task = this.tasks.get(taskId);
  if (!task || task.status !== 'running') return false;

  task.status = 'completed';
  task.completedAt = new Date();
  task.result = result;

  // Release concurrency slot BEFORE notification
  if (task.concurrencyKey) {
    this.concurrencyManager.release(task.concurrencyKey);
  }

  this.persistState();

  // Notify parent session
  this.notificationManager.notify(task);

  if (this.onTaskComplete) {
    this.onTaskComplete(task);
  }

  return true;
}
```

4. Update failTask similarly:
```typescript
failTask(taskId: string, error: string): boolean {
  // ... existing code ...

  // Notify parent session
  this.notificationManager.notify(task);

  // ... callback ...
}
```

5. Update cancelTask similarly

6. Add to clear():
```typescript
clear(): void {
  this.notificationManager.flushAll();
  this.notificationManager.clear();
  this.concurrencyManager.clear();
  // ... rest ...
}
```

7. Add getter for event bus:
```typescript
getEventBus(): HookEventBus {
  return this.notificationManager.getEventBus();
}
```

8. Update BackgroundConfig type in types.ts:
```typescript
export interface BackgroundConfig {
  modelConcurrency?: Record<string, number>;
  defaultConcurrency?: number;
  pollingIntervalMs?: number;
  stabilityThreshold?: number;
  // Add notification config
  notificationBatchWindow?: number;
  notificationMaxBatch?: number;
}
```
  </action>
  <verify>
1. completeTask triggers notification
2. failTask triggers notification
3. cancelTask triggers notification
4. clear() flushes all pending notifications
5. Event bus accessible via getEventBus()
  </verify>
  <done>BackgroundManager integrates with NotificationManager</done>
</task>

<task type="auto">
  <name>Task 3: Update Module Exports</name>
  <files>src/orchestration/background/index.ts</files>
  <action>
Add notification exports to index:

```typescript
/**
 * Background Manager Module
 *
 * Provides background task management with model-based concurrency control,
 * task queuing, stability detection, and parent session notifications.
 *
 * Key components:
 * - ConcurrencyManager: Model-tiered concurrent limits
 * - BackgroundManager: Task lifecycle management
 * - NotificationManager: Batched parent session notifications
 * - State persistence: Survives process restarts
 *
 * @module orchestration/background
 */

// Types
export * from './types.js';

// Concurrency management
export { ConcurrencyManager } from './concurrency.js';

// State persistence
export {
  loadBackgroundState,
  saveBackgroundState,
  clearBackgroundState,
  createEmptyState,
} from './state.js';

// Notifications
export {
  NotificationManager,
  createNotificationManager,
  formatBatchNotification,
  type NotificationConfig,
} from './notifications.js';

// Background manager
export {
  BackgroundManager,
  getBackgroundManager,
  resetBackgroundManager,
} from './manager.js';

// Stability detection will be added in Plan 21-04:
// export { StabilityDetector } from './stability.js';
```
  </action>
  <verify>
1. NotificationManager exported
2. formatBatchNotification exported
3. npm run build succeeds
  </verify>
  <done>All notification components exported</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. `npm run lint` passes for modified files
3. Task completion triggers notification to parent
4. Notifications batch within 1000ms window
5. Batch flushes at 5 tasks
6. Events dispatched via HookEventBus
7. Events persisted to state event system
</verification>

<success_criteria>
1. NotificationManager implements configurable batching
2. Per-parent batch management prevents cross-contamination
3. Dual event emission (individual + batch) for flexibility
4. BackgroundManager automatically notifies on completion
5. Integration with existing hook system complete
</success_criteria>

<output>
After completion, create `.planning/phases/21-background-manager/21-03-SUMMARY.md`
</output>

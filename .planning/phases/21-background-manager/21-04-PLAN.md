---
phase: 21-background-manager
plan: 04
type: execute
wave: 3
depends_on: ["21-02"]
files_modified:
  - src/orchestration/background/stability.ts
  - src/orchestration/background/manager.ts
  - src/orchestration/background/index.ts
  - src/orchestration/background/manager.test.ts
autonomous: true

must_haves:
  truths:
    - "Stability detection triggers completion after 3 consecutive stable polls"
    - "Tasks must run for minimum 10 seconds before stability detection activates"
    - "Stale timeout marks tasks as error after 3 minutes of no progress"
    - "TTL enforcement removes tasks after 30 minutes"
  artifacts:
    - path: "src/orchestration/background/stability.ts"
      provides: "StabilityDetector class for idle detection and stale handling"
      exports: ["StabilityDetector", "createStabilityDetector", "StabilityConfig"]
    - path: "src/orchestration/background/manager.test.ts"
      provides: "Unit tests for BackgroundManager"
      min_lines: 100
  key_links:
    - from: "src/orchestration/background/manager.ts"
      to: "src/orchestration/background/stability.ts"
      via: "uses StabilityDetector for auto-completion"
      pattern: "stabilityDetector\\.poll"
---

<objective>
Implement stability detection for automatic task completion and stale timeout handling.

Purpose: Background tasks need automatic completion detection when they become idle. This plan implements a polling-based stability detector that monitors message counts and triggers completion after consecutive stable polls. It also handles stale task timeouts and TTL enforcement.

Output:
- `src/orchestration/background/stability.ts` - StabilityDetector class
- Updated `src/orchestration/background/manager.ts` - Integration with stability detection
- Updated `src/orchestration/background/index.ts` - Add stability exports
- `src/orchestration/background/manager.test.ts` - Unit tests
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/21-background-manager/21-RESEARCH.md

# From previous plans
@src/orchestration/background/types.ts
@src/orchestration/background/manager.ts
@src/orchestration/background/concurrency.ts

# Reference implementation
@references/oh-my-opencode/src/features/background-agent/manager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement StabilityDetector</name>
  <files>src/orchestration/background/stability.ts</files>
  <action>
Create StabilityDetector class for monitoring task completion:

```typescript
import type { BackgroundTask } from './types.js';

export interface StabilityConfig {
  /** Minimum milliseconds before stability detection activates (default: 10000) */
  minStabilityTimeMs?: number;
  /** Consecutive stable polls needed to trigger completion (default: 3) */
  stabilityThreshold?: number;
  /** Milliseconds before task is considered stale (default: 180000 = 3 min) */
  staleTimeoutMs?: number;
  /** Minimum runtime before stale check (default: 30000 = 30 sec) */
  minRuntimeBeforeStaleMs?: number;
  /** Task TTL in milliseconds (default: 1800000 = 30 min) */
  taskTtlMs?: number;
}

export interface PollResult {
  taskId: string;
  action: 'complete' | 'stale' | 'expired' | 'continue';
  reason?: string;
}

// Default configuration matching oh-my-opencode
const DEFAULT_STABILITY_CONFIG: Required<StabilityConfig> = {
  minStabilityTimeMs: 10_000,       // 10 seconds
  stabilityThreshold: 3,            // 3 stable polls
  staleTimeoutMs: 180_000,          // 3 minutes
  minRuntimeBeforeStaleMs: 30_000,  // 30 seconds
  taskTtlMs: 30 * 60 * 1000,        // 30 minutes
};

export class StabilityDetector {
  private config: Required<StabilityConfig>;
  private msgCountProvider?: (taskId: string) => Promise<number | null>;

  constructor(config?: StabilityConfig) {
    this.config = { ...DEFAULT_STABILITY_CONFIG, ...config };
  }

  /**
   * Set provider for getting current message count for a task.
   * Returns null if session not found.
   */
  setMessageCountProvider(provider: (taskId: string) => Promise<number | null>): void {
    this.msgCountProvider = provider;
  }

  /**
   * Poll a task and determine if it should be completed, marked stale, or continue.
   */
  async poll(task: BackgroundTask): Promise<PollResult> {
    const now = Date.now();

    // Skip non-running tasks
    if (task.status !== 'running') {
      return { taskId: task.id, action: 'continue' };
    }

    const startedAt = task.startedAt?.getTime() ?? now;
    const elapsed = now - startedAt;

    // Check TTL expiration
    if (elapsed > this.config.taskTtlMs) {
      return {
        taskId: task.id,
        action: 'expired',
        reason: `Task exceeded TTL of ${this.config.taskTtlMs / 1000}s`,
      };
    }

    // Check stale timeout (only after minimum runtime)
    if (elapsed > this.config.minRuntimeBeforeStaleMs) {
      const lastUpdate = task.progress?.lastUpdate?.getTime() ?? startedAt;
      const timeSinceUpdate = now - lastUpdate;

      if (timeSinceUpdate > this.config.staleTimeoutMs) {
        return {
          taskId: task.id,
          action: 'stale',
          reason: `No progress for ${this.config.staleTimeoutMs / 1000}s`,
        };
      }
    }

    // Check stability (only after minimum stability time)
    if (elapsed > this.config.minStabilityTimeMs) {
      const stabilityResult = await this.checkStability(task);
      if (stabilityResult) {
        return stabilityResult;
      }
    }

    return { taskId: task.id, action: 'continue' };
  }

  /**
   * Check message count stability for a task.
   */
  private async checkStability(task: BackgroundTask): Promise<PollResult | null> {
    if (!this.msgCountProvider) {
      // No provider - use simple time-based completion check
      // If task has been idle for stabilityThreshold * pollingInterval, consider complete
      return null;
    }

    const currentMsgCount = await this.msgCountProvider(task.id);
    if (currentMsgCount === null) {
      // Session not found - may have terminated
      return {
        taskId: task.id,
        action: 'complete',
        reason: 'Session terminated',
      };
    }

    // Compare with last known count
    if (task.lastMsgCount === currentMsgCount) {
      // Count is stable - increment stable polls
      const stablePolls = (task.stablePolls ?? 0) + 1;

      if (stablePolls >= this.config.stabilityThreshold) {
        return {
          taskId: task.id,
          action: 'complete',
          reason: `Message count stable for ${stablePolls} polls`,
        };
      }

      // Update task state (caller must persist)
      task.stablePolls = stablePolls;
    } else {
      // Count changed - reset stability counter
      task.lastMsgCount = currentMsgCount;
      task.stablePolls = 0;
    }

    return null;
  }

  /**
   * Reset stability tracking for a task.
   */
  resetStability(task: BackgroundTask): void {
    task.stablePolls = 0;
    task.lastMsgCount = undefined;
  }

  /**
   * Get current configuration.
   */
  getConfig(): Required<StabilityConfig> {
    return { ...this.config };
  }
}

/**
 * Factory function for creating StabilityDetector.
 */
export function createStabilityDetector(config?: StabilityConfig): StabilityDetector {
  return new StabilityDetector(config);
}
```

Key implementation details:
1. **Minimum stability time**: Don't detect completion before 10 seconds
2. **Consecutive stable polls**: Need 3 stable polls (6+ seconds at 2s interval)
3. **Stale detection**: Mark error after 3 min of no progress (after 30s minimum runtime)
4. **TTL enforcement**: Tasks expire after 30 minutes
5. **Message count provider**: Pluggable for different session backends
  </action>
  <verify>
1. poll() returns 'continue' for new tasks (< 10s)
2. poll() returns 'complete' after 3 stable polls
3. poll() returns 'stale' after 3 min no progress
4. poll() returns 'expired' after TTL
  </verify>
  <done>StabilityDetector implements idle detection and stale handling</done>
</task>

<task type="auto">
  <name>Task 2: Integrate Stability with Manager</name>
  <files>src/orchestration/background/manager.ts</files>
  <action>
Update BackgroundManager to use StabilityDetector with polling loop:

1. Add imports:
```typescript
import { StabilityDetector, createStabilityDetector, type StabilityConfig } from './stability.js';
```

2. Add to class properties:
```typescript
private stabilityDetector: StabilityDetector;
private pollInterval?: ReturnType<typeof setInterval>;
private isPolling = false;
```

3. Update constructor:
```typescript
constructor(config?: Partial<BackgroundConfig>) {
  this.config = { ...DEFAULT_BACKGROUND_CONFIG, ...config };
  this.concurrencyManager = new ConcurrencyManager(this.config);
  this.notificationManager = createNotificationManager({
    batchWindow: config?.notificationBatchWindow ?? 1000,
    maxBatchSize: config?.notificationMaxBatch ?? 5,
  });
  this.stabilityDetector = createStabilityDetector({
    minStabilityTimeMs: config?.minStabilityTimeMs ?? 10_000,
    stabilityThreshold: config?.stabilityThreshold ?? 3,
    staleTimeoutMs: config?.staleTimeoutMs ?? 180_000,
    minRuntimeBeforeStaleMs: config?.minRuntimeBeforeStaleMs ?? 30_000,
    taskTtlMs: config?.taskTtlMs ?? 30 * 60 * 1000,
  });
  this.loadState();
}
```

4. Add polling methods:
```typescript
/**
 * Start the stability polling loop.
 */
startPolling(intervalMs?: number): void {
  if (this.pollInterval) return;

  const interval = intervalMs ?? this.config.pollingIntervalMs ?? 2000;
  this.pollInterval = setInterval(() => {
    this.pollRunningTasks().catch(console.error);
  }, interval);
}

/**
 * Stop the stability polling loop.
 */
stopPolling(): void {
  if (this.pollInterval) {
    clearInterval(this.pollInterval);
    this.pollInterval = undefined;
  }
}

/**
 * Poll all running tasks for stability.
 */
private async pollRunningTasks(): Promise<void> {
  if (this.isPolling) return;
  this.isPolling = true;

  try {
    const runningTasks = this.getTasksByStatus('running');

    for (const task of runningTasks) {
      const result = await this.stabilityDetector.poll(task);

      switch (result.action) {
        case 'complete':
          this.completeTask(task.id, `Auto-completed: ${result.reason}`);
          break;

        case 'stale':
          this.failTask(task.id, `Task stale: ${result.reason}`);
          break;

        case 'expired':
          this.failTask(task.id, `Task expired: ${result.reason}`);
          break;

        case 'continue':
          // Update task state if stability counters changed
          this.persistState();
          break;
      }
    }
  } finally {
    this.isPolling = false;
  }
}

/**
 * Set message count provider for stability detection.
 */
setMessageCountProvider(provider: (taskId: string) => Promise<number | null>): void {
  this.stabilityDetector.setMessageCountProvider(provider);
}
```

5. Update clear() to stop polling:
```typescript
clear(): void {
  this.stopPolling();
  this.notificationManager.flushAll();
  this.notificationManager.clear();
  this.concurrencyManager.clear();
  this.tasks.clear();
  this.queues.clear();
  this.processing.clear();
  clearBackgroundState();
}
```

6. Update startTask to start polling if not running:
```typescript
private async startTask(task: BackgroundTask, input: LaunchInput): Promise<void> {
  task.status = 'running';
  task.startedAt = new Date();
  this.stabilityDetector.resetStability(task);
  this.persistState();

  // Start polling if not already running
  if (!this.pollInterval) {
    this.startPolling();
  }

  if (this.onTaskStart) {
    this.onTaskStart(task);
  }
}
```

7. Update BackgroundConfig in types.ts to add stability config:
```typescript
export interface BackgroundConfig {
  modelConcurrency?: Record<string, number>;
  defaultConcurrency?: number;
  pollingIntervalMs?: number;
  stabilityThreshold?: number;
  // Notification config
  notificationBatchWindow?: number;
  notificationMaxBatch?: number;
  // Stability config
  minStabilityTimeMs?: number;
  staleTimeoutMs?: number;
  minRuntimeBeforeStaleMs?: number;
  taskTtlMs?: number;
}
```
  </action>
  <verify>
1. startPolling() starts interval-based polling
2. pollRunningTasks() checks all running tasks
3. Tasks auto-complete after stability threshold
4. Tasks marked error on stale/expired
5. Polling stops on clear()
  </verify>
  <done>BackgroundManager polls for stability and handles stale tasks</done>
</task>

<task type="auto">
  <name>Task 3: Create Unit Tests</name>
  <files>src/orchestration/background/manager.test.ts</files>
  <action>
Create comprehensive unit tests for the BackgroundManager module:

```typescript
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import {
  BackgroundManager,
  getBackgroundManager,
  resetBackgroundManager,
  ConcurrencyManager,
  StabilityDetector,
  createStabilityDetector,
} from './index.js';
import type { BackgroundTask, LaunchInput } from './types.js';

describe('ConcurrencyManager', () => {
  let manager: ConcurrencyManager;

  beforeEach(() => {
    manager = new ConcurrencyManager({
      modelConcurrency: { opus: 2, sonnet: 3, haiku: 5 },
      defaultConcurrency: 3,
    });
  });

  describe('getConcurrencyLimit', () => {
    it('returns configured limit for known models', () => {
      expect(manager.getConcurrencyLimit('opus')).toBe(2);
      expect(manager.getConcurrencyLimit('sonnet')).toBe(3);
      expect(manager.getConcurrencyLimit('haiku')).toBe(5);
    });

    it('returns default for unknown models', () => {
      expect(manager.getConcurrencyLimit('unknown')).toBe(3);
    });
  });

  describe('acquire/release', () => {
    it('acquires slots up to limit', async () => {
      await manager.acquire('opus');
      await manager.acquire('opus');
      expect(manager.getCount('opus')).toBe(2);
    });

    it('blocks when at limit', async () => {
      await manager.acquire('opus');
      await manager.acquire('opus');

      let resolved = false;
      const promise = manager.acquire('opus').then(() => {
        resolved = true;
      });

      // Should not resolve immediately
      await new Promise(r => setTimeout(r, 10));
      expect(resolved).toBe(false);

      // Release one slot
      manager.release('opus');

      // Now should resolve
      await promise;
      expect(resolved).toBe(true);
    });

    it('releases slots correctly', async () => {
      await manager.acquire('opus');
      expect(manager.getCount('opus')).toBe(1);

      manager.release('opus');
      expect(manager.getCount('opus')).toBe(0);
    });
  });

  describe('cancelWaiters', () => {
    it('rejects waiting acquires', async () => {
      await manager.acquire('opus');
      await manager.acquire('opus');

      const promise = manager.acquire('opus');

      manager.cancelWaiters('opus');

      await expect(promise).rejects.toThrow('cancelled');
    });
  });
});

describe('StabilityDetector', () => {
  let detector: StabilityDetector;

  beforeEach(() => {
    detector = createStabilityDetector({
      minStabilityTimeMs: 100,    // Fast for tests
      stabilityThreshold: 3,
      staleTimeoutMs: 500,
      minRuntimeBeforeStaleMs: 50,
      taskTtlMs: 1000,
    });
  });

  const createTask = (overrides?: Partial<BackgroundTask>): BackgroundTask => ({
    id: 'test-task',
    parentSessionId: 'parent-1',
    parentMessageId: 'msg-1',
    description: 'Test task',
    prompt: 'Test prompt',
    agent: 'executor',
    status: 'running',
    startedAt: new Date(Date.now() - 200), // Started 200ms ago
    ...overrides,
  });

  describe('poll', () => {
    it('returns continue for tasks below min stability time', async () => {
      const task = createTask({ startedAt: new Date() }); // Just started
      const result = await detector.poll(task);
      expect(result.action).toBe('continue');
    });

    it('returns expired for tasks beyond TTL', async () => {
      const task = createTask({
        startedAt: new Date(Date.now() - 2000), // Started 2s ago (> 1s TTL)
      });
      const result = await detector.poll(task);
      expect(result.action).toBe('expired');
    });

    it('detects stability after threshold polls', async () => {
      const task = createTask();
      detector.setMessageCountProvider(async () => 5); // Always return 5

      // First poll - sets baseline
      await detector.poll(task);
      expect(task.stablePolls).toBe(1);

      // Second poll - still stable
      await detector.poll(task);
      expect(task.stablePolls).toBe(2);

      // Third poll - triggers completion
      const result = await detector.poll(task);
      expect(result.action).toBe('complete');
    });

    it('resets stability when count changes', async () => {
      const task = createTask();
      let count = 5;
      detector.setMessageCountProvider(async () => count);

      // First two polls - stable
      await detector.poll(task);
      await detector.poll(task);
      expect(task.stablePolls).toBe(2);

      // Count changes
      count = 6;
      await detector.poll(task);
      expect(task.stablePolls).toBe(0);
    });
  });
});

describe('BackgroundManager', () => {
  let manager: BackgroundManager;

  beforeEach(() => {
    resetBackgroundManager();
    manager = new BackgroundManager({
      modelConcurrency: { opus: 2, sonnet: 3, haiku: 5 },
      pollingIntervalMs: 100,
    });
  });

  afterEach(() => {
    manager.clear();
  });

  const createInput = (overrides?: Partial<LaunchInput>): LaunchInput => ({
    description: 'Test task',
    prompt: 'Test prompt',
    agent: 'executor',
    parentSessionId: 'parent-1',
    parentMessageId: 'msg-1',
    model: 'sonnet',
    ...overrides,
  });

  describe('launch', () => {
    it('creates task in pending state', async () => {
      const task = await manager.launch(createInput());
      expect(task.status).toBe('pending');
      expect(task.id).toMatch(/^bg-/);
    });

    it('assigns concurrency key from model', async () => {
      const task = await manager.launch(createInput({ model: 'opus' }));
      expect(task.concurrencyKey).toBe('opus');
    });
  });

  describe('completeTask', () => {
    it('marks task as completed', async () => {
      const task = await manager.launch(createInput());

      // Manually transition to running
      (task as any).status = 'running';

      const result = manager.completeTask(task.id, 'Success');
      expect(result).toBe(true);
      expect(task.status).toBe('completed');
      expect(task.result).toBe('Success');
    });

    it('rejects non-running tasks', async () => {
      const task = await manager.launch(createInput());
      const result = manager.completeTask(task.id, 'Success');
      expect(result).toBe(false); // Still pending
    });
  });

  describe('getTasksByStatus', () => {
    it('filters by status', async () => {
      await manager.launch(createInput());
      await manager.launch(createInput());

      const pending = manager.getTasksByStatus('pending');
      expect(pending.length).toBe(2);

      const running = manager.getTasksByStatus('running');
      expect(running.length).toBe(0);
    });
  });

  describe('getTasksForParent', () => {
    it('filters by parent session', async () => {
      await manager.launch(createInput({ parentSessionId: 'parent-1' }));
      await manager.launch(createInput({ parentSessionId: 'parent-2' }));

      const parent1Tasks = manager.getTasksForParent('parent-1');
      expect(parent1Tasks.length).toBe(1);
    });
  });
});
```

Run tests with: `npm test -- background`
  </action>
  <verify>npm test -- background passes all tests</verify>
  <done>Comprehensive tests cover ConcurrencyManager, StabilityDetector, and BackgroundManager</done>
</task>

<task type="auto">
  <name>Task 4: Update Module Exports</name>
  <files>src/orchestration/background/index.ts</files>
  <action>
Add stability exports to complete the module:

```typescript
/**
 * Background Manager Module
 *
 * Provides background task management with model-based concurrency control,
 * task queuing, stability detection, and parent session notifications.
 *
 * Key components:
 * - ConcurrencyManager: Model-tiered concurrent limits (haiku:5, sonnet:3, opus:2)
 * - BackgroundManager: Task lifecycle management (launch, track, complete)
 * - NotificationManager: Batched parent session notifications
 * - StabilityDetector: Auto-completion via idle detection (3 stable polls)
 * - State persistence: Survives process restarts
 *
 * Usage:
 * ```typescript
 * import { getBackgroundManager } from './orchestration/background';
 *
 * const manager = getBackgroundManager();
 *
 * // Launch a background task
 * const task = await manager.launch({
 *   description: 'Analyze code',
 *   prompt: 'Analyze the codebase...',
 *   agent: 'architect',
 *   parentSessionId: currentSession.id,
 *   parentMessageId: currentMessage.id,
 *   model: 'opus',
 * });
 *
 * // Start polling for stability detection
 * manager.startPolling();
 *
 * // Subscribe to completion events
 * manager.getEventBus().subscribe('background_task_completed', (payload) => {
 *   console.log('Task completed:', payload.taskId);
 * });
 * ```
 *
 * @module orchestration/background
 */

// Types
export * from './types.js';

// Concurrency management
export { ConcurrencyManager } from './concurrency.js';

// State persistence
export {
  loadBackgroundState,
  saveBackgroundState,
  clearBackgroundState,
  createEmptyState,
} from './state.js';

// Notifications
export {
  NotificationManager,
  createNotificationManager,
  formatBatchNotification,
  type NotificationConfig,
} from './notifications.js';

// Stability detection
export {
  StabilityDetector,
  createStabilityDetector,
  type StabilityConfig,
  type PollResult,
} from './stability.js';

// Background manager
export {
  BackgroundManager,
  getBackgroundManager,
  resetBackgroundManager,
} from './manager.js';
```
  </action>
  <verify>
1. All exports available from index
2. JSDoc usage example compiles
3. npm run build succeeds
  </verify>
  <done>Complete module with all components exported</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. `npm test -- background` passes all tests
3. `npm run lint` passes for all files
4. Stability detection triggers after 3 stable polls (6+ seconds at 2s interval)
5. Stale timeout marks error after 3 min
6. TTL enforcement removes tasks after 30 min
7. Polling loop runs at configured interval
</verification>

<success_criteria>
1. StabilityDetector implements idle detection algorithm
2. Configurable thresholds (stability, stale, TTL)
3. BackgroundManager integrates polling loop
4. Automatic completion/failure based on stability/stale detection
5. Comprehensive test coverage (>80%)
6. Full module documentation with usage examples
</success_criteria>

<output>
After completion, create `.planning/phases/21-background-manager/21-04-SUMMARY.md`
</output>

---
phase: 21-background-manager
plan: 02
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - src/orchestration/background/manager.ts
  - src/orchestration/background/state.ts
  - src/orchestration/background/index.ts
autonomous: true

must_haves:
  truths:
    - "BackgroundManager.launch() creates task in pending state and queues for execution"
    - "Tasks transition from pending to running when concurrency slot acquired"
    - "Tasks can be tracked by ID and queried by status"
    - "State persists across process restarts via StateManager"
  artifacts:
    - path: "src/orchestration/background/manager.ts"
      provides: "BackgroundManager class for task lifecycle"
      exports: ["BackgroundManager", "getBackgroundManager"]
    - path: "src/orchestration/background/state.ts"
      provides: "State persistence helpers"
      exports: ["loadBackgroundState", "saveBackgroundState", "clearBackgroundState"]
  key_links:
    - from: "src/orchestration/background/manager.ts"
      to: "src/orchestration/background/concurrency.ts"
      via: "uses ConcurrencyManager for slot control"
      pattern: "concurrencyManager\\.acquire"
    - from: "src/orchestration/background/manager.ts"
      to: "src/orchestration/background/state.ts"
      via: "persists state via state helpers"
      pattern: "saveBackgroundState"
---

<objective>
Implement BackgroundManager core with task launch, tracking, and state persistence.

Purpose: The BackgroundManager is the central coordinator for background tasks. It handles task creation, queue management, concurrency control integration, and state persistence. This plan focuses on the core launch/track/complete lifecycle.

Output:
- `src/orchestration/background/manager.ts` - BackgroundManager class
- `src/orchestration/background/state.ts` - State persistence utilities
- Updated `src/orchestration/background/index.ts` - Add new exports
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/21-background-manager/21-RESEARCH.md

# From Plan 21-01
@src/orchestration/background/types.ts
@src/orchestration/background/concurrency.ts

# State management pattern
@src/state/state-manager.ts

# Reference implementation
@references/oh-my-opencode/src/features/background-agent/manager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement State Persistence</name>
  <files>src/orchestration/background/state.ts</files>
  <action>
Create state persistence utilities using StateManager pattern:

```typescript
import { StateManager, StateLocation } from '../../state/state-manager.js';
import type { BackgroundTask, BackgroundState } from './types.js';

const STATE_NAME = 'background-manager';

// State manager instance (lazy initialized)
let stateManager: StateManager<BackgroundState> | null = null;

function getStateManager(): StateManager<BackgroundState> {
  if (!stateManager) {
    stateManager = new StateManager<BackgroundState>(STATE_NAME, StateLocation.LOCAL);
  }
  return stateManager;
}

export function loadBackgroundState(): BackgroundState | null {
  const result = getStateManager().read();
  return result.exists ? result.data : null;
}

export function saveBackgroundState(state: BackgroundState): boolean {
  return getStateManager().write(state).success;
}

export function clearBackgroundState(): boolean {
  return getStateManager().clear();
}

export function createEmptyState(): BackgroundState {
  return {
    tasks: {},
    activeCount: {},
    lastUpdated: new Date().toISOString(),
  };
}
```

Key details:
1. Use LOCAL state location (project-specific)
2. STATE_NAME = 'background-manager' creates `.ultraplan/state/background-manager.json`
3. Lazy initialization of StateManager
4. Provide createEmptyState() for initialization
  </action>
  <verify>loadBackgroundState() returns null when no state, saveBackgroundState() persists correctly</verify>
  <done>State persistence works with atomic writes</done>
</task>

<task type="auto">
  <name>Task 2: Implement BackgroundManager Core</name>
  <files>src/orchestration/background/manager.ts</files>
  <action>
Implement BackgroundManager class with task lifecycle management:

```typescript
import { v4 as uuid } from 'uuid';
import { ConcurrencyManager } from './concurrency.js';
import { loadBackgroundState, saveBackgroundState, createEmptyState } from './state.js';
import type {
  BackgroundTask,
  BackgroundTaskStatus,
  LaunchInput,
  BackgroundConfig,
  BackgroundState,
  DEFAULT_BACKGROUND_CONFIG,
} from './types.js';

interface QueueItem {
  task: BackgroundTask;
  input: LaunchInput;
}

export class BackgroundManager {
  private config: BackgroundConfig;
  private concurrencyManager: ConcurrencyManager;
  private tasks: Map<string, BackgroundTask> = new Map();
  private queues: Map<string, QueueItem[]> = new Map();
  private processing: Set<string> = new Set();
  private onTaskComplete?: (task: BackgroundTask) => void;
  private onTaskStart?: (task: BackgroundTask) => void;

  constructor(config?: Partial<BackgroundConfig>) {
    this.config = { ...DEFAULT_BACKGROUND_CONFIG, ...config };
    this.concurrencyManager = new ConcurrencyManager(this.config);
    this.loadState();
  }

  // Load persisted state on startup
  private loadState(): void {
    const state = loadBackgroundState();
    if (state) {
      for (const [id, task] of Object.entries(state.tasks)) {
        this.tasks.set(id, task);
      }
    }
  }

  // Persist current state
  private persistState(): void {
    const state: BackgroundState = {
      tasks: Object.fromEntries(this.tasks),
      activeCount: {},
      lastUpdated: new Date().toISOString(),
    };
    saveBackgroundState(state);
  }

  // Launch a new background task
  async launch(input: LaunchInput): Promise<BackgroundTask> {
    const id = `bg-${uuid()}`;
    const concurrencyKey = input.model || 'sonnet'; // default to sonnet

    const task: BackgroundTask = {
      id,
      parentSessionId: input.parentSessionId,
      parentMessageId: input.parentMessageId,
      description: input.description,
      prompt: input.prompt,
      agent: input.agent,
      status: 'pending',
      queuedAt: new Date(),
      concurrencyKey,
    };

    this.tasks.set(id, task);
    this.persistState();

    // Add to queue for this concurrency key
    const queue = this.queues.get(concurrencyKey) || [];
    queue.push({ task, input });
    this.queues.set(concurrencyKey, queue);

    // Trigger queue processing (fire-and-forget)
    this.processQueue(concurrencyKey).catch(console.error);

    return task;
  }

  // Process queue for a concurrency key
  private async processQueue(key: string): Promise<void> {
    if (this.processing.has(key)) return;
    this.processing.add(key);

    try {
      const queue = this.queues.get(key);
      while (queue && queue.length > 0) {
        // Acquire concurrency slot (blocks if at limit)
        await this.concurrencyManager.acquire(key);

        const item = queue.shift();
        if (!item) {
          this.concurrencyManager.release(key);
          continue;
        }

        // Start the task
        await this.startTask(item.task, item.input);
      }
    } finally {
      this.processing.delete(key);
    }
  }

  // Start a task (transition from pending to running)
  private async startTask(task: BackgroundTask, input: LaunchInput): Promise<void> {
    task.status = 'running';
    task.startedAt = new Date();
    this.persistState();

    if (this.onTaskStart) {
      this.onTaskStart(task);
    }

    // Note: Actual session spawning would happen here
    // For now, we just track the state transition
    // The actual execution is handled by the orchestrator
  }

  // Mark task as complete
  completeTask(taskId: string, result?: string): boolean {
    const task = this.tasks.get(taskId);
    if (!task || task.status !== 'running') return false;

    task.status = 'completed';
    task.completedAt = new Date();
    task.result = result;

    // Release concurrency slot
    if (task.concurrencyKey) {
      this.concurrencyManager.release(task.concurrencyKey);
    }

    this.persistState();

    if (this.onTaskComplete) {
      this.onTaskComplete(task);
    }

    return true;
  }

  // Mark task as failed
  failTask(taskId: string, error: string): boolean {
    const task = this.tasks.get(taskId);
    if (!task || task.status !== 'running') return false;

    task.status = 'error';
    task.completedAt = new Date();
    task.error = error;

    // Release concurrency slot
    if (task.concurrencyKey) {
      this.concurrencyManager.release(task.concurrencyKey);
    }

    this.persistState();

    if (this.onTaskComplete) {
      this.onTaskComplete(task);
    }

    return true;
  }

  // Cancel a task
  cancelTask(taskId: string): boolean {
    const task = this.tasks.get(taskId);
    if (!task) return false;

    if (task.status === 'running' && task.concurrencyKey) {
      this.concurrencyManager.release(task.concurrencyKey);
    }

    task.status = 'cancelled';
    task.completedAt = new Date();
    this.persistState();

    return true;
  }

  // Get a task by ID
  getTask(taskId: string): BackgroundTask | undefined {
    return this.tasks.get(taskId);
  }

  // Get all tasks
  getAllTasks(): BackgroundTask[] {
    return Array.from(this.tasks.values());
  }

  // Get tasks by status
  getTasksByStatus(status: BackgroundTaskStatus): BackgroundTask[] {
    return this.getAllTasks().filter(t => t.status === status);
  }

  // Get tasks for a parent session
  getTasksForParent(parentSessionId: string): BackgroundTask[] {
    return this.getAllTasks().filter(t => t.parentSessionId === parentSessionId);
  }

  // Set completion callback
  onComplete(callback: (task: BackgroundTask) => void): void {
    this.onTaskComplete = callback;
  }

  // Set start callback
  onStart(callback: (task: BackgroundTask) => void): void {
    this.onTaskStart = callback;
  }

  // Cleanup - clear all state
  clear(): void {
    this.concurrencyManager.clear();
    this.tasks.clear();
    this.queues.clear();
    this.processing.clear();
    clearBackgroundState();
  }
}

// Singleton instance
let instance: BackgroundManager | null = null;

export function getBackgroundManager(config?: Partial<BackgroundConfig>): BackgroundManager {
  if (!instance) {
    instance = new BackgroundManager(config);
  }
  return instance;
}

export function resetBackgroundManager(): void {
  if (instance) {
    instance.clear();
    instance = null;
  }
}
```

Key implementation details:
1. **Queue-based launch**: Tasks enter queue, processed when slot available
2. **State persistence**: All state changes trigger persistState()
3. **Callbacks**: onComplete/onStart for integration with notification system
4. **Singleton pattern**: getBackgroundManager() for global access
5. **Graceful cleanup**: clear() releases all slots and clears state
  </action>
  <verify>
1. launch() creates task with 'pending' status
2. Task transitions to 'running' when slot acquired
3. completeTask() releases slot and updates status
4. State persists across manager recreation
  </verify>
  <done>BackgroundManager handles full task lifecycle with concurrency control</done>
</task>

<task type="auto">
  <name>Task 3: Update Module Index</name>
  <files>src/orchestration/background/index.ts</files>
  <action>
Update the index to export new components:

```typescript
/**
 * Background Manager Module
 *
 * Provides background task management with model-based concurrency control,
 * task queuing, stability detection, and parent session notifications.
 *
 * Key components:
 * - ConcurrencyManager: Model-tiered concurrent limits
 * - BackgroundManager: Task lifecycle management
 * - State persistence: Survives process restarts
 *
 * @module orchestration/background
 */

// Types
export * from './types.js';

// Concurrency management
export { ConcurrencyManager } from './concurrency.js';

// State persistence
export {
  loadBackgroundState,
  saveBackgroundState,
  clearBackgroundState,
  createEmptyState,
} from './state.js';

// Background manager
export {
  BackgroundManager,
  getBackgroundManager,
  resetBackgroundManager,
} from './manager.js';

// Stability detection and notifications will be added in subsequent plans:
// export { StabilityDetector } from './stability.js';
// export { NotificationManager } from './notifications.js';
```

Also update src/orchestration/index.ts to export background module:

```typescript
// Add at the end of the file:

// Background module - background task management with concurrency control
export * from './background/index.js';
```
  </action>
  <verify>
1. All new exports available from index
2. src/orchestration/index.ts includes background export
3. npm run build succeeds
  </verify>
  <done>Module exports complete, integrated with orchestration module</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. `npm run lint` passes for new files
3. BackgroundManager.launch() creates pending task
4. Task transitions to running when concurrency slot available
5. completeTask() releases slot and marks complete
6. State persists to `.ultraplan/state/background-manager.json`
7. State survives manager recreation
</verification>

<success_criteria>
1. BackgroundManager manages full task lifecycle (pending -> running -> completed/error/cancelled)
2. ConcurrencyManager integration blocks launch when at limit
3. State persists across process restarts
4. Singleton pattern provides global access
5. Callbacks enable integration with notification system
</success_criteria>

<output>
After completion, create `.planning/phases/21-background-manager/21-02-SUMMARY.md`
</output>

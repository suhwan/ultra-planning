---
phase: 21-background-manager
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/orchestration/background/types.ts
  - src/orchestration/background/concurrency.ts
  - src/orchestration/background/index.ts
autonomous: true

must_haves:
  truths:
    - "ConcurrencyManager limits concurrent tasks per model tier"
    - "acquire() blocks when at limit, returns immediately when slot available"
    - "release() frees slot and unblocks waiting acquires"
    - "cancelWaiters() rejects all queued acquires for cleanup"
  artifacts:
    - path: "src/orchestration/background/types.ts"
      provides: "BackgroundTask, TaskProgress, BackgroundTaskStatus types"
      exports: ["BackgroundTaskStatus", "TaskProgress", "BackgroundTask", "LaunchInput", "BackgroundConfig"]
    - path: "src/orchestration/background/concurrency.ts"
      provides: "ConcurrencyManager class with queue-based slot management"
      exports: ["ConcurrencyManager"]
    - path: "src/orchestration/background/index.ts"
      provides: "Public exports for background module"
      exports: ["*"]
  key_links:
    - from: "src/orchestration/background/concurrency.ts"
      to: "src/orchestration/background/types.ts"
      via: "imports BackgroundConfig"
      pattern: "import.*BackgroundConfig.*from.*types"
---

<objective>
Create Background Manager types and ConcurrencyManager for model-based rate limiting.

Purpose: Establish foundation types and concurrency control for background task management. The ConcurrencyManager provides model-tiered concurrent limits (haiku:5, sonnet:3, opus:2) with queue-based blocking when limits are reached.

Output:
- `src/orchestration/background/types.ts` - All type definitions
- `src/orchestration/background/concurrency.ts` - ConcurrencyManager class
- `src/orchestration/background/index.ts` - Public exports
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-background-manager/21-RESEARCH.md

# Existing patterns to follow
@src/orchestration/ecomode/types.ts - MODEL_CONCURRENT_LIMITS reference
@src/state/state-manager.ts - State persistence pattern
@references/oh-my-opencode/src/features/background-agent/concurrency.ts - Reference implementation
@references/oh-my-opencode/src/features/background-agent/types.ts - Reference types
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Background Types</name>
  <files>src/orchestration/background/types.ts</files>
  <action>
Create comprehensive type definitions for the background task system:

1. **BackgroundTaskStatus** union type:
   - 'pending' | 'running' | 'completed' | 'error' | 'cancelled'

2. **TaskProgress** interface:
   - toolCalls: number
   - lastTool?: string
   - lastUpdate: Date
   - lastMessage?: string
   - lastMessageAt?: Date

3. **BackgroundTask** interface:
   - id: string (uuid)
   - sessionId?: string (child session)
   - parentSessionId: string
   - parentMessageId: string
   - description: string
   - prompt: string
   - agent: string
   - status: BackgroundTaskStatus
   - queuedAt?: Date
   - startedAt?: Date
   - completedAt?: Date
   - result?: string
   - error?: string
   - progress?: TaskProgress
   - concurrencyKey?: string (model tier key)
   - lastMsgCount?: number (for stability detection)
   - stablePolls?: number (consecutive stable polls)

4. **LaunchInput** interface:
   - description: string
   - prompt: string
   - agent: string
   - parentSessionId: string
   - parentMessageId: string
   - model?: ModelTier (from complexity/types)

5. **BackgroundConfig** interface:
   - modelConcurrency?: Record<string, number>
   - defaultConcurrency?: number
   - pollingIntervalMs?: number
   - stabilityThreshold?: number (default 3)

6. **DEFAULT_BACKGROUND_CONFIG** constant:
   - Use MODEL_CONCURRENT_LIMITS from ecomode
   - defaultConcurrency: 3
   - pollingIntervalMs: 2000
   - stabilityThreshold: 3

7. **BackgroundState** interface for state persistence:
   - tasks: Map serializable as Record<string, BackgroundTask>
   - activeCount: Record<string, number>
   - lastUpdated: string (ISO timestamp)

Import ModelTier from '../../complexity/types.js' for model tier typing.
  </action>
  <verify>npm run build -- --filter="**/background/types.ts" shows no errors</verify>
  <done>All background types exported, no TypeScript errors</done>
</task>

<task type="auto">
  <name>Task 2: Implement ConcurrencyManager</name>
  <files>src/orchestration/background/concurrency.ts</files>
  <action>
Implement ConcurrencyManager class adapting the oh-my-opencode pattern:

```typescript
import type { BackgroundConfig } from './types.js';

interface QueueEntry {
  resolve: () => void;
  rawReject: (error: Error) => void;
  settled: boolean;
}

export class ConcurrencyManager {
  private config: BackgroundConfig;
  private counts: Map<string, number> = new Map();
  private queues: Map<string, QueueEntry[]> = new Map();

  constructor(config?: BackgroundConfig);

  // Get limit for a model tier (haiku=5, sonnet=3, opus=2, default=3)
  getConcurrencyLimit(model: string): number;

  // Acquire a slot - blocks if at limit, returns immediately if available
  async acquire(model: string): Promise<void>;

  // Release a slot - hands off to waiting acquire or decrements count
  release(model: string): void;

  // Cancel all waiting acquires for a model (for cleanup)
  cancelWaiters(model: string): void;

  // Clear all state (for shutdown)
  clear(): void;

  // Debug helpers
  getCount(model: string): number;
  getQueueLength(model: string): number;
}
```

Key implementation details:
1. **acquire()**: Check if current < limit, increment and return. Otherwise create Promise that pushes QueueEntry to queue.
2. **release()**: Try to hand off slot to waiting entry (skip settled ones). If no handoff, decrement count.
3. **settled flag pattern**: Prevents double-resolution when cancelWaiters() races with release().
4. **0 means Infinity**: If modelConcurrency[model] === 0, treat as unlimited.
5. Use DEFAULT_BACKGROUND_CONFIG.modelConcurrency which uses MODEL_CONCURRENT_LIMITS from ecomode.
  </action>
  <verify>Create a simple test: acquire 2 opus slots (limit), 3rd acquire should block until release()</verify>
  <done>ConcurrencyManager limits concurrent tasks, acquire/release work correctly</done>
</task>

<task type="auto">
  <name>Task 3: Create Module Index</name>
  <files>src/orchestration/background/index.ts</files>
  <action>
Create the public module index with all exports:

```typescript
/**
 * Background Manager Module
 *
 * Provides background task management with model-based concurrency control,
 * task queuing, stability detection, and parent session notifications.
 *
 * Key components:
 * - ConcurrencyManager: Model-tiered concurrent limits
 * - BackgroundManager: Task lifecycle management (Plan 21-02)
 * - Stability detection: Auto-completion via idle detection (Plan 21-04)
 * - Notifications: Batch notifications to parent session (Plan 21-03)
 *
 * @module orchestration/background
 */

// Types
export * from './types.js';

// Concurrency management
export { ConcurrencyManager } from './concurrency.js';

// Manager and state will be added in subsequent plans:
// export { BackgroundManager } from './manager.js';
// export { loadBackgroundState, saveBackgroundState } from './state.js';
```

Note: Manager and state exports are commented placeholders for Plans 21-02 and later.
  </action>
  <verify>npm run build -- --filter="**/background/**" shows no errors</verify>
  <done>Index exports types and ConcurrencyManager cleanly</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. `npm run lint` passes for new files
3. ConcurrencyManager limits:
   - haiku: 5 concurrent
   - sonnet: 3 concurrent
   - opus: 2 concurrent
4. acquire() blocks when at limit
5. release() unblocks waiting acquires
</verification>

<success_criteria>
1. All types defined with proper JSDoc comments
2. ConcurrencyManager implements queue-based slot management
3. Settled-flag pattern prevents double-resolution bugs
4. Module exports cleanly from index.ts
5. No TypeScript errors on build
</success_criteria>

<output>
After completion, create `.planning/phases/21-background-manager/21-01-SUMMARY.md`
</output>

---
phase: 10-context-monitor
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/context/types.ts
  - src/context/estimator.ts
  - src/context/index.ts
autonomous: true

must_haves:
  truths:
    - "Token count can be estimated from text length"
    - "Cumulative context tracking accumulates across tool calls"
    - "Usage ratio is calculated against configurable context limit"
  artifacts:
    - path: "src/context/types.ts"
      provides: "ContextState, Thresholds, config interfaces"
      exports: ["ContextState", "ContextConfig", "ContextUsageResult"]
    - path: "src/context/estimator.ts"
      provides: "Token estimation and cumulative tracking"
      exports: ["estimateTokens", "createContextTracker", "analyzeContextUsage"]
    - path: "src/context/index.ts"
      provides: "Public API exports"
      exports: ["estimateTokens", "createContextTracker"]
  key_links:
    - from: "src/context/estimator.ts"
      to: "src/context/types.ts"
      via: "type imports"
      pattern: "import.*from.*types"
---

<objective>
Implement token estimation using text.length / 4 pattern and cumulative context tracking.

Purpose: Foundation for context window monitoring - enables subagents to track their own context usage
Output: Context types, token estimator function, cumulative tracker class
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-context-monitor/10-RESEARCH.md

# Existing patterns to follow
@src/state/types.ts
@src/state/state-manager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create context types</name>
  <files>src/context/types.ts</files>
  <action>
Create type definitions for context monitoring:

1. **Constants:**
   - `CHARS_PER_TOKEN = 4` (standard approximation)
   - `CLAUDE_DEFAULT_CONTEXT_LIMIT = 200_000` (200K tokens default)
   - `WARNING_THRESHOLD = 0.70` (70% - prepare handoff)
   - `CRITICAL_THRESHOLD = 0.85` (85% - force return)

2. **ContextConfig interface:**
   - `contextLimit?: number` (default 200K, can be 1M)
   - `warningThreshold?: number` (default 0.70)
   - `criticalThreshold?: number` (default 0.85)

3. **ContextState interface (for file persistence):**
   - `sessionId: string` (unique per subagent session)
   - `cumulativeChars: number` (total characters tracked)
   - `estimatedTokens: number` (chars / 4)
   - `usageRatio: number` (tokens / limit)
   - `thresholdStatus: 'normal' | 'warning' | 'critical'`
   - `lastUpdated: string` (ISO timestamp)

4. **ContextUsageResult interface:**
   - `totalTokens: number`
   - `usageRatio: number`
   - `isWarning: boolean`
   - `isCritical: boolean`
   - `action: 'none' | 'prepare_handoff' | 'force_return'`

Follow existing src/state/types.ts patterns for exports and documentation.
  </action>
  <verify>
`npx tsc --noEmit` passes - types compile without errors
  </verify>
  <done>
All context types defined and exported, constants for thresholds established
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement token estimator and cumulative tracker</name>
  <files>src/context/estimator.ts, src/context/index.ts</files>
  <action>
Create the token estimation and tracking implementation:

**estimator.ts:**

1. **estimateTokens(text: string): number**
   - Return `Math.ceil(text.length / CHARS_PER_TOKEN)`
   - Simple, fast approximation

2. **getContextLimit(): number**
   - Check `process.env.ANTHROPIC_1M_CONTEXT` for extended limit
   - Return 1_000_000 if set, otherwise CLAUDE_DEFAULT_CONTEXT_LIMIT

3. **analyzeContextUsage(cumulativeChars: number, config?: ContextConfig): ContextUsageResult**
   - Calculate tokens: `Math.ceil(cumulativeChars / CHARS_PER_TOKEN)`
   - Calculate ratio: `tokens / limit`
   - Determine thresholds and action
   - Return complete ContextUsageResult

4. **createContextTracker(sessionId: string, config?: ContextConfig)**
   - Returns tracker object with methods:
     - `trackContent(text: string): void` - adds to cumulative
     - `getState(): ContextState` - returns current state
     - `getUsage(): ContextUsageResult` - analyzes current usage
     - `reset(): void` - resets cumulative count
   - Internal state: cumulativeChars, sessionId, config

**index.ts:**
   - Export all public functions and types from types.ts and estimator.ts

Follow existing module patterns (see src/state/index.ts if exists).
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. Create simple test: `echo "import { estimateTokens } from './src/context/index.js'; console.log(estimateTokens('hello'));" | npx tsx` should output 2 (5 chars / 4 = 1.25, ceil = 2)
  </verify>
  <done>
- estimateTokens returns token approximation from text length
- createContextTracker provides cumulative tracking with state access
- analyzeContextUsage determines threshold status and required action
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - All files compile
2. Import test: `import { estimateTokens, createContextTracker, analyzeContextUsage } from './src/context/index.js'`
3. Estimate 1000 chars -> 250 tokens
4. Tracker accumulates across multiple trackContent calls
</verification>

<success_criteria>
- Token estimation works (text.length / 4)
- Context tracker accumulates chars and computes usage
- Threshold analysis returns correct action for normal/warning/critical states
- All exports accessible from src/context/index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/10-context-monitor/10-01-SUMMARY.md`
</output>

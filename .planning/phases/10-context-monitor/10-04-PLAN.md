---
phase: 10-context-monitor
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/orchestration/context-polling/types.ts
  - src/orchestration/context-polling/poller.ts
  - src/orchestration/context-polling/index.ts
autonomous: true

must_haves:
  truths:
    - "Orchestrator can poll subagent state files"
    - "Stale heartbeats (>60s) are detected"
    - "Checkpoint-ready subagents are identified"
    - "Polling loop runs at 5-second intervals"
  artifacts:
    - path: "src/orchestration/context-polling/types.ts"
      provides: "Polling types and constants"
      exports: ["PollResult", "SubagentStatus", "POLL_INTERVAL_MS", "STALE_THRESHOLD_MS"]
    - path: "src/orchestration/context-polling/poller.ts"
      provides: "Polling functions and loop"
      exports: ["pollSubagent", "pollAllSubagents", "startPollingLoop", "stopPollingLoop"]
    - path: "src/orchestration/context-polling/index.ts"
      provides: "Public API"
      exports: ["pollSubagent", "startPollingLoop"]
  key_links:
    - from: "src/orchestration/context-polling/poller.ts"
      to: "src/state/state-manager.ts"
      via: "reads subagent state files"
      pattern: "StateManager.*subagents"
---

<objective>
Implement orchestrator-side polling for subagent state files.

Purpose: Orchestrator monitors subagent health and detects when checkpoint handoff is needed
Output: Polling utilities and loop for watching subagent state files
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-context-monitor/10-RESEARCH.md

# Existing state patterns
@src/state/state-manager.ts
@src/state/types.ts
@src/orchestration/ultrapilot/state.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define polling types and constants</name>
  <files>src/orchestration/context-polling/types.ts</files>
  <action>
Create types for orchestrator polling:

1. **Constants:**
   - `POLL_INTERVAL_MS = 5000` (5 seconds)
   - `STALE_THRESHOLD_MS = 60 * 1000` (1 minute)
   - `SUBAGENT_STATE_DIR = 'subagents'` (relative to STATE_DIR)

2. **SubagentStatus type:**
   - `'active'` - Running normally
   - `'stale'` - Heartbeat older than threshold
   - `'checkpoint_ready'` - Has checkpoint data
   - `'not_found'` - State file doesn't exist
   - `'completed'` - Finished (active=false)

3. **PollResult interface:**
   - `agentId: string`
   - `status: SubagentStatus`
   - `contextUsage?: number` - Usage ratio if active
   - `thresholdStatus?: 'normal' | 'warning' | 'critical'`
   - `checkpoint?: CheckpointReturn` - If checkpoint_ready
   - `lastHeartbeat?: string` - ISO timestamp
   - `error?: string` - If polling failed

4. **PollingLoopConfig interface:**
   - `intervalMs?: number` (default POLL_INTERVAL_MS)
   - `staleThresholdMs?: number` (default STALE_THRESHOLD_MS)
   - `onCheckpointReady?: (agentId: string, checkpoint: CheckpointReturn) => void`
   - `onStale?: (agentId: string) => void`
   - `onError?: (agentId: string, error: Error) => void`

5. **PollingLoopHandle interface:**
   - `stop(): void` - Stop the polling loop
   - `isRunning(): boolean` - Check if loop is active
   - `getLastPollTime(): Date | null` - Last poll timestamp

Import CheckpointReturn type from context module (will be available).
  </action>
  <verify>
`npx tsc --noEmit` passes
  </verify>
  <done>
All polling types defined with proper constants for timing
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement polling functions</name>
  <files>src/orchestration/context-polling/poller.ts, src/orchestration/context-polling/index.ts</files>
  <action>
Create polling implementation:

**poller.ts:**

1. **pollSubagent(agentId: string): PollResult**
   - Create StateManager for `subagents/${agentId}` (LOCAL)
   - Read state file
   - If not exists: return { agentId, status: 'not_found' }
   - If parse error: return { agentId, status: 'not_found', error: message }
   - Check active field: if false, return { agentId, status: 'completed' }
   - Check lastHeartbeat age:
     - If > STALE_THRESHOLD_MS: return { agentId, status: 'stale', lastHeartbeat }
   - Check for checkpoint field:
     - If present: return { agentId, status: 'checkpoint_ready', checkpoint, contextUsage, thresholdStatus }
   - Return { agentId, status: 'active', contextUsage, thresholdStatus, lastHeartbeat }

2. **pollAllSubagents(agentIds: string[]): PollResult[]**
   - Map over agentIds, call pollSubagent for each
   - Return array of results

3. **startPollingLoop(agentIds: string[], config?: PollingLoopConfig): PollingLoopHandle**
   - Create interval with setInterval
   - On each tick: pollAllSubagents, call callbacks for checkpoint_ready and stale
   - Return handle with stop(), isRunning(), getLastPollTime()

4. **stopPollingLoop(handle: PollingLoopHandle): void**
   - Calls handle.stop()

5. **listActiveSubagents(): string[]**
   - List files in .ultraplan/state/subagents/
   - Return agentIds (filenames without .json)
   - Filter out .tmp files

**index.ts:**
- Export: pollSubagent, pollAllSubagents, startPollingLoop, stopPollingLoop, listActiveSubagents
- Export all types from types.ts
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. pollSubagent returns correct status for different states
3. Polling loop can be started and stopped
  </verify>
  <done>
- pollSubagent correctly determines status from state file
- Stale detection based on heartbeat age works
- Checkpoint-ready detection works
- Polling loop runs at configured interval
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - All files compile
2. pollSubagent returns 'not_found' for missing state file
3. pollSubagent returns 'stale' for old heartbeat
4. pollSubagent returns 'checkpoint_ready' when checkpoint present
5. Polling loop invokes callbacks correctly
</verification>

<success_criteria>
- Orchestrator can poll subagent state files
- Stale heartbeats detected within threshold
- Checkpoint-ready state triggers callback
- Polling loop manageable via handle
</success_criteria>

<output>
After completion, create `.planning/phases/10-context-monitor/10-04-SUMMARY.md`
</output>

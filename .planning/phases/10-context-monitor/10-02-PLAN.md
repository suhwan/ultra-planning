---
phase: 10-context-monitor
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/context/monitor.ts
  - src/context/thresholds.ts
  - src/context/index.ts
  - src/state/types.ts
autonomous: true

must_haves:
  truths:
    - "70% threshold triggers prepare_handoff action"
    - "85% threshold triggers force_return action"
    - "Monitor persists state to file for orchestrator polling"
    - "Threshold events are emitted to event system"
  artifacts:
    - path: "src/context/thresholds.ts"
      provides: "Threshold detection and action determination"
      exports: ["detectThreshold", "getThresholdAction"]
    - path: "src/context/monitor.ts"
      provides: "ContextMonitor class with file persistence"
      exports: ["ContextMonitor", "createContextMonitor"]
  key_links:
    - from: "src/context/monitor.ts"
      to: "src/context/estimator.ts"
      via: "uses createContextTracker"
      pattern: "createContextTracker"
    - from: "src/context/monitor.ts"
      to: "src/state/state-manager.ts"
      via: "persists state"
      pattern: "StateManager"
    - from: "src/context/monitor.ts"
      to: "src/state/event-system.ts"
      via: "emits threshold events"
      pattern: "emitEvent"
---

<objective>
Implement threshold detection and ContextMonitor class with state persistence.

Purpose: Subagents use ContextMonitor to track usage and trigger appropriate actions at thresholds
Output: Threshold detection logic, ContextMonitor class with file-based state persistence
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-context-monitor/10-RESEARCH.md

# Phase 10-01 dependencies (will exist when this runs)
@src/context/types.ts
@src/context/estimator.ts

# Existing patterns to integrate with
@src/state/state-manager.ts
@src/state/event-system.ts
@src/state/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement threshold detection</name>
  <files>src/context/thresholds.ts</files>
  <action>
Create threshold detection utilities:

1. **ThresholdLevel type:**
   - `'normal' | 'warning' | 'critical'`

2. **ThresholdAction interface:**
   - `level: ThresholdLevel`
   - `action: 'none' | 'prepare_handoff' | 'force_return'`
   - `message: string` (human-readable explanation)

3. **detectThreshold(usageRatio: number, config?: ContextConfig): ThresholdLevel**
   - If ratio >= criticalThreshold (0.85): return 'critical'
   - If ratio >= warningThreshold (0.70): return 'warning'
   - Otherwise: return 'normal'

4. **getThresholdAction(level: ThresholdLevel): ThresholdAction**
   - 'critical': action='force_return', message='Context critical (85%+) - initiating checkpoint return'
   - 'warning': action='prepare_handoff', message='Context warning (70%+) - complete current task, prepare clean handoff'
   - 'normal': action='none', message='Context normal'

5. **shouldEmitEvent(previousLevel: ThresholdLevel, currentLevel: ThresholdLevel): boolean**
   - Return true if level changed (for event emission)
   - Prevents duplicate events on same threshold

Keep functions pure and testable. Use constants from types.ts.
  </action>
  <verify>
`npx tsc --noEmit` passes
  </verify>
  <done>
Threshold detection correctly identifies normal/warning/critical states with appropriate actions
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement ContextMonitor class</name>
  <files>src/context/monitor.ts, src/context/index.ts</files>
  <action>
Create ContextMonitor class that integrates tracking with persistence:

**monitor.ts:**

1. **SubagentContextState interface (extends Record&lt;string, unknown&gt;):**
   - `agentId: string`
   - `sessionId: string`
   - `active: boolean`
   - `startedAt: string`
   - `lastHeartbeat: string`
   - Context fields: cumulativeChars, estimatedTokens, usageRatio, thresholdStatus
   - Task progress: currentTask?, tasksCompleted, tasksTotal

2. **ContextMonitor class:**
   ```typescript
   constructor(agentId: string, config?: ContextConfig)
   ```
   - Creates StateManager for `subagents/${agentId}` (LOCAL)
   - Creates internal context tracker via createContextTracker
   - Stores config with defaults

3. **Methods:**
   - `start(): void` - Initialize state file with active=true, heartbeat
   - `trackContent(text: string): ThresholdAction` - Add content, update state, return action
   - `updateHeartbeat(): void` - Update lastHeartbeat timestamp
   - `setCurrentTask(task: string): void` - Update currentTask field
   - `completeTask(): void` - Increment tasksCompleted
   - `getState(): SubagentContextState` - Return current state
   - `getThresholdAction(): ThresholdAction` - Get action for current level
   - `stop(): void` - Set active=false

4. **Event emission:**
   - On threshold change (warning/critical), emit event via emitEvent:
     - type: 'context_threshold_reached' (add to StateEventType in state/types.ts)
     - payload: { agentId, level, usageRatio, action }
     - source: `agent:${agentId}`

5. **createContextMonitor(agentId: string, config?: ContextConfig): ContextMonitor**
   - Factory function for creating monitors

**index.ts:**
   - Add exports for ContextMonitor, createContextMonitor, SubagentContextState
   - Add exports for thresholds.ts functions

**state/types.ts:**
   - Add 'context_threshold_reached' to StateEventType union
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. State file created at .ultraplan/state/subagents/{agentId}.json
3. trackContent returns appropriate ThresholdAction
  </verify>
  <done>
- ContextMonitor persists state to file for orchestrator polling
- Threshold transitions emit events
- Heartbeat updated for stale detection
- All exports available from src/context/index.ts
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - All files compile
2. Monitor creates state file in .ultraplan/state/subagents/
3. trackContent at 70% usage returns 'prepare_handoff' action
4. trackContent at 85% usage returns 'force_return' action
5. Event emitted on threshold change
</verification>

<success_criteria>
- detectThreshold correctly identifies threshold levels
- ContextMonitor persists state to subagent-specific file
- Threshold events emitted on state changes
- Heartbeat mechanism for stale detection
</success_criteria>

<output>
After completion, create `.planning/phases/10-context-monitor/10-02-SUMMARY.md`
</output>

---
phase: 15-layered-memory
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - src/memory/collector.ts
  - src/memory/extractor.ts
  - src/memory/index.ts
autonomous: true

must_haves:
  truths:
    - "Agent results are analyzed for wisdom-worthy content"
    - "Learnings/decisions/issues auto-extracted from agent output"
    - "Extracted wisdom appended to long-term memory"
  artifacts:
    - path: "src/memory/extractor.ts"
      provides: "Wisdom extraction from text"
      exports: ["extractWisdom", "WisdomExtraction"]
    - path: "src/memory/collector.ts"
      provides: "Automatic wisdom collection orchestration"
      exports: ["WisdomCollector"]
  key_links:
    - from: "src/memory/collector.ts"
      to: "src/memory/long-term.ts"
      via: "appendLearning/appendDecision/appendIssue"
      pattern: "longTermManager\\.append"
    - from: "src/memory/collector.ts"
      to: "src/memory/extractor.ts"
      via: "extractWisdom call"
      pattern: "extractWisdom\\("
---

<objective>
Implement automatic wisdom extraction from agent results.

Purpose: When subagents complete work, analyze their output for learnings, decisions, and issues worth preserving. This enables automatic knowledge accumulation without manual curation.

Output: Extractor module for parsing agent output, collector module for orchestrating the flow.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/v4.0-VISION.md

Reference from 15-01:
@src/memory/types.ts
@src/memory/long-term.ts

Existing patterns:
@src/notepad/api.ts - Entry formatting patterns
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wisdom extraction logic</name>
  <files>src/memory/extractor.ts</files>
  <action>
Create wisdom extraction module that analyzes agent output text:

```typescript
export interface WisdomExtraction {
  learnings: string[];
  decisions: string[];
  issues: string[];
  patterns: string[];
  confidence: number;  // 0-1, higher = more confident extraction
}

// Extraction patterns - look for these markers in agent output
const LEARNING_MARKERS = [
  /(?:learned|discovered|found out|realized|noticed)[:.]?\s*(.+)/gi,
  /(?:pattern|approach|technique)[:.]?\s*(.+)/gi,
  /(?:tip|trick|gotcha|note)[:.]?\s*(.+)/gi,
];

const DECISION_MARKERS = [
  /(?:decided|chose|selected|picked)[:.]?\s*(.+)/gi,
  /(?:using|will use|went with)[:.]?\s*(.+)/gi,
  /(?:because|since|rationale)[:.]?\s*(.+)/gi,
];

const ISSUE_MARKERS = [
  /(?:issue|problem|bug|error|failed|broken)[:.]?\s*(.+)/gi,
  /(?:workaround|fix|solution)[:.]?\s*(.+)/gi,
  /(?:warning|caution|careful)[:.]?\s*(.+)/gi,
];

const PATTERN_MARKERS = [
  /(?:file|path)[:.]?\s*`([^`]+)`/g,  // Code references like `src/foo.ts:10-20`
  /(?:pattern found|see also|reference)[:.]?\s*(.+)/gi,
];

export function extractWisdom(text: string): WisdomExtraction {
  const result: WisdomExtraction = {
    learnings: [],
    decisions: [],
    issues: [],
    patterns: [],
    confidence: 0,
  };

  // Extract each category
  result.learnings = extractMatches(text, LEARNING_MARKERS);
  result.decisions = extractMatches(text, DECISION_MARKERS);
  result.issues = extractMatches(text, ISSUE_MARKERS);
  result.patterns = extractMatches(text, PATTERN_MARKERS);

  // Calculate confidence based on extraction count
  const total = result.learnings.length + result.decisions.length +
                result.issues.length + result.patterns.length;
  result.confidence = Math.min(total / 10, 1);  // Cap at 1.0

  return result;
}

function extractMatches(text: string, patterns: RegExp[]): string[] {
  const matches: string[] = [];
  for (const pattern of patterns) {
    let match;
    const regex = new RegExp(pattern.source, pattern.flags);
    while ((match = regex.exec(text)) !== null) {
      const content = match[1]?.trim();
      if (content && content.length > 10 && content.length < 500) {
        matches.push(content);
      }
    }
  }
  return [...new Set(matches)];  // Deduplicate
}
```

Keep extraction simple and conservative - false negatives better than false positives.
  </action>
  <verify>npm run build -- --noEmit</verify>
  <done>extractWisdom parses text and returns WisdomExtraction with learnings/decisions/issues/patterns</done>
</task>

<task type="auto">
  <name>Task 2: Wisdom collector orchestration</name>
  <files>src/memory/collector.ts</files>
  <action>
Create collector that orchestrates wisdom flow from agent output to long-term storage:

```typescript
import { LongTermMemoryManager } from './long-term.js';
import { extractWisdom, WisdomExtraction } from './extractor.js';
import { MemoryConfig, DEFAULT_MEMORY_CONFIG } from './types.js';

export interface CollectionResult {
  extracted: WisdomExtraction;
  stored: {
    learnings: number;
    decisions: number;
    issues: number;
    patterns: number;
  };
  skipped: number;  // Items below confidence threshold
}

export class WisdomCollector {
  private longTermManager: LongTermMemoryManager;
  private minConfidence: number;

  constructor(
    config: Partial<MemoryConfig> = {},
    minConfidence: number = 0.3
  ) {
    this.longTermManager = new LongTermMemoryManager(config);
    this.minConfidence = minConfidence;
  }

  /**
   * Collect wisdom from agent output
   * Called after subagent completes work
   */
  collectFromAgentOutput(
    agentOutput: string,
    taskId: string
  ): CollectionResult {
    const extracted = extractWisdom(agentOutput);

    const result: CollectionResult = {
      extracted,
      stored: { learnings: 0, decisions: 0, issues: 0, patterns: 0 },
      skipped: 0,
    };

    // Skip if confidence too low
    if (extracted.confidence < this.minConfidence) {
      result.skipped = extracted.learnings.length + extracted.decisions.length +
                       extracted.issues.length + extracted.patterns.length;
      return result;
    }

    // Store each category
    for (const learning of extracted.learnings) {
      if (this.longTermManager.appendLearning(learning, taskId)) {
        result.stored.learnings++;
      }
    }

    for (const decision of extracted.decisions) {
      if (this.longTermManager.appendDecision(decision, taskId)) {
        result.stored.decisions++;
      }
    }

    for (const issue of extracted.issues) {
      if (this.longTermManager.appendIssue(issue, taskId)) {
        result.stored.issues++;
      }
    }

    for (const pattern of extracted.patterns) {
      if (this.longTermManager.appendPattern(pattern, taskId)) {
        result.stored.patterns++;
      }
    }

    return result;
  }

  /**
   * Batch collect from multiple outputs (e.g., at plan completion)
   */
  collectFromMultipleOutputs(
    outputs: Array<{ taskId: string; output: string }>
  ): CollectionResult[] {
    return outputs.map(({ taskId, output }) =>
      this.collectFromAgentOutput(output, taskId)
    );
  }
}
```

Collector wraps extraction + storage. Orchestrator calls collectFromAgentOutput after each subagent.
  </action>
  <verify>npm run build -- --noEmit</verify>
  <done>WisdomCollector.collectFromAgentOutput extracts and stores wisdom to long-term memory</done>
</task>

<task type="auto">
  <name>Task 3: Update index exports</name>
  <files>src/memory/index.ts</files>
  <action>
Update index.ts to export new modules:

```typescript
// Types
export * from './types.js';

// Managers
export { WorkingMemoryManager } from './working.js';
export { ShortTermMemoryManager } from './short-term.js';
export { LongTermMemoryManager } from './long-term.js';

// Extraction and collection
export { extractWisdom, type WisdomExtraction } from './extractor.js';
export { WisdomCollector, type CollectionResult } from './collector.js';

// Snapshot utility
export { createMemorySnapshot } from './snapshot.js';
```

If createMemorySnapshot doesn't exist from 15-01, add it inline:

```typescript
export function createMemorySnapshot(
  config: Partial<MemoryConfig> = {}
): MemorySnapshot {
  const workingManager = new WorkingMemoryManager();
  const shortTermManager = new ShortTermMemoryManager(config);
  const longTermManager = new LongTermMemoryManager(config);

  const working = workingManager.getCurrentTask();
  const shortTerm = shortTermManager.loadFromState();
  const longTerm = longTermManager.loadWisdom();

  return {
    working,
    shortTerm,
    longTerm,
    totalTokens: (longTerm?.tokenEstimate || 0),
  };
}
```
  </action>
  <verify>npm run build -- --noEmit</verify>
  <done>All new exports available from src/memory/index.ts</done>
</task>

</tasks>

<verification>
1. `npm run build` passes
2. `extractWisdom("I learned that X works well")` returns learnings array
3. `WisdomCollector.collectFromAgentOutput()` stores to wisdom files
</verification>

<success_criteria>
- extractWisdom parses agent text for wisdom-worthy content
- WisdomCollector orchestrates extraction to long-term storage
- Confidence threshold filters low-quality extractions
- All new APIs exported from index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/15-layered-memory/15-02-SUMMARY.md`
</output>

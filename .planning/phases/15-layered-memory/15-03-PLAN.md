---
phase: 15-layered-memory
plan: 03
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - src/memory/session-loader.ts
  - src/memory/prompt-injector.ts
  - src/memory/index.ts
autonomous: true

must_haves:
  truths:
    - "Wisdom automatically loaded at session start"
    - "Loaded wisdom injected into subagent prompts"
    - "Token budget respected during injection"
  artifacts:
    - path: "src/memory/session-loader.ts"
      provides: "Session-start wisdom loading"
      exports: ["SessionWisdomLoader"]
    - path: "src/memory/prompt-injector.ts"
      provides: "Wisdom formatting for prompt injection"
      exports: ["WisdomPromptInjector", "formatWisdomBlock"]
  key_links:
    - from: "src/memory/session-loader.ts"
      to: "src/memory/long-term.ts"
      via: "loadWisdom"
      pattern: "longTermManager\\.loadWisdom"
    - from: "src/memory/prompt-injector.ts"
      to: "src/memory/types.ts"
      via: "LongTermMemory type"
      pattern: "LongTermMemory"
---

<objective>
Enable cross-session wisdom persistence by loading long-term memory at session start and injecting it into subagent prompts.

Purpose: Knowledge accumulated in previous sessions becomes available to new sessions automatically, enabling continuous learning across the project lifecycle.

Output: Session loader for startup, prompt injector for subagent delegation.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/v4.0-VISION.md

Reference from 15-01:
@src/memory/types.ts
@src/memory/long-term.ts

Existing injection patterns:
@src/notepad/injector.ts - formatWisdomForPrompt, createWisdomDirective
</context>

<tasks>

<task type="auto">
  <name>Task 1: Session wisdom loader</name>
  <files>src/memory/session-loader.ts</files>
  <action>
Create module that loads wisdom at session start:

```typescript
import { LongTermMemoryManager } from './long-term.js';
import { ShortTermMemoryManager } from './short-term.js';
import { LongTermMemory, ShortTermMemory, MemoryConfig, DEFAULT_MEMORY_CONFIG } from './types.js';

export interface SessionContext {
  sessionId: string;
  startTime: string;  // ISO timestamp
  longTermMemory: LongTermMemory | null;
  shortTermMemory: ShortTermMemory | null;
  loaded: boolean;
}

export class SessionWisdomLoader {
  private config: MemoryConfig;
  private longTermManager: LongTermMemoryManager;
  private shortTermManager: ShortTermMemoryManager;
  private sessionContext: SessionContext | null = null;

  constructor(config: Partial<MemoryConfig> = {}) {
    this.config = { ...DEFAULT_MEMORY_CONFIG, ...config };
    this.longTermManager = new LongTermMemoryManager(this.config);
    this.shortTermManager = new ShortTermMemoryManager(this.config);
  }

  /**
   * Initialize session and load all persistent memory
   * Call this at orchestrator startup
   */
  initSession(): SessionContext {
    const sessionId = this.generateSessionId();

    // Ensure wisdom directory exists
    this.longTermManager.initWisdomDir();

    // Load both memory layers
    const longTermMemory = this.longTermManager.loadWisdom();
    const shortTermMemory = this.shortTermManager.loadFromState();

    this.sessionContext = {
      sessionId,
      startTime: new Date().toISOString(),
      longTermMemory,
      shortTermMemory,
      loaded: true,
    };

    return this.sessionContext;
  }

  /**
   * Get current session context
   * Returns null if initSession() not called
   */
  getSessionContext(): SessionContext | null {
    return this.sessionContext;
  }

  /**
   * Refresh long-term memory (e.g., after wisdom collection)
   */
  refreshLongTermMemory(): LongTermMemory | null {
    const longTermMemory = this.longTermManager.loadWisdom();
    if (this.sessionContext) {
      this.sessionContext.longTermMemory = longTermMemory;
    }
    return longTermMemory;
  }

  /**
   * Get wisdom summary for quick status check
   */
  getWisdomStats(): { learnings: number; decisions: number; issues: number; patterns: number } | null {
    if (!this.sessionContext?.longTermMemory) {
      return null;
    }
    const mem = this.sessionContext.longTermMemory;
    return {
      learnings: mem.learnings.length,
      decisions: mem.decisions.length,
      issues: mem.issues.length,
      patterns: mem.patterns.length,
    };
  }

  private generateSessionId(): string {
    return `session-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  }
}
```

Loader initializes at orchestrator start, caches context for the session duration.
  </action>
  <verify>npm run build -- --noEmit</verify>
  <done>SessionWisdomLoader.initSession() loads long-term and short-term memory</done>
</task>

<task type="auto">
  <name>Task 2: Prompt injection formatting</name>
  <files>src/memory/prompt-injector.ts</files>
  <action>
Create prompt injector that formats wisdom for subagent prompts:

```typescript
import { LongTermMemory, MemoryConfig, DEFAULT_MEMORY_CONFIG } from './types.js';

const CHARS_PER_TOKEN = 4;

/**
 * Format long-term wisdom into injectable prompt block
 * Priority: issues > decisions > learnings (most actionable first)
 */
export function formatWisdomBlock(
  memory: LongTermMemory | null,
  maxTokens: number = 1000
): string {
  if (!memory) {
    return '';
  }

  const maxChars = maxTokens * CHARS_PER_TOKEN;
  const sections: string[] = [];

  // Issues first (blockers/warnings)
  if (memory.issues.length > 0) {
    const issueText = memory.issues.slice(0, 5).map(i => `- ${i}`).join('\n');
    sections.push(`### Known Issues\n${issueText}`);
  }

  // Decisions (architectural context)
  if (memory.decisions.length > 0) {
    const decisionText = memory.decisions.slice(0, 5).map(d => `- ${d}`).join('\n');
    sections.push(`### Key Decisions\n${decisionText}`);
  }

  // Learnings (patterns and knowledge)
  if (memory.learnings.length > 0) {
    const learningText = memory.learnings.slice(0, 5).map(l => `- ${l}`).join('\n');
    sections.push(`### Accumulated Knowledge\n${learningText}`);
  }

  // Patterns (code references)
  if (memory.patterns.length > 0) {
    const patternText = memory.patterns.slice(0, 3).map(p => `- \`${p}\``).join('\n');
    sections.push(`### Useful Patterns\n${patternText}`);
  }

  let formatted = sections.join('\n\n');

  // Truncate if over budget
  if (formatted.length > maxChars) {
    formatted = formatted.slice(0, maxChars - 20) + '\n\n[...truncated]';
  }

  return formatted;
}

export class WisdomPromptInjector {
  private config: MemoryConfig;

  constructor(config: Partial<MemoryConfig> = {}) {
    this.config = { ...DEFAULT_MEMORY_CONFIG, ...config };
  }

  /**
   * Create full wisdom directive for subagent prompts
   * Includes wisdom + instructions for recording new learnings
   */
  createInjectionBlock(
    longTermMemory: LongTermMemory | null,
    currentPlanId: string | null = null
  ): string {
    const wisdomBlock = formatWisdomBlock(longTermMemory, this.config.maxWisdomTokens);

    if (!wisdomBlock && !currentPlanId) {
      return '';
    }

    const parts: string[] = ['<project-wisdom>'];

    if (wisdomBlock) {
      parts.push('## Accumulated Project Wisdom');
      parts.push('');
      parts.push(wisdomBlock);
      parts.push('');
    }

    // Instructions for recording new wisdom
    parts.push('## Recording New Wisdom');
    parts.push('');
    parts.push(`WISDOM PATH: ${this.config.baseDir}/${this.config.wisdomDir}/`);
    parts.push('');
    parts.push('After completing work, record significant findings:');
    parts.push('- learnings.md: Patterns, techniques, gotchas');
    parts.push('- decisions.md: Architectural choices with rationale');
    parts.push('- issues.md: Problems encountered and solutions');
    parts.push('');
    parts.push('Format: ## YYYY-MM-DDTHH:MM:SSZ | Task: {taskId}');
    parts.push('');
    parts.push('</project-wisdom>');

    return parts.join('\n');
  }

  /**
   * Estimate tokens for a wisdom block
   */
  estimateTokens(memory: LongTermMemory | null): number {
    if (!memory) return 0;
    return memory.tokenEstimate;
  }
}
```

Injector formats wisdom with priority ordering and respects token budgets.
  </action>
  <verify>npm run build -- --noEmit</verify>
  <done>WisdomPromptInjector.createInjectionBlock formats wisdom for subagent prompts</done>
</task>

<task type="auto">
  <name>Task 3: Update index and integration</name>
  <files>src/memory/index.ts</files>
  <action>
Update index.ts to export session loader and prompt injector:

```typescript
// Types
export * from './types.js';

// Managers
export { WorkingMemoryManager } from './working.js';
export { ShortTermMemoryManager } from './short-term.js';
export { LongTermMemoryManager } from './long-term.js';

// Extraction and collection (from 15-02)
export { extractWisdom, type WisdomExtraction } from './extractor.js';
export { WisdomCollector, type CollectionResult } from './collector.js';

// Session and injection (from 15-03)
export { SessionWisdomLoader, type SessionContext } from './session-loader.js';
export { WisdomPromptInjector, formatWisdomBlock } from './prompt-injector.js';

// Convenience function for orchestrator startup
export function initializeMemorySystem(
  config: Partial<MemoryConfig> = {}
): {
  sessionLoader: SessionWisdomLoader;
  collector: WisdomCollector;
  injector: WisdomPromptInjector;
} {
  const sessionLoader = new SessionWisdomLoader(config);
  const collector = new WisdomCollector(config);
  const injector = new WisdomPromptInjector(config);

  // Initialize session (loads all persistent memory)
  sessionLoader.initSession();

  return { sessionLoader, collector, injector };
}
```

The initializeMemorySystem function provides a single entry point for orchestrators.
  </action>
  <verify>npm run build -- --noEmit</verify>
  <done>All session/injection APIs exported, initializeMemorySystem convenience function available</done>
</task>

</tasks>

<verification>
1. `npm run build` passes
2. SessionWisdomLoader.initSession() loads from .planning/wisdom/
3. WisdomPromptInjector.createInjectionBlock() produces valid prompt block
4. initializeMemorySystem() returns all three components
</verification>

<success_criteria>
- Wisdom automatically loaded when session starts
- Loaded wisdom formatted and injected into subagent prompts
- Token budget (default 2000) respected during injection
- All APIs exported from index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/15-layered-memory/15-03-SUMMARY.md`
</output>

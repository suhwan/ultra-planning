---
phase: 15-layered-memory
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/memory/types.ts
  - src/memory/index.ts
  - src/memory/working.ts
  - src/memory/short-term.ts
  - src/memory/long-term.ts
autonomous: true

must_haves:
  truths:
    - "MemoryLayer enum distinguishes Working/ShortTerm/LongTerm"
    - "Each layer has defined lifetime and storage location"
    - ".planning/wisdom/ directory structure exists"
  artifacts:
    - path: "src/memory/types.ts"
      provides: "Memory layer type definitions"
      exports: ["MemoryLayer", "WorkingMemory", "ShortTermMemory", "LongTermMemory", "MemoryConfig"]
    - path: "src/memory/working.ts"
      provides: "Working memory (volatile PLAN.md tasks)"
      exports: ["WorkingMemoryManager"]
    - path: "src/memory/short-term.ts"
      provides: "Short-term memory (STATE.md + session)"
      exports: ["ShortTermMemoryManager"]
    - path: "src/memory/long-term.ts"
      provides: "Long-term memory (wisdom directory)"
      exports: ["LongTermMemoryManager"]
  key_links:
    - from: "src/memory/index.ts"
      to: "all managers"
      via: "re-exports"
      pattern: "export.*from"
---

<objective>
Define Memory layer types and initialize .planning/wisdom/ directory structure.

Purpose: Establish the three-layer memory hierarchy (Working/Short-term/Long-term) as the foundation for context engineering. Each layer has distinct lifetime and purpose.

Output: Type definitions, three memory managers, and wisdom directory structure.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/v4.0-VISION.md

Reference existing patterns:
@src/notepad/types.ts - WisdomSummary, NotepadCategory patterns
@src/notepad/manager.ts - Directory management pattern
@src/state/state-manager.ts - State management pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Memory layer types</name>
  <files>src/memory/types.ts</files>
  <action>
Create type definitions for the three-layer memory system:

```typescript
// Memory layers enum
export enum MemoryLayer {
  Working = 'working',      // Volatile, current task only
  ShortTerm = 'short-term', // Project lifetime (STATE.md)
  LongTerm = 'long-term',   // Persistent (wisdom/)
}

// Working memory: current PLAN.md task state
export interface WorkingMemory {
  layer: MemoryLayer.Working;
  currentPlan: string | null;  // e.g., "15-01"
  currentTask: string | null;  // e.g., "15-01-02"
  taskContext: Record<string, unknown>;  // Task-specific data
  volatile: true;  // Always true - cleared on completion
}

// Short-term memory: session and project state
export interface ShortTermMemory {
  layer: MemoryLayer.ShortTerm;
  sessionId: string;
  decisions: string[];  // From STATE.md
  pendingTodos: string[];
  blockers: string[];
  phaseProgress: { phase: number; plan: number; status: string };
}

// Long-term memory: persistent wisdom
export interface LongTermMemory {
  layer: MemoryLayer.LongTerm;
  learnings: string[];
  decisions: string[];
  issues: string[];
  patterns: string[];
  tokenEstimate: number;
}

// Config for memory system
export interface MemoryConfig {
  baseDir: string;  // Default: '.planning'
  wisdomDir: string;  // Default: 'wisdom'
  maxWisdomTokens: number;  // Default: 2000
}

export const DEFAULT_MEMORY_CONFIG: MemoryConfig = {
  baseDir: '.planning',
  wisdomDir: 'wisdom',
  maxWisdomTokens: 2000,
};

// Unified memory snapshot for context assembly
export interface MemorySnapshot {
  working: WorkingMemory | null;
  shortTerm: ShortTermMemory | null;
  longTerm: LongTermMemory | null;
  totalTokens: number;
}
```

Follow patterns from src/notepad/types.ts for consistency.
  </action>
  <verify>npm run build -- --noEmit</verify>
  <done>All memory layer types compile, MemoryLayer enum has 3 values, config has defaults</done>
</task>

<task type="auto">
  <name>Task 2: Memory managers implementation</name>
  <files>src/memory/working.ts, src/memory/short-term.ts, src/memory/long-term.ts, src/memory/index.ts</files>
  <action>
Create three memory managers, each handling one layer:

**WorkingMemoryManager (src/memory/working.ts):**
- In-memory only (volatile)
- setCurrentTask(planId, taskId, context)
- getCurrentTask(): WorkingMemory | null
- clearOnTaskComplete()
- No file I/O - purely runtime state

**ShortTermMemoryManager (src/memory/short-term.ts):**
- Reads from STATE.md and session files
- loadFromState(): ShortTermMemory
- updateProgress(phase, plan, status)
- addDecision(decision: string)
- Syncs with src/state/state-manager.ts

**LongTermMemoryManager (src/memory/long-term.ts):**
- Manages .planning/wisdom/ directory
- initWisdomDir(): creates wisdom/learnings.md, decisions.md, issues.md, patterns.md
- loadWisdom(): LongTermMemory
- appendLearning(content), appendDecision(content), appendIssue(content)
- getWisdomSummary(maxTokens): formatted string for injection
- Uses CHARS_PER_TOKEN = 4 for estimation (from notepad/types.ts)

**Index (src/memory/index.ts):**
- Re-export all types and managers
- Export createMemorySnapshot() that combines all three layers

Follow existing manager patterns from src/notepad/manager.ts.
  </action>
  <verify>npm run build -- --noEmit && ls src/memory/*.ts</verify>
  <done>All three managers compile, index exports all public API, wisdom directory creation works</done>
</task>

<task type="auto">
  <name>Task 3: Wisdom directory initialization</name>
  <files>src/memory/long-term.ts</files>
  <action>
Add wisdom directory initialization to LongTermMemoryManager:

```typescript
initWisdomDir(): boolean {
  const wisdomPath = join(this.config.baseDir, this.config.wisdomDir);

  if (!existsSync(wisdomPath)) {
    mkdirSync(wisdomPath, { recursive: true });
  }

  // Initialize files with headers
  const files = [
    { name: 'learnings.md', header: '# Long-term Learnings\n\nPersistent patterns and knowledge.\n' },
    { name: 'decisions.md', header: '# Long-term Decisions\n\nArchitectural choices and rationales.\n' },
    { name: 'issues.md', header: '# Long-term Issues\n\nRecurring problems and solutions.\n' },
    { name: 'patterns.md', header: '# Discovered Patterns\n\nCode patterns worth reusing.\n' },
  ];

  for (const file of files) {
    const filePath = join(wisdomPath, file.name);
    if (!existsSync(filePath)) {
      writeFileSync(filePath, file.header, 'utf-8');
    }
  }

  return true;
}
```

This differs from notepad/_project because:
1. Located at .planning/wisdom/ (not .planning/notepads/_project/)
2. Designed for cross-session persistence (notepad is per-plan)
3. Will be auto-loaded at session start
  </action>
  <verify>npm run build -- --noEmit</verify>
  <done>initWisdomDir creates .planning/wisdom/ with 4 markdown files</done>
</task>

</tasks>

<verification>
1. `npm run build` passes without errors
2. `ls src/memory/` shows: types.ts, working.ts, short-term.ts, long-term.ts, index.ts
3. Types are properly exported from index.ts
</verification>

<success_criteria>
- MemoryLayer enum with Working, ShortTerm, LongTerm values
- Three managers handling their respective layers
- LongTermMemoryManager.initWisdomDir() creates .planning/wisdom/
- All types compile and export correctly
</success_criteria>

<output>
After completion, create `.planning/phases/15-layered-memory/15-01-SUMMARY.md`
</output>

---
phase: 12-notepad-learning
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/notepad/types.ts
  - src/notepad/manager.ts
  - src/notepad/api.ts
  - src/notepad/index.ts
autonomous: true

must_haves:
  truths:
    - "NotepadEntry type defines timestamp, taskId, content, tags"
    - "NotepadManager can initialize plan notepad directory"
    - "addLearning appends entry to learnings.md"
    - "addDecision appends entry to decisions.md"
    - "addIssue appends entry to issues.md"
  artifacts:
    - path: "src/notepad/types.ts"
      provides: "Type definitions for notepad system"
      exports: ["NotepadEntry", "NotepadCategory", "LearningEntry", "DecisionEntry", "IssueEntry", "WisdomSummary"]
      min_lines: 40
    - path: "src/notepad/manager.ts"
      provides: "NotepadManager class for directory initialization"
      exports: ["NotepadManager"]
      contains: "initPlanNotepad"
      min_lines: 50
    - path: "src/notepad/api.ts"
      provides: "Write API functions"
      exports: ["addLearning", "addDecision", "addIssue"]
      min_lines: 80
    - path: "src/notepad/index.ts"
      provides: "Public exports"
      exports: ["NotepadManager", "addLearning", "addDecision", "addIssue"]
  key_links:
    - from: "src/notepad/api.ts"
      to: "src/notepad/types.ts"
      via: "imports NotepadEntry, LearningEntry types"
      pattern: "import.*from.*types"
    - from: "src/notepad/api.ts"
      to: ".planning/notepads/{planId}/*.md"
      via: "appendFileSync"
      pattern: "appendFileSync"
---

<objective>
Implement the foundational notepad types, manager, and write API for the learning system.

Purpose: Enable subagents to record learnings, decisions, and issues during task execution. This is the foundation for cross-plan knowledge transfer.

Output: Types (NotepadEntry, WisdomSummary), NotepadManager class, write API (addLearning, addDecision, addIssue)
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-notepad-learning/12-RESEARCH.md
@src/types.ts
@src/state/state-manager.ts
</context>

<research_findings>
From 12-RESEARCH.md:
- Use Markdown files with timestamped sections (not JSON)
- Timestamp format: ISO 8601 (`new Date().toISOString()`)
- Entry format: `## timestamp | Task: taskId\n\ncontent\n\n---`
- Always APPEND, never overwrite (appendFileSync)
- Base directory: `.planning/notepads/` (per decision 07-01)
- Categories: learnings.md, decisions.md, issues.md
</research_findings>

<tasks>

<task type="auto">
  <name>Task 1: Create notepad types</name>
  <files>src/notepad/types.ts</files>
  <action>
Create type definitions for the notepad system:

```typescript
// src/notepad/types.ts

/** Notepad categories */
export type NotepadCategory = 'learnings' | 'decisions' | 'issues';

/** Base notepad entry */
export interface NotepadEntry {
  timestamp: string;  // ISO 8601
  taskId: string;     // e.g., "03-01-02"
  content: string;
  tags?: string[];
}

/** Learning entry with pattern reference */
export interface LearningEntry extends NotepadEntry {
  pattern?: string;  // File:lines reference, e.g., "src/utils.ts:45-60"
}

/** Decision entry with rationale */
export interface DecisionEntry extends NotepadEntry {
  rationale: string;
  alternatives?: string[];
}

/** Issue entry with severity */
export interface IssueEntry extends NotepadEntry {
  severity: 'low' | 'medium' | 'high' | 'critical';
  status: 'open' | 'workaround' | 'resolved';
  workaround?: string;
}

/** Wisdom summary for injection */
export interface WisdomSummary {
  learnings: string[];
  decisions: string[];
  issues: string[];
  tokenEstimate: number;
}

/** Notepad config */
export interface NotepadConfig {
  baseDir: string;           // Default: '.planning'
  maxEntriesPerCategory: number;  // For wisdom extraction
  maxTokenBudget: number;    // For prompt injection
}

export const DEFAULT_NOTEPAD_CONFIG: NotepadConfig = {
  baseDir: '.planning',
  maxEntriesPerCategory: 5,
  maxTokenBudget: 1000,
};
```

Follow existing type patterns from src/types.ts (JSDoc comments, exported interfaces).
  </action>
  <verify>npx tsc --noEmit src/notepad/types.ts</verify>
  <done>types.ts compiles without errors, exports all listed types</done>
</task>

<task type="auto">
  <name>Task 2: Create NotepadManager class</name>
  <files>src/notepad/manager.ts</files>
  <action>
Create NotepadManager class for directory initialization:

```typescript
// src/notepad/manager.ts

import { mkdirSync, existsSync, writeFileSync } from 'fs';
import { join } from 'path';
import { NotepadConfig, DEFAULT_NOTEPAD_CONFIG, NotepadCategory } from './types.js';

/**
 * Manages notepad directory structure and initialization
 */
export class NotepadManager {
  private readonly config: NotepadConfig;

  constructor(config: Partial<NotepadConfig> = {}) {
    this.config = { ...DEFAULT_NOTEPAD_CONFIG, ...config };
  }

  /**
   * Get path to a plan's notepad directory
   */
  getPlanNotepadDir(planId: string): string {
    return join(this.config.baseDir, 'notepads', planId);
  }

  /**
   * Get path to project-level notepad directory
   */
  getProjectNotepadDir(): string {
    return join(this.config.baseDir, 'notepads', '_project');
  }

  /**
   * Get path to specific notepad file
   */
  getNotepadPath(planId: string, category: NotepadCategory): string {
    return join(this.getPlanNotepadDir(planId), `${category}.md`);
  }

  /**
   * Initialize notepad directory for a plan
   * Creates directory and empty category files if they don't exist
   */
  initPlanNotepad(planId: string): boolean {
    const notepadDir = this.getPlanNotepadDir(planId);

    try {
      if (!existsSync(notepadDir)) {
        mkdirSync(notepadDir, { recursive: true });
      }

      // Initialize category files with headers
      const categories: NotepadCategory[] = ['learnings', 'decisions', 'issues'];
      for (const category of categories) {
        const filePath = join(notepadDir, `${category}.md`);
        if (!existsSync(filePath)) {
          const header = `# ${category.charAt(0).toUpperCase() + category.slice(1)}\n\n`;
          writeFileSync(filePath, header, 'utf-8');
        }
      }

      return true;
    } catch {
      return false;
    }
  }

  /**
   * Initialize project-level notepad directory
   */
  initProjectNotepad(): boolean {
    const projectDir = this.getProjectNotepadDir();

    try {
      if (!existsSync(projectDir)) {
        mkdirSync(projectDir, { recursive: true });
      }

      // Project level has additional files
      const files = ['learnings.md', 'decisions.md', 'issues.md', 'patterns.md', 'summary.md'];
      for (const file of files) {
        const filePath = join(projectDir, file);
        if (!existsSync(filePath)) {
          const name = file.replace('.md', '');
          const header = `# Project ${name.charAt(0).toUpperCase() + name.slice(1)}\n\n`;
          writeFileSync(filePath, header, 'utf-8');
        }
      }

      return true;
    } catch {
      return false;
    }
  }

  /**
   * Check if notepad exists for a plan
   */
  notepadExists(planId: string): boolean {
    return existsSync(this.getPlanNotepadDir(planId));
  }
}
```

Follow StateManager pattern from src/state/state-manager.ts for consistency.
  </action>
  <verify>npx tsc --noEmit src/notepad/manager.ts</verify>
  <done>manager.ts compiles, NotepadManager class exports initPlanNotepad, getPlanNotepadDir</done>
</task>

<task type="auto">
  <name>Task 3: Create write API functions</name>
  <files>src/notepad/api.ts, src/notepad/index.ts</files>
  <action>
Create write API functions that append entries to notepad files:

```typescript
// src/notepad/api.ts

import { appendFileSync, existsSync } from 'fs';
import { NotepadManager } from './manager.js';
import {
  LearningEntry,
  DecisionEntry,
  IssueEntry,
  NotepadConfig,
  DEFAULT_NOTEPAD_CONFIG,
} from './types.js';

/**
 * Format a notepad entry as markdown
 */
function formatEntry(
  timestamp: string,
  taskId: string,
  content: string,
  extra: Record<string, unknown> = {}
): string {
  const lines: string[] = [
    `## ${timestamp} | Task: ${taskId}`,
    '',
    content,
    '',
  ];

  // Add extra fields
  for (const [key, value] of Object.entries(extra)) {
    if (value !== undefined && value !== null) {
      if (Array.isArray(value)) {
        lines.push(`**${key}:** ${value.join(', ')}`);
      } else {
        lines.push(`**${key}:** ${value}`);
      }
    }
  }

  lines.push('', '---', '');
  return lines.join('\n');
}

/**
 * Add a learning entry to the plan's notepad
 *
 * @param planId - Plan identifier (e.g., "03-01")
 * @param entry - Learning entry data (taskId, content required)
 * @param config - Optional config override
 * @returns true if written successfully
 */
export function addLearning(
  planId: string,
  entry: Omit<LearningEntry, 'timestamp'>,
  config: Partial<NotepadConfig> = {}
): boolean {
  const manager = new NotepadManager({ ...DEFAULT_NOTEPAD_CONFIG, ...config });
  const filePath = manager.getNotepadPath(planId, 'learnings');

  // Ensure notepad exists
  if (!existsSync(filePath)) {
    manager.initPlanNotepad(planId);
  }

  const timestamp = new Date().toISOString();
  const markdown = formatEntry(timestamp, entry.taskId, entry.content, {
    'Pattern found': entry.pattern,
    Tags: entry.tags,
  });

  try {
    appendFileSync(filePath, markdown, 'utf-8');
    return true;
  } catch {
    return false;
  }
}

/**
 * Add a decision entry to the plan's notepad
 */
export function addDecision(
  planId: string,
  entry: Omit<DecisionEntry, 'timestamp'>,
  config: Partial<NotepadConfig> = {}
): boolean {
  const manager = new NotepadManager({ ...DEFAULT_NOTEPAD_CONFIG, ...config });
  const filePath = manager.getNotepadPath(planId, 'decisions');

  if (!existsSync(filePath)) {
    manager.initPlanNotepad(planId);
  }

  const timestamp = new Date().toISOString();
  const markdown = formatEntry(timestamp, entry.taskId, entry.content, {
    Rationale: entry.rationale,
    Alternatives: entry.alternatives,
    Tags: entry.tags,
  });

  try {
    appendFileSync(filePath, markdown, 'utf-8');
    return true;
  } catch {
    return false;
  }
}

/**
 * Add an issue entry to the plan's notepad
 */
export function addIssue(
  planId: string,
  entry: Omit<IssueEntry, 'timestamp'>,
  config: Partial<NotepadConfig> = {}
): boolean {
  const manager = new NotepadManager({ ...DEFAULT_NOTEPAD_CONFIG, ...config });
  const filePath = manager.getNotepadPath(planId, 'issues');

  if (!existsSync(filePath)) {
    manager.initPlanNotepad(planId);
  }

  const timestamp = new Date().toISOString();
  const markdown = formatEntry(timestamp, entry.taskId, entry.content, {
    Severity: entry.severity,
    Status: entry.status,
    Workaround: entry.workaround,
    Tags: entry.tags,
  });

  try {
    appendFileSync(filePath, markdown, 'utf-8');
    return true;
  } catch {
    return false;
  }
}
```

Then create the index file:

```typescript
// src/notepad/index.ts

export * from './types.js';
export { NotepadManager } from './manager.js';
export { addLearning, addDecision, addIssue } from './api.js';
```
  </action>
  <verify>npx tsc --noEmit src/notepad/index.ts && npm run build</verify>
  <done>api.ts exports addLearning, addDecision, addIssue; index.ts re-exports all; npm run build passes</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - All notepad module files compile
2. `npm run build` - Project builds successfully with new module
3. Manual test: Import and call `addLearning('test-plan', { taskId: 'T1', content: 'Test learning' })` - file created in `.planning/notepads/test-plan/learnings.md`
</verification>

<success_criteria>
- [ ] src/notepad/types.ts exports NotepadEntry, NotepadCategory, WisdomSummary
- [ ] src/notepad/manager.ts exports NotepadManager with initPlanNotepad
- [ ] src/notepad/api.ts exports addLearning, addDecision, addIssue
- [ ] src/notepad/index.ts re-exports all public API
- [ ] npm run build passes
- [ ] Calling addLearning creates/appends to .planning/notepads/{planId}/learnings.md
</success_criteria>

<output>
After completion, create `.planning/phases/12-notepad-learning/12-01-SUMMARY.md`
</output>

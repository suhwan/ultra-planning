---
phase: 12-notepad-learning
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - src/notepad/reader.ts
  - src/notepad/injector.ts
  - src/notepad/index.ts
autonomous: true

must_haves:
  truths:
    - "getWisdomForPlan reads all three category files and returns WisdomSummary"
    - "extractRecentEntries extracts last N entries from markdown content"
    - "formatWisdomForPrompt creates injectable wisdom block with token budget"
    - "Wisdom is prioritized: issues > decisions > learnings"
  artifacts:
    - path: "src/notepad/reader.ts"
      provides: "Notepad reading and parsing functions"
      exports: ["getWisdomForPlan", "extractRecentEntries", "readNotepadFile"]
      min_lines: 60
    - path: "src/notepad/injector.ts"
      provides: "Wisdom formatting for prompt injection"
      exports: ["formatWisdomForPrompt", "createWisdomDirective"]
      min_lines: 50
  key_links:
    - from: "src/notepad/reader.ts"
      to: "src/notepad/types.ts"
      via: "imports WisdomSummary type"
      pattern: "import.*WisdomSummary.*from"
    - from: "src/notepad/injector.ts"
      to: "src/notepad/reader.ts"
      via: "uses getWisdomForPlan result"
      pattern: "WisdomSummary"
    - from: "src/notepad/reader.ts"
      to: ".planning/notepads/{planId}/*.md"
      via: "readFileSync"
      pattern: "readFileSync"
---

<objective>
Implement notepad reading and wisdom injection for orchestrator delegation.

Purpose: Enable orchestrators to read accumulated wisdom before delegating tasks, and format it for subagent prompts. This is the core propagation mechanism.

Output: reader.ts (getWisdomForPlan, extractRecentEntries), injector.ts (formatWisdomForPrompt, createWisdomDirective)
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-notepad-learning/12-RESEARCH.md
@src/notepad/types.ts
@src/notepad/manager.ts
</context>

<research_findings>
From 12-RESEARCH.md:
- Read notepad IMMEDIATELY before each delegation (avoid stale wisdom)
- Extract last N entries (default 5) per category
- Token budget: ~1000 tokens max for wisdom injection
- Priority order: issues > decisions > learnings (most actionable first)
- Format as `<wisdom>` block in prompt
- Rough token estimate: text.length / 4
</research_findings>

<tasks>

<task type="auto">
  <name>Task 1: Create notepad reader</name>
  <files>src/notepad/reader.ts</files>
  <action>
Create reader functions for extracting wisdom from notepad files:

```typescript
// src/notepad/reader.ts

import { readFileSync, existsSync } from 'fs';
import { NotepadManager } from './manager.js';
import {
  WisdomSummary,
  NotepadCategory,
  NotepadConfig,
  DEFAULT_NOTEPAD_CONFIG,
} from './types.js';

/** Chars per token estimate (from Phase 10 decision) */
const CHARS_PER_TOKEN = 4;

/**
 * Read raw content from a notepad file
 *
 * @param planId - Plan identifier
 * @param category - Notepad category
 * @param config - Optional config override
 * @returns File content or null if not found
 */
export function readNotepadFile(
  planId: string,
  category: NotepadCategory,
  config: Partial<NotepadConfig> = {}
): string | null {
  const manager = new NotepadManager({ ...DEFAULT_NOTEPAD_CONFIG, ...config });
  const filePath = manager.getNotepadPath(planId, category);

  if (!existsSync(filePath)) {
    return null;
  }

  try {
    return readFileSync(filePath, 'utf-8');
  } catch {
    return null;
  }
}

/**
 * Extract recent entries from markdown content
 * Entries are delimited by `## YYYY-MM-DD` timestamp headers
 *
 * @param content - Raw markdown content
 * @param limit - Maximum entries to extract
 * @returns Array of entry content strings
 */
export function extractRecentEntries(content: string, limit: number = 5): string[] {
  if (!content || content.trim() === '') {
    return [];
  }

  // Split by ## timestamp headers (ISO format: YYYY-MM-DDTHH:MM:SS)
  // Pattern matches: ## 2026-01-27T14:30:00Z | Task: ...
  const sections = content.split(/\n(?=## \d{4}-\d{2}-\d{2}T)/);

  // Filter out header-only sections and take last N
  const entries = sections
    .filter(s => s.trim() && s.includes('|'))  // Must have task marker
    .slice(-limit);

  return entries;
}

/**
 * Get wisdom summary for a plan
 * Reads all three category files and extracts recent entries
 *
 * @param planId - Plan identifier
 * @param config - Optional config override
 * @returns WisdomSummary or null if notepad doesn't exist
 */
export function getWisdomForPlan(
  planId: string,
  config: Partial<NotepadConfig> = {}
): WisdomSummary | null {
  const fullConfig = { ...DEFAULT_NOTEPAD_CONFIG, ...config };
  const manager = new NotepadManager(fullConfig);

  if (!manager.notepadExists(planId)) {
    return null;
  }

  const result: WisdomSummary = {
    learnings: [],
    decisions: [],
    issues: [],
    tokenEstimate: 0,
  };

  // Read each category
  const categories: NotepadCategory[] = ['learnings', 'decisions', 'issues'];
  for (const category of categories) {
    const content = readNotepadFile(planId, category, fullConfig);
    if (content) {
      const entries = extractRecentEntries(content, fullConfig.maxEntriesPerCategory);
      result[category] = entries;
      result.tokenEstimate += Math.ceil(content.length / CHARS_PER_TOKEN);
    }
  }

  return result;
}

/**
 * Get wisdom from project-level notepad
 * Used for cross-plan knowledge
 *
 * @param config - Optional config override
 * @returns WisdomSummary or null if doesn't exist
 */
export function getProjectWisdom(
  config: Partial<NotepadConfig> = {}
): WisdomSummary | null {
  // Project notepad uses special "_project" planId
  return getWisdomForPlan('_project', config);
}
```

Key implementation notes:
- Use CHARS_PER_TOKEN = 4 (Phase 10 decision)
- Split by ISO timestamp headers
- Return null if notepad doesn't exist (orchestrator can handle)
  </action>
  <verify>npx tsc --noEmit src/notepad/reader.ts</verify>
  <done>reader.ts compiles, exports getWisdomForPlan, extractRecentEntries, readNotepadFile</done>
</task>

<task type="auto">
  <name>Task 2: Create wisdom injector</name>
  <files>src/notepad/injector.ts</files>
  <action>
Create injector functions for formatting wisdom into prompts:

```typescript
// src/notepad/injector.ts

import { WisdomSummary, NotepadConfig, DEFAULT_NOTEPAD_CONFIG } from './types.js';
import { getWisdomForPlan, getProjectWisdom } from './reader.js';

/** Chars per token estimate */
const CHARS_PER_TOKEN = 4;

/**
 * Format wisdom summary as injectable prompt block
 * Prioritizes: issues > decisions > learnings (most actionable first)
 *
 * @param wisdom - Wisdom summary to format
 * @param maxTokens - Maximum tokens for output (default from config)
 * @returns Formatted markdown string or empty if no wisdom
 */
export function formatWisdomForPrompt(
  wisdom: WisdomSummary | null,
  maxTokens: number = DEFAULT_NOTEPAD_CONFIG.maxTokenBudget
): string {
  if (!wisdom || wisdom.tokenEstimate === 0) {
    return '';
  }

  const sections: string[] = [];
  const maxChars = maxTokens * CHARS_PER_TOKEN;

  // Priority order: issues first (blockers), then decisions, then learnings
  if (wisdom.issues.length > 0) {
    const issueText = wisdom.issues.slice(0, 3).join('\n\n');
    sections.push(`### Known Issues & Blockers\n${issueText}`);
  }

  if (wisdom.decisions.length > 0) {
    const decisionText = wisdom.decisions.slice(0, 3).join('\n\n');
    sections.push(`### Decisions Made\n${decisionText}`);
  }

  if (wisdom.learnings.length > 0) {
    const learningText = wisdom.learnings.slice(0, 3).join('\n\n');
    sections.push(`### Learnings & Patterns\n${learningText}`);
  }

  let formatted = sections.join('\n\n');

  // Truncate if over budget
  if (formatted.length > maxChars) {
    formatted = formatted.slice(0, maxChars - 20) + '\n\n[...truncated]';
  }

  return formatted;
}

/**
 * Create the full wisdom directive for subagent prompts
 * Combines plan-level and project-level wisdom with notepad write instructions
 *
 * @param planId - Current plan identifier
 * @param config - Optional config override
 * @returns Full directive string to inject into prompt
 */
export function createWisdomDirective(
  planId: string,
  config: Partial<NotepadConfig> = {}
): string {
  const fullConfig = { ...DEFAULT_NOTEPAD_CONFIG, ...config };
  const halfBudget = Math.floor(fullConfig.maxTokenBudget / 2);

  // Get both plan-level and project-level wisdom
  const planWisdom = getWisdomForPlan(planId, fullConfig);
  const projectWisdom = getProjectWisdom(fullConfig);

  const planSection = formatWisdomForPrompt(planWisdom, halfBudget);
  const projectSection = formatWisdomForPrompt(projectWisdom, halfBudget);

  // Build directive
  const parts: string[] = ['<wisdom>'];

  if (projectSection) {
    parts.push('## Project-Level Knowledge');
    parts.push(projectSection);
    parts.push('');
  }

  if (planSection) {
    parts.push('## Current Plan Knowledge');
    parts.push(planSection);
    parts.push('');
  }

  // Add notepad write instructions
  parts.push('## Notepad Location (for recording learnings)');
  parts.push(`NOTEPAD PATH: ${fullConfig.baseDir}/notepads/${planId}/`);
  parts.push('- learnings.md: Record patterns, conventions, successful approaches');
  parts.push('- issues.md: Record problems, blockers, gotchas encountered');
  parts.push('- decisions.md: Record architectural choices and rationales');
  parts.push('');
  parts.push('You SHOULD append findings to notepad files after completing work.');
  parts.push('IMPORTANT: Always APPEND to notepad files - never overwrite or use Edit tool.');

  parts.push('</wisdom>');

  return parts.join('\n');
}

/**
 * Quick check if there's any wisdom to inject
 * Use this to skip injection overhead when notepad is empty
 *
 * @param planId - Plan identifier
 * @param config - Optional config override
 * @returns true if wisdom exists
 */
export function hasWisdom(
  planId: string,
  config: Partial<NotepadConfig> = {}
): boolean {
  const planWisdom = getWisdomForPlan(planId, config);
  const projectWisdom = getProjectWisdom(config);

  return (
    (planWisdom !== null && planWisdom.tokenEstimate > 0) ||
    (projectWisdom !== null && projectWisdom.tokenEstimate > 0)
  );
}
```

Key implementation notes:
- Prioritize issues > decisions > learnings (from research)
- Split token budget between plan and project wisdom
- Include notepad write instructions per oh-my-opencode pattern
- Explicit "APPEND only" warning (Pitfall 1 from research)
  </action>
  <verify>npx tsc --noEmit src/notepad/injector.ts</verify>
  <done>injector.ts compiles, exports formatWisdomForPrompt, createWisdomDirective, hasWisdom</done>
</task>

<task type="auto">
  <name>Task 3: Update index exports</name>
  <files>src/notepad/index.ts</files>
  <action>
Update index.ts to export reader and injector functions:

```typescript
// src/notepad/index.ts

// Types
export * from './types.js';

// Manager
export { NotepadManager } from './manager.js';

// Write API
export { addLearning, addDecision, addIssue } from './api.js';

// Read API
export {
  getWisdomForPlan,
  getProjectWisdom,
  extractRecentEntries,
  readNotepadFile,
} from './reader.js';

// Injection
export {
  formatWisdomForPrompt,
  createWisdomDirective,
  hasWisdom,
} from './injector.js';
```

Then verify the full module compiles and builds:
1. Run `npx tsc --noEmit`
2. Run `npm run build`
  </action>
  <verify>npx tsc --noEmit && npm run build</verify>
  <done>index.ts exports all public API, npm run build passes</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - All notepad module files compile
2. `npm run build` - Project builds successfully
3. Manual test:
   - Create test notepad: `addLearning('test-plan', { taskId: 'T1', content: 'Test' })`
   - Read wisdom: `getWisdomForPlan('test-plan')` returns WisdomSummary with 1 learning
   - Format: `formatWisdomForPrompt(wisdom)` returns markdown with "### Learnings"
</verification>

<success_criteria>
- [ ] src/notepad/reader.ts exports getWisdomForPlan, extractRecentEntries
- [ ] src/notepad/injector.ts exports formatWisdomForPrompt, createWisdomDirective
- [ ] getWisdomForPlan returns WisdomSummary with tokenEstimate
- [ ] formatWisdomForPrompt respects maxTokens budget
- [ ] createWisdomDirective includes notepad write instructions
- [ ] npm run build passes
</success_criteria>

<output>
After completion, create `.planning/phases/12-notepad-learning/12-02-SUMMARY.md`
</output>

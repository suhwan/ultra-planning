---
phase: 12-notepad-learning
plan: 03
type: execute
wave: 3
depends_on: ["12-02"]
files_modified:
  - src/notepad/merger.ts
  - src/notepad/index.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "mergePlanToProject appends plan notepad content to _project/ files"
    - "Merge includes plan header to identify source"
    - "generateProjectSummary creates summary.md with key insights"
    - "Notepad module is exported from main src/index.ts"
  artifacts:
    - path: "src/notepad/merger.ts"
      provides: "Cross-plan merge and summary generation"
      exports: ["mergePlanToProject", "generateProjectSummary"]
      min_lines: 80
    - path: "src/index.ts"
      provides: "Main package exports"
      contains: "notepad"
  key_links:
    - from: "src/notepad/merger.ts"
      to: "src/notepad/reader.ts"
      via: "uses readNotepadFile"
      pattern: "import.*readNotepadFile"
    - from: "src/notepad/merger.ts"
      to: ".planning/notepads/_project/*.md"
      via: "appendFileSync"
      pattern: "appendFileSync"
    - from: "src/index.ts"
      to: "src/notepad/index.ts"
      via: "re-exports notepad module"
      pattern: "export.*notepad"
---

<objective>
Implement cross-plan merge and project-level summary generation.

Purpose: Enable long-term learning accumulation by merging plan-level notepads to project-level files, and generating summaries for efficient knowledge retrieval.

Output: merger.ts (mergePlanToProject, generateProjectSummary), updated exports
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-notepad-learning/12-RESEARCH.md
@src/notepad/types.ts
@src/notepad/reader.ts
@src/index.ts
</context>

<research_findings>
From 12-RESEARCH.md:
- Trigger merge in plan completion event handler
- Add plan header before appending: `\n\n# From: {planId}\n\n`
- _project/ has additional files: patterns.md, summary.md
- Summary should be auto-generated on merge (simple bullet points)
- Pitfall 4: "No merge on plan complete" - must trigger merge explicitly
</research_findings>

<tasks>

<task type="auto">
  <name>Task 1: Create merger module</name>
  <files>src/notepad/merger.ts</files>
  <action>
Create merger functions for cross-plan learning accumulation:

```typescript
// src/notepad/merger.ts

import { readFileSync, appendFileSync, writeFileSync, existsSync } from 'fs';
import { join } from 'path';
import { NotepadManager } from './manager.js';
import { readNotepadFile, extractRecentEntries } from './reader.js';
import {
  NotepadCategory,
  NotepadConfig,
  DEFAULT_NOTEPAD_CONFIG,
} from './types.js';

/**
 * Merge a plan's notepad content to project-level files
 * Called when a plan completes to accumulate learnings
 *
 * @param planId - Plan identifier to merge
 * @param config - Optional config override
 * @returns Object with merge results per category
 */
export function mergePlanToProject(
  planId: string,
  config: Partial<NotepadConfig> = {}
): Record<NotepadCategory, boolean> {
  const fullConfig = { ...DEFAULT_NOTEPAD_CONFIG, ...config };
  const manager = new NotepadManager(fullConfig);

  // Ensure project notepad exists
  manager.initProjectNotepad();

  const results: Record<NotepadCategory, boolean> = {
    learnings: false,
    decisions: false,
    issues: false,
  };

  const categories: NotepadCategory[] = ['learnings', 'decisions', 'issues'];

  for (const category of categories) {
    const content = readNotepadFile(planId, category, fullConfig);

    if (content && content.trim()) {
      const projectFile = join(
        manager.getProjectNotepadDir(),
        `${category}.md`
      );

      // Add plan header before content
      const header = `\n\n# From: ${planId}\n`;
      const timestamp = `*Merged: ${new Date().toISOString()}*\n\n`;

      try {
        appendFileSync(projectFile, header + timestamp + content, 'utf-8');
        results[category] = true;
      } catch {
        results[category] = false;
      }
    }
  }

  return results;
}

/**
 * Extract key patterns from project learnings
 * Identifies repeated code patterns across plans
 *
 * @param config - Optional config override
 * @returns Array of pattern strings
 */
function extractPatterns(config: Partial<NotepadConfig>): string[] {
  const fullConfig = { ...DEFAULT_NOTEPAD_CONFIG, ...config };
  const manager = new NotepadManager(fullConfig);
  const patternsFile = join(manager.getProjectNotepadDir(), 'patterns.md');

  // Read learnings and extract "Pattern found:" entries
  const learningsContent = readNotepadFile('_project', 'learnings', fullConfig);
  if (!learningsContent) {
    return [];
  }

  const patterns: string[] = [];
  const patternRegex = /\*\*Pattern found:\*\*\s*`([^`]+)`/g;
  let match;

  while ((match = patternRegex.exec(learningsContent)) !== null) {
    if (!patterns.includes(match[1])) {
      patterns.push(match[1]);
    }
  }

  return patterns;
}

/**
 * Generate project-level summary from accumulated wisdom
 * Creates summary.md with key insights organized by category
 *
 * @param config - Optional config override
 * @returns true if summary generated successfully
 */
export function generateProjectSummary(
  config: Partial<NotepadConfig> = {}
): boolean {
  const fullConfig = { ...DEFAULT_NOTEPAD_CONFIG, ...config };
  const manager = new NotepadManager(fullConfig);

  // Ensure project notepad exists
  manager.initProjectNotepad();

  const summaryFile = join(manager.getProjectNotepadDir(), 'summary.md');
  const patternsFile = join(manager.getProjectNotepadDir(), 'patterns.md');

  try {
    const lines: string[] = [
      '# Project Wisdom Summary',
      '',
      `*Last updated: ${new Date().toISOString()}*`,
      '',
    ];

    // Count entries per category
    const categories: NotepadCategory[] = ['learnings', 'decisions', 'issues'];
    const counts: Record<NotepadCategory, number> = {
      learnings: 0,
      decisions: 0,
      issues: 0,
    };

    for (const category of categories) {
      const content = readNotepadFile('_project', category, fullConfig);
      if (content) {
        const entries = extractRecentEntries(content, 100); // Get all for counting
        counts[category] = entries.length;
      }
    }

    lines.push('## Statistics');
    lines.push('');
    lines.push(`- **Learnings recorded:** ${counts.learnings}`);
    lines.push(`- **Decisions documented:** ${counts.decisions}`);
    lines.push(`- **Issues tracked:** ${counts.issues}`);
    lines.push('');

    // Extract and save patterns
    const patterns = extractPatterns(fullConfig);
    if (patterns.length > 0) {
      lines.push('## Key Patterns');
      lines.push('');
      for (const pattern of patterns.slice(0, 10)) {
        lines.push(`- \`${pattern}\``);
      }
      lines.push('');

      // Also save to patterns.md
      const patternsContent = [
        '# Discovered Patterns',
        '',
        `*Updated: ${new Date().toISOString()}*`,
        '',
        ...patterns.map(p => `- \`${p}\``),
      ].join('\n');
      writeFileSync(patternsFile, patternsContent, 'utf-8');
    }

    // Recent highlights (last 5 from each category)
    lines.push('## Recent Highlights');
    lines.push('');

    for (const category of categories) {
      const content = readNotepadFile('_project', category, fullConfig);
      if (content) {
        const entries = extractRecentEntries(content, 3);
        if (entries.length > 0) {
          lines.push(`### ${category.charAt(0).toUpperCase() + category.slice(1)}`);
          lines.push('');
          // Extract just the first line of each entry (the timestamp/task header)
          for (const entry of entries) {
            const firstLine = entry.split('\n').find(l => l.startsWith('## '));
            if (firstLine) {
              lines.push(`- ${firstLine.replace('## ', '')}`);
            }
          }
          lines.push('');
        }
      }
    }

    writeFileSync(summaryFile, lines.join('\n'), 'utf-8');
    return true;
  } catch {
    return false;
  }
}

/**
 * Merge all unmerged plan notepads to project
 * Scans notepads directory for plan folders and merges each
 *
 * @param config - Optional config override
 * @returns Array of merged plan IDs
 */
export function mergeAllPlansToProject(
  config: Partial<NotepadConfig> = {}
): string[] {
  const fullConfig = { ...DEFAULT_NOTEPAD_CONFIG, ...config };
  const manager = new NotepadManager(fullConfig);
  const notepadsDir = join(fullConfig.baseDir, 'notepads');

  if (!existsSync(notepadsDir)) {
    return [];
  }

  const { readdirSync } = require('fs');
  const merged: string[] = [];

  try {
    const entries = readdirSync(notepadsDir, { withFileTypes: true });

    for (const entry of entries) {
      // Skip _project and non-directories
      if (!entry.isDirectory() || entry.name === '_project') {
        continue;
      }

      const planId = entry.name;
      const results = mergePlanToProject(planId, fullConfig);

      // If any category merged, record it
      if (results.learnings || results.decisions || results.issues) {
        merged.push(planId);
      }
    }
  } catch {
    // Silently handle errors (e.g., permissions)
  }

  return merged;
}
```

Key implementation notes:
- Merge adds plan header: `# From: {planId}` with timestamp
- Summary includes statistics and recent highlights
- Patterns extracted from "Pattern found:" entries in learnings
- mergeAllPlansToProject for batch operations
  </action>
  <verify>npx tsc --noEmit src/notepad/merger.ts</verify>
  <done>merger.ts compiles, exports mergePlanToProject, generateProjectSummary, mergeAllPlansToProject</done>
</task>

<task type="auto">
  <name>Task 2: Update notepad module exports</name>
  <files>src/notepad/index.ts</files>
  <action>
Update index.ts to export merger functions:

```typescript
// src/notepad/index.ts

// Types
export * from './types.js';

// Manager
export { NotepadManager } from './manager.js';

// Write API
export { addLearning, addDecision, addIssue } from './api.js';

// Read API
export {
  getWisdomForPlan,
  getProjectWisdom,
  extractRecentEntries,
  readNotepadFile,
} from './reader.js';

// Injection
export {
  formatWisdomForPrompt,
  createWisdomDirective,
  hasWisdom,
} from './injector.js';

// Merge & Summary
export {
  mergePlanToProject,
  generateProjectSummary,
  mergeAllPlansToProject,
} from './merger.js';
```
  </action>
  <verify>npx tsc --noEmit src/notepad/index.ts</verify>
  <done>index.ts exports all notepad module functions</done>
</task>

<task type="auto">
  <name>Task 3: Export notepad module from main index</name>
  <files>src/index.ts</files>
  <action>
Update the main src/index.ts to export the notepad module. Read the current file first and add the notepad export.

Add to src/index.ts:

```typescript
// Notepad system
export * as notepad from './notepad/index.js';
```

This allows users to import like:
```typescript
import { notepad } from 'ultra-planning';
// or
import { addLearning, createWisdomDirective } from 'ultra-planning/notepad';
```

After updating, run full build to verify integration.
  </action>
  <verify>npm run build && npx tsc --noEmit</verify>
  <done>src/index.ts exports notepad module, npm run build passes</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - All files compile
2. `npm run build` - Project builds successfully
3. Manual integration test:
   ```typescript
   // Add learnings to plan
   addLearning('test-plan', { taskId: 'T1', content: 'Test', pattern: 'src/foo.ts:10-20' });

   // Merge to project
   mergePlanToProject('test-plan');

   // Generate summary
   generateProjectSummary();

   // Verify _project/learnings.md has "# From: test-plan"
   // Verify _project/summary.md exists with statistics
   ```
</verification>

<success_criteria>
- [ ] src/notepad/merger.ts exports mergePlanToProject, generateProjectSummary
- [ ] mergePlanToProject appends with "# From: {planId}" header
- [ ] generateProjectSummary creates summary.md with stats and highlights
- [ ] patterns.md updated with extracted patterns
- [ ] src/index.ts exports notepad module
- [ ] npm run build passes
- [ ] Phase 12 success criteria met:
  - [x] Subagent can write learnings (12-01)
  - [x] Orchestrator can inject wisdom (12-02)
  - [x] Learnings merge to project level (12-03)
  - [x] Summary queryable (12-03)
</success_criteria>

<output>
After completion, create `.planning/phases/12-notepad-learning/12-03-SUMMARY.md`
</output>

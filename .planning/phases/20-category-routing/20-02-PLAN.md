---
phase: 20-category-routing
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - src/orchestration/delegation/manager.ts
  - src/orchestration/delegation/manager.test.ts
  - src/hooks/tool/category-routing.ts
  - src/hooks/tool/index.ts
autonomous: true

must_haves:
  truths:
    - "enhancePromptWithCategory() appends category-specific guidance to prompts"
    - "Category routing hook intercepts Task tool calls and injects category hints"
    - "delegate_task can receive category parameter for routing"
  artifacts:
    - path: "src/orchestration/delegation/manager.ts"
      provides: "enhancePromptWithCategory function"
      exports: ["enhancePromptWithCategory", "CATEGORY_PROMPT_APPEND"]
    - path: "src/hooks/tool/category-routing.ts"
      provides: "Category routing hook for Task tool"
      exports: ["createCategoryRoutingHook"]
  key_links:
    - from: "src/hooks/tool/category-routing.ts"
      to: "src/orchestration/delegation/manager.ts"
      via: "import resolveCategory, enhancePromptWithCategory"
      pattern: "import.*from.*delegation/manager"
    - from: "src/hooks/tool/index.ts"
      to: "category-routing.ts"
      via: "re-export"
      pattern: "export.*from.*category-routing"
---

<objective>
Add category-specific prompt enhancement and integrate category routing into the Task tool via hooks.

Purpose: Enable automatic prompt enhancement based on category and seamless category-based routing in task delegation.
Output: Prompt enhancement function and category routing hook for Task tool.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/20-category-routing/20-RESEARCH.md

# Foundation from 20-01
@src/orchestration/delegation/types.ts
@src/orchestration/delegation/manager.ts

# Hook patterns to follow
@src/hooks/tool/delegate-task-retry.ts
@src/hooks/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add category-specific prompt enhancement</name>
  <files>
    src/orchestration/delegation/manager.ts
    src/orchestration/delegation/manager.test.ts
  </files>
  <action>
Add to `manager.ts`:

```typescript
/**
 * Category-specific prompt appendices.
 * Provides domain-specific guidance for each category.
 */
export const CATEGORY_PROMPT_APPEND: Record<DelegationCategory, string> = {
  quick: '',  // No additional guidance needed for simple lookups

  standard: `
Focus on:
- Clean, maintainable implementation
- Following existing codebase patterns
- Appropriate error handling`,

  complex: `
Approach systematically:
- Plan the refactoring steps
- Minimize changes to public APIs
- Consider backward compatibility
- Test after each major change`,

  ultrabrain: `
Approach systematically:
- Root cause analysis first
- Consider edge cases
- Document your reasoning
- Verify assumptions with evidence`,

  'visual-engineering': `
Focus on:
- Visual hierarchy and layout
- Accessibility (ARIA, keyboard navigation)
- Responsive design considerations
- Design system consistency
- User experience flow`,

  artistry: `
Explore creatively:
- Generate multiple alternatives
- Consider unconventional approaches
- Balance creativity with practicality
- Explain tradeoffs of each option`,

  writing: `
Focus on:
- Clarity and conciseness
- Accurate technical details
- Consistent terminology
- Appropriate examples
- Proper formatting`,

  'unspecified-low': '',  // Generic fallback, no specific guidance

  'unspecified-high': `
Approach thoroughly:
- Consider the full context
- Handle edge cases
- Provide complete solution`,
};

/**
 * Enhance a prompt with category-specific guidance.
 * Appends domain-specific instructions to improve task execution quality.
 *
 * @param prompt - Original task prompt
 * @param category - Delegation category
 * @returns Enhanced prompt with category guidance (if any)
 */
export function enhancePromptWithCategory(
  prompt: string,
  category: DelegationCategory
): string {
  const append = CATEGORY_PROMPT_APPEND[category];
  if (!append || append.trim() === '') {
    return prompt;
  }
  return `${prompt}\n\n## Category Guidance (${category})${append}`;
}
```

Add tests:

```typescript
describe('CATEGORY_PROMPT_APPEND', () => {
  it('should have entry for each category', () => {
    const categories = listCategories();
    for (const { category } of categories) {
      expect(CATEGORY_PROMPT_APPEND).toHaveProperty(category);
    }
  });
});

describe('enhancePromptWithCategory', () => {
  it('should append guidance for categories with content', () => {
    const enhanced = enhancePromptWithCategory('Do the task', 'ultrabrain');
    expect(enhanced).toContain('Do the task');
    expect(enhanced).toContain('Category Guidance');
    expect(enhanced).toContain('Root cause analysis');
  });

  it('should not modify prompt for categories without guidance', () => {
    const enhanced = enhancePromptWithCategory('Find file', 'quick');
    expect(enhanced).toBe('Find file');
  });

  it('should handle visual-engineering guidance', () => {
    const enhanced = enhancePromptWithCategory('Create button', 'visual-engineering');
    expect(enhanced).toContain('Accessibility');
    expect(enhanced).toContain('Responsive design');
  });

  it('should handle writing guidance', () => {
    const enhanced = enhancePromptWithCategory('Write docs', 'writing');
    expect(enhanced).toContain('Clarity');
    expect(enhanced).toContain('formatting');
  });
});
```
  </action>
  <verify>
    `npm test -- src/orchestration/delegation/manager.test.ts` passes
    `grep -q "enhancePromptWithCategory" src/orchestration/delegation/manager.ts`
  </verify>
  <done>
    - CATEGORY_PROMPT_APPEND constant has guidance for all 9 categories
    - enhancePromptWithCategory() appends guidance to prompts
    - Tests verify guidance is correctly applied
  </done>
</task>

<task type="auto">
  <name>Task 2: Create category routing hook for Task tool</name>
  <files>
    src/hooks/tool/category-routing.ts
    src/hooks/tool/index.ts
  </files>
  <action>
Create `src/hooks/tool/category-routing.ts`:

```typescript
/**
 * Category Routing Hook
 *
 * Intercepts Task tool calls to inject category-based routing hints.
 * This hook enhances task delegation with automatic category detection
 * and prompt enhancement based on task characteristics.
 *
 * Features:
 * - Auto-detects category from task prompt if not specified
 * - Injects category-specific guidance into prompts
 * - Provides model/temperature recommendations
 * - Logs category routing decisions
 *
 * @module hooks/tool/category-routing
 */

import type { HookContext, HookHandlers, ToolExecuteBeforeInput, ToolExecuteBeforeOutput } from '../types.js';
import {
  detectCategory,
  resolveCategory,
  getCategoryConfig,
  enhancePromptWithCategory,
  getCategoryThinkingBudgetTokens,
  type DelegationCategory,
  type ModelTier,
} from '../../orchestration/delegation/index.js';

// ============================================================================
// Types
// ============================================================================

interface TaskToolParams {
  prompt?: string;
  description?: string;
  category?: DelegationCategory;
  model?: ModelTier;
  [key: string]: unknown;
}

// ============================================================================
// Constants
// ============================================================================

const HOOK_NAME = 'category-routing';

// ============================================================================
// Factory Function
// ============================================================================

/**
 * Create a category routing hook.
 *
 * This hook monitors Task tool invocations and:
 * 1. Auto-detects category from prompt if not specified
 * 2. Enhances prompt with category-specific guidance
 * 3. Suggests model/temperature based on category
 *
 * @param ctx - Hook context with state manager and event emitter
 * @param options - Hook configuration options
 * @returns HookHandlers with tool.execute.before handler
 *
 * @example
 * const hook = createCategoryRoutingHook(ctx, { enhancePrompts: true });
 */
export function createCategoryRoutingHook(
  ctx: HookContext,
  options: {
    /** Whether to enhance prompts with category guidance (default: true) */
    enhancePrompts?: boolean;
    /** Whether to log routing decisions (default: true) */
    logRouting?: boolean;
  } = {}
): HookHandlers {
  const { enhancePrompts = true, logRouting = true } = options;

  /**
   * Handler for tool.execute.before events.
   * Intercepts Task tool calls to inject category routing.
   */
  async function toolExecuteBeforeHandler(
    input: ToolExecuteBeforeInput
  ): Promise<ToolExecuteBeforeOutput | void> {
    const { toolName, params, sessionId } = input;

    // Only process Task tool invocations
    if (toolName !== 'Task') {
      return;
    }

    const taskParams = params as TaskToolParams;
    const prompt = taskParams.prompt || taskParams.description || '';

    // Skip if no prompt to analyze
    if (!prompt) {
      return;
    }

    // Resolve category using priority: explicit > tier-based > auto-detect
    const category = resolveCategory({
      taskDescription: prompt,
      explicitCategory: taskParams.category,
      explicitTier: taskParams.model,
    });

    const config = getCategoryConfig(category);
    const thinkingTokens = getCategoryThinkingBudgetTokens(category);

    // Log routing decision
    if (logRouting) {
      ctx.emitEvent({
        type: 'category_routing',
        payload: {
          sessionId,
          category,
          model: config.model.tier,
          temperature: config.model.temperature,
          thinkingBudget: config.model.thinkingBudget,
          thinkingTokens,
          wasExplicit: !!taskParams.category,
        },
        source: `hook:${HOOK_NAME}`,
      });
    }

    // Prepare modifications
    const modifications: ToolExecuteBeforeOutput = {};

    // Enhance prompt if enabled and not already specified
    if (enhancePrompts && !taskParams.category) {
      const enhancedPrompt = enhancePromptWithCategory(prompt, category);
      if (enhancedPrompt !== prompt) {
        modifications.modifiedParams = {
          ...taskParams,
          prompt: enhancedPrompt,
        };
      }
    }

    // Inject category routing hint
    modifications.inject = `\n[Category Routing: ${category} -> model=${config.model.tier}, temp=${config.model.temperature}, thinking=${thinkingTokens} tokens]`;

    return modifications;
  }

  return {
    'tool.execute.before': toolExecuteBeforeHandler,
  };
}
```

Update `src/hooks/tool/index.ts` to add export:

```typescript
export * from './category-routing.js';
```
  </action>
  <verify>
    `npm run build` succeeds
    `grep -q "createCategoryRoutingHook" src/hooks/tool/index.ts`
    `grep -q "createCategoryRoutingHook" src/hooks/tool/category-routing.ts`
  </verify>
  <done>
    - createCategoryRoutingHook() intercepts Task tool calls
    - Hook auto-detects category and enhances prompts
    - Hook emits category_routing events for monitoring
    - Hook is exported from hooks/tool/index.ts
  </done>
</task>

<task type="auto">
  <name>Task 3: Add hook tests and verify integration</name>
  <files>
    src/hooks/tool/category-routing.test.ts
  </files>
  <action>
Create `src/hooks/tool/category-routing.test.ts`:

```typescript
/**
 * Category Routing Hook Tests
 */

import { describe, it, expect, vi, beforeEach } from 'vitest';
import { createCategoryRoutingHook } from './category-routing.js';
import type { HookContext, ToolExecuteBeforeInput } from '../types.js';

describe('Category Routing Hook', () => {
  let ctx: HookContext;
  let emitEventMock: ReturnType<typeof vi.fn>;

  beforeEach(() => {
    emitEventMock = vi.fn();
    ctx = {
      sessionId: 'test-session',
      stateManager: {} as any,
      emitEvent: emitEventMock,
      config: {
        enabledHooks: [],
        disabledHooks: [],
        hookOptions: {},
      },
    };
  });

  describe('createCategoryRoutingHook', () => {
    it('should return tool.execute.before handler', () => {
      const handlers = createCategoryRoutingHook(ctx);
      expect(handlers['tool.execute.before']).toBeDefined();
    });

    it('should ignore non-Task tools', async () => {
      const handlers = createCategoryRoutingHook(ctx);
      const handler = handlers['tool.execute.before']!;

      const result = await handler({
        toolName: 'Read',
        params: { file_path: '/test' },
        sessionId: 'session-1',
      });

      expect(result).toBeUndefined();
      expect(emitEventMock).not.toHaveBeenCalled();
    });

    it('should detect ultrabrain category for debugging prompts', async () => {
      const handlers = createCategoryRoutingHook(ctx);
      const handler = handlers['tool.execute.before']!;

      const result = await handler({
        toolName: 'Task',
        params: { prompt: 'Debug the race condition in auth' },
        sessionId: 'session-1',
      });

      expect(result?.inject).toContain('ultrabrain');
      expect(result?.inject).toContain('opus');
      expect(emitEventMock).toHaveBeenCalledWith(
        expect.objectContaining({
          type: 'category_routing',
          payload: expect.objectContaining({
            category: 'ultrabrain',
            model: 'opus',
          }),
        })
      );
    });

    it('should detect quick category for lookup prompts', async () => {
      const handlers = createCategoryRoutingHook(ctx);
      const handler = handlers['tool.execute.before']!;

      const result = await handler({
        toolName: 'Task',
        params: { prompt: 'Find the user model file' },
        sessionId: 'session-1',
      });

      expect(result?.inject).toContain('quick');
      expect(result?.inject).toContain('haiku');
    });

    it('should respect explicit category', async () => {
      const handlers = createCategoryRoutingHook(ctx);
      const handler = handlers['tool.execute.before']!;

      const result = await handler({
        toolName: 'Task',
        params: {
          prompt: 'Simple task',
          category: 'ultrabrain',
        },
        sessionId: 'session-1',
      });

      expect(result?.inject).toContain('ultrabrain');
      expect(emitEventMock).toHaveBeenCalledWith(
        expect.objectContaining({
          payload: expect.objectContaining({
            category: 'ultrabrain',
            wasExplicit: true,
          }),
        })
      );
    });

    it('should enhance prompts when not explicit', async () => {
      const handlers = createCategoryRoutingHook(ctx, { enhancePrompts: true });
      const handler = handlers['tool.execute.before']!;

      const result = await handler({
        toolName: 'Task',
        params: { prompt: 'Debug the issue' },
        sessionId: 'session-1',
      });

      // ultrabrain has prompt enhancement
      expect(result?.modifiedParams?.prompt).toContain('Category Guidance');
      expect(result?.modifiedParams?.prompt).toContain('Root cause analysis');
    });

    it('should not enhance prompts when disabled', async () => {
      const handlers = createCategoryRoutingHook(ctx, { enhancePrompts: false });
      const handler = handlers['tool.execute.before']!;

      const result = await handler({
        toolName: 'Task',
        params: { prompt: 'Debug the issue' },
        sessionId: 'session-1',
      });

      expect(result?.modifiedParams).toBeUndefined();
    });

    it('should include thinking tokens in routing hint', async () => {
      const handlers = createCategoryRoutingHook(ctx);
      const handler = handlers['tool.execute.before']!;

      const result = await handler({
        toolName: 'Task',
        params: { prompt: 'Debug complex issue' },
        sessionId: 'session-1',
      });

      expect(result?.inject).toContain('thinking=');
      expect(result?.inject).toContain('tokens');
    });

    it('should not log when logRouting is false', async () => {
      const handlers = createCategoryRoutingHook(ctx, { logRouting: false });
      const handler = handlers['tool.execute.before']!;

      await handler({
        toolName: 'Task',
        params: { prompt: 'Do something' },
        sessionId: 'session-1',
      });

      expect(emitEventMock).not.toHaveBeenCalled();
    });
  });
});
```
  </action>
  <verify>
    `npm test -- src/hooks/tool/category-routing.test.ts` passes
    `npm run build` succeeds
  </verify>
  <done>
    - Hook tests cover: non-Task tools, category detection, explicit category, prompt enhancement
    - All tests pass
    - Build succeeds with no type errors
  </done>
</task>

</tasks>

<verification>
```bash
# Build succeeds
npm run build

# All delegation tests pass
npm test -- src/orchestration/delegation/

# Hook tests pass
npm test -- src/hooks/tool/category-routing.test.ts

# Exports are correct
grep -q "enhancePromptWithCategory" src/orchestration/delegation/manager.ts
grep -q "createCategoryRoutingHook" src/hooks/tool/index.ts
```
</verification>

<success_criteria>
- enhancePromptWithCategory() correctly appends category-specific guidance
- CATEGORY_PROMPT_APPEND has meaningful guidance for relevant categories
- createCategoryRoutingHook() intercepts Task tool calls
- Hook auto-detects category and suggests model/temperature
- Hook optionally enhances prompts with category guidance
- Hook emits events for monitoring
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/20-category-routing/20-02-SUMMARY.md`
</output>

---
phase: 05-opencode-reimplementation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/loops/ralph/types.ts
  - src/loops/ralph/state.ts
  - src/loops/ralph/detection.ts
  - src/loops/ralph/index.ts
  - src/loops/index.ts
autonomous: true

must_haves:
  truths:
    - "Ralph Loop state persists across process restarts"
    - "Completion detected via <promise>TAG</promise> pattern"
    - "Loop continues until max iterations or completion"
    - "Continuation prompt includes iteration count and original task"
  artifacts:
    - path: "src/loops/ralph/types.ts"
      provides: "RalphLoopState, RalphLoopConfig interfaces"
      exports: ["RalphLoopState", "RalphLoopConfig", "DEFAULT_MAX_ITERATIONS", "DEFAULT_COMPLETION_PROMISE"]
    - path: "src/loops/ralph/state.ts"
      provides: "State persistence functions"
      exports: ["readRalphLoopState", "writeRalphLoopState", "clearRalphLoopState", "incrementIteration"]
    - path: "src/loops/ralph/detection.ts"
      provides: "Completion detection logic"
      exports: ["detectCompletion", "escapeRegex", "COMPLETION_TAG_PATTERN"]
    - path: "src/loops/ralph/index.ts"
      provides: "Module exports and continuation prompt builder"
      exports: ["buildContinuationPrompt", "isRalphLoopActive", "startRalphLoop", "endRalphLoop"]
  key_links:
    - from: "src/loops/ralph/state.ts"
      to: "src/state/state-manager.ts"
      via: "StateManager class"
      pattern: "new StateManager.*ralph"
    - from: "src/loops/ralph/index.ts"
      to: "src/state/mode-registry.ts"
      via: "startMode/endMode integration"
      pattern: "(startMode|endMode).*ralph"
---

<objective>
Implement Ralph Loop state persistence and continuation logic for persistent task execution.

Purpose: Enable the orchestrator to track multi-iteration task execution with completion detection, allowing tasks to continue until they're truly done (via `<promise>DONE</promise>` output) or max iterations reached.

Output: `src/loops/ralph/` module with state management, completion detection, and continuation prompt building.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-opencode-reimplementation/05-RESEARCH.md

# Existing state management (to integrate with)
@src/state/state-manager.ts
@src/state/mode-registry.ts
@src/state/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Ralph Loop types and constants</name>
  <files>src/loops/ralph/types.ts</files>
  <action>
Create Ralph Loop type definitions following the pattern from 05-RESEARCH.md:

1. **RalphLoopState interface**:
   - `active: boolean` - Whether loop is currently running
   - `iteration: number` - Current iteration (1-based)
   - `maxIterations: number` - Maximum iterations before forced stop
   - `completionPromise: string` - The tag to detect (e.g., "DONE")
   - `startedAt: string` - ISO 8601 timestamp
   - `prompt: string` - Original task prompt
   - Extend `Record<string, unknown>` for StateManager compatibility

2. **RalphLoopConfig interface**:
   - `maxIterations?: number` - Optional override (default 100)
   - `completionPromise?: string` - Optional custom promise tag (default "DONE")

3. **Constants**:
   - `DEFAULT_MAX_ITERATIONS = 100`
   - `DEFAULT_COMPLETION_PROMISE = 'DONE'`
   - `RALPH_LOOP_STATE_FILE = 'ralph-loop'` (for StateManager)

4. **Add JSDoc comments** explaining each field's purpose

Do NOT add session ID tracking - Claude Code sessions don't have stable IDs. Use state file existence as the signal.
  </action>
  <verify>
```bash
npm run build 2>&1 | grep -E "(error|warning)" || echo "Build clean"
```
Verify exports exist:
```bash
grep -E "export (interface|const)" src/loops/ralph/types.ts
```
  </verify>
  <done>
- RalphLoopState interface exported with all required fields
- RalphLoopConfig interface exported
- Constants exported: DEFAULT_MAX_ITERATIONS (100), DEFAULT_COMPLETION_PROMISE ('DONE')
- Build passes with no TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement state persistence and completion detection</name>
  <files>src/loops/ralph/state.ts, src/loops/ralph/detection.ts</files>
  <action>
**state.ts** - State persistence using existing StateManager:

1. **Imports**:
   - StateManager, StateLocation from '../state/index.js'
   - Types from './types.js'

2. **State Manager Instance**:
   ```typescript
   const manager = new StateManager<RalphLoopState>(
     RALPH_LOOP_STATE_FILE,
     StateLocation.LOCAL
   );
   ```

3. **Functions**:
   - `readRalphLoopState(): RalphLoopState | null` - Read state, return null if not exists
   - `writeRalphLoopState(state: RalphLoopState): boolean` - Write state, return success
   - `clearRalphLoopState(): boolean` - Delete state file, return success
   - `incrementIteration(state: RalphLoopState): RalphLoopState` - Return new state with iteration + 1

**detection.ts** - Completion detection:

1. **COMPLETION_TAG_PATTERN**:
   ```typescript
   export const COMPLETION_TAG_PATTERN = /<promise>(.*?)<\/promise>/is;
   ```

2. **escapeRegex(str: string): string**:
   - Escape regex special characters: `.*+?^${}()|[\]\\`

3. **detectCompletion(text: string, promise: string): boolean**:
   - Build pattern: `<promise>\s*${escapeRegex(promise)}\s*</promise>`
   - Use case-insensitive regex
   - Return true if pattern matches

IMPORTANT: Only check assistant output text, NOT user messages (to avoid detecting the completion tag in instructions).
  </action>
  <verify>
```bash
npm run build 2>&1 | grep -E "(error|warning)" || echo "Build clean"
```
Test detection logic manually:
```bash
node -e "
const { detectCompletion } = require('./dist/loops/ralph/detection.js');
console.log('Test 1:', detectCompletion('<promise>DONE</promise>', 'DONE') === true);
console.log('Test 2:', detectCompletion('<promise> DONE </promise>', 'DONE') === true);
console.log('Test 3:', detectCompletion('no completion here', 'DONE') === false);
console.log('Test 4:', detectCompletion('<Promise>done</Promise>', 'DONE') === true);
"
```
  </verify>
  <done>
- readRalphLoopState returns null when file doesn't exist
- writeRalphLoopState persists to .ultraplan/state/ralph-loop.json
- clearRalphLoopState removes the state file
- detectCompletion correctly identifies promise tags (case-insensitive, whitespace-tolerant)
- Build passes with no TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Ralph Loop module with continuation prompt</name>
  <files>src/loops/ralph/index.ts, src/loops/index.ts</files>
  <action>
**index.ts** - Main Ralph Loop module:

1. **Re-exports**: Export all from types.ts, state.ts, detection.ts

2. **CONTINUATION_PROMPT template**:
   ```typescript
   const CONTINUATION_PROMPT = `[SYSTEM DIRECTIVE: ULTRA-PLANNING - RALPH LOOP {{ITERATION}}/{{MAX}}]

Your previous attempt did not output the completion promise. Continue working on the task.

IMPORTANT:
- Review your progress so far
- Continue from where you left off
- When FULLY complete, output: <promise>{{PROMISE}}</promise>
- Do not stop until the task is truly done

Original task:
{{PROMPT}}`;
   ```

3. **buildContinuationPrompt(state: RalphLoopState): string**:
   - Replace `{{ITERATION}}` with state.iteration
   - Replace `{{MAX}}` with state.maxIterations
   - Replace `{{PROMISE}}` with state.completionPromise
   - Replace `{{PROMPT}}` with state.prompt

4. **startRalphLoop(prompt: string, config?: RalphLoopConfig): RalphLoopState | null**:
   - Check canStartMode('executing') - return null if blocked
   - Create initial state with iteration=1, active=true
   - Write state file
   - Register with startMode('executing', { mode: 'ralph-loop' })
   - Return state

5. **endRalphLoop(): boolean**:
   - Clear state file
   - Call endMode('executing')
   - Return success

6. **isRalphLoopActive(): boolean**:
   - Read state, return state?.active === true

**src/loops/index.ts** - Module re-export:
   ```typescript
   export * from './ralph/index.js';
   ```

Update **src/index.ts** to export loops module.
  </action>
  <verify>
```bash
npm run build 2>&1 | grep -E "(error|warning)" || echo "Build clean"
```
Verify exports from main index:
```bash
node -e "
const api = require('./dist/index.js');
const fns = ['startRalphLoop', 'endRalphLoop', 'isRalphLoopActive', 'buildContinuationPrompt', 'detectCompletion'];
fns.forEach(fn => console.log(fn + ':', typeof api[fn]));
"
```
Verify continuation prompt building:
```bash
node -e "
const { buildContinuationPrompt } = require('./dist/loops/ralph/index.js');
const state = { iteration: 3, maxIterations: 100, completionPromise: 'DONE', prompt: 'Build a REST API' };
const prompt = buildContinuationPrompt(state);
console.log('Contains iteration:', prompt.includes('3/100'));
console.log('Contains promise:', prompt.includes('<promise>DONE</promise>'));
console.log('Contains task:', prompt.includes('Build a REST API'));
"
```
  </verify>
  <done>
- startRalphLoop creates state file and registers with mode registry
- endRalphLoop clears state and unregisters from mode registry
- isRalphLoopActive returns true when loop is running
- buildContinuationPrompt produces correct prompt with iteration/max/promise/task
- All functions exported from src/index.ts
- Build passes with no TypeScript errors
  </done>
</task>

</tasks>

<verification>
1. Build check: `npm run build` succeeds with exit code 0
2. Exports check: All Ralph Loop functions accessible from main index
3. State persistence: Writing and reading state works correctly
4. Completion detection: Promise tags detected with case-insensitivity and whitespace tolerance
5. Mode registry: Loop integrates with exclusive mode system
</verification>

<success_criteria>
- src/loops/ralph/ module created with types, state, detection, index files
- StateManager integration for file-based persistence
- Mode registry integration for exclusive mode tracking
- Completion detection via `<promise>TAG</promise>` pattern
- Continuation prompt builder with template substitution
- All functions exported from main src/index.ts
- npm run build passes with 0 errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-opencode-reimplementation/05-01-SUMMARY.md`
</output>

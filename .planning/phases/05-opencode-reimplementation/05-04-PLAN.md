---
phase: 05-opencode-reimplementation
plan: 04
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/recovery/types.ts
  - src/recovery/rollback.ts
  - src/recovery/index.ts
autonomous: true

must_haves:
  truths:
    - "Ralph Loop can recover from errors via cooldown timer"
    - "Error triggers checkpoint rollback of state files"
    - "Recovery clears Ralph Loop state to allow retry"
    - "Error events emitted to event system"
  artifacts:
    - path: "src/recovery/types.ts"
      provides: "Recovery type definitions"
      exports: ["RecoveryState", "RecoveryConfig", "RecoveryResult"]
    - path: "src/recovery/rollback.ts"
      provides: "Error recovery with git rollback integration"
      exports: ["handleError", "canRetry", "getRecoveryState", "setRecoveryState"]
    - path: "src/recovery/index.ts"
      provides: "Module exports"
      exports: ["DEFAULT_COOLDOWN_MS", "DEFAULT_MAX_RETRIES"]
  key_links:
    - from: "src/recovery/rollback.ts"
      to: "src/state/checkpoint.ts"
      via: "getLatestCheckpoint, rollbackToCheckpoint"
      pattern: "(getLatestCheckpoint|rollbackToCheckpoint)"
    - from: "src/recovery/rollback.ts"
      to: "src/loops/ralph/state.ts"
      via: "clearRalphLoopState"
      pattern: "clearRalphLoopState"
    - from: "src/recovery/rollback.ts"
      to: "src/state/event-system.ts"
      via: "emitEvent for recovery events"
      pattern: "emitEvent.*ralph_loop_failed"
---

<objective>
Implement error recovery with Git rollback integration for Ralph Loop.

Purpose: When errors occur during Ralph Loop execution, automatically roll back state files to the last checkpoint and allow the loop to retry. This provides resilience against transient failures and bad state.

Output: `src/recovery/` module with error handling, cooldown timer, and checkpoint rollback integration.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-opencode-reimplementation/05-RESEARCH.md

# Depends on 05-01 for Ralph Loop state
@src/loops/ralph/state.ts
@src/loops/ralph/types.ts

# Existing checkpoint system
@src/state/checkpoint.ts
@src/state/event-system.ts
@src/state/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create recovery types and constants</name>
  <files>src/recovery/types.ts</files>
  <action>
Create type definitions for error recovery:

1. **RecoveryState interface** (extends Record<string, unknown> for StateManager):
```typescript
export interface RecoveryState extends Record<string, unknown> {
  /** Whether recovery is currently in progress */
  isRecovering: boolean;
  /** ISO 8601 timestamp of last error */
  lastErrorAt: string | null;
  /** Number of consecutive errors */
  errorCount: number;
  /** Last error message */
  lastError: string | null;
  /** Cooldown end timestamp (ISO 8601) */
  cooldownUntil: string | null;
}
```

2. **RecoveryConfig interface**:
```typescript
export interface RecoveryConfig {
  /** Cooldown period in milliseconds (default: 5000) */
  cooldownMs?: number;
  /** Maximum retry attempts before giving up (default: 3) */
  maxRetries?: number;
  /** Whether to roll back state on error (default: true) */
  rollbackOnError?: boolean;
}
```

3. **RecoveryResult interface**:
```typescript
export interface RecoveryResult {
  /** Whether recovery action succeeded */
  success: boolean;
  /** Whether retry is allowed after cooldown */
  canRetry: boolean;
  /** When retry is allowed (ISO 8601, null if immediate) */
  retryAfter: string | null;
  /** What action was taken */
  action: 'rolled_back' | 'cooldown_set' | 'max_retries_exceeded' | 'no_checkpoint';
  /** Error message if recovery failed */
  error?: string;
}
```

4. **Constants**:
```typescript
export const DEFAULT_COOLDOWN_MS = 5000; // 5 seconds
export const DEFAULT_MAX_RETRIES = 3;
export const RECOVERY_STATE_FILE = 'recovery';
```

Add JSDoc explaining the cooldown mechanism: prevents rapid retry loops that could cause cascading failures.
  </action>
  <verify>
```bash
npm run build 2>&1 | grep -E "(error|warning)" || echo "Build clean"
```
Verify exports:
```bash
grep -E "export (interface|const)" src/recovery/types.ts
```
  </verify>
  <done>
- RecoveryState interface exported with isRecovering, errorCount, cooldownUntil fields
- RecoveryConfig interface exported with cooldownMs, maxRetries options
- RecoveryResult interface exported with success, canRetry, action fields
- Constants exported: DEFAULT_COOLDOWN_MS (5000), DEFAULT_MAX_RETRIES (3)
- Build passes with no TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement recovery logic with checkpoint rollback</name>
  <files>src/recovery/rollback.ts</files>
  <action>
Implement error recovery with Git rollback integration:

1. **Imports**:
```typescript
import { StateManager, StateLocation, emitEvent } from '../state/index.js';
import { getLatestCheckpoint, rollbackToCheckpoint } from '../state/checkpoint.js';
import { clearRalphLoopState } from '../loops/ralph/state.js';
import {
  RecoveryState,
  RecoveryConfig,
  RecoveryResult,
  DEFAULT_COOLDOWN_MS,
  DEFAULT_MAX_RETRIES,
  RECOVERY_STATE_FILE,
} from './types.js';
```

2. **State Manager Instance**:
```typescript
const recoveryManager = new StateManager<RecoveryState>(
  RECOVERY_STATE_FILE,
  StateLocation.LOCAL
);
```

3. **getRecoveryState(): RecoveryState**:
   - Read state from file
   - Return default state if not exists: { isRecovering: false, lastErrorAt: null, errorCount: 0, lastError: null, cooldownUntil: null }

4. **setRecoveryState(state: Partial<RecoveryState>): boolean**:
   - Merge with existing state and write

5. **clearRecoveryState(): boolean**:
   - Delete recovery state file

6. **canRetry(config?: RecoveryConfig): boolean**:
   - Get current state
   - Check if errorCount < maxRetries
   - Check if cooldown has passed (Date.now() > Date.parse(cooldownUntil))
   - Return true if both conditions met

7. **handleError(error: Error, context: { phase: string; plan: number }, config?: RecoveryConfig): RecoveryResult**:

   a. Get current recovery state
   b. Increment errorCount
   c. Set lastError = error.message, lastErrorAt = now

   d. Check max retries:
   ```typescript
   if (state.errorCount >= (config?.maxRetries ?? DEFAULT_MAX_RETRIES)) {
     emitEvent({
       type: 'ralph_loop_failed',
       payload: { error: error.message, phase: context.phase, plan: context.plan, reason: 'max_retries' },
       source: 'recovery',
     });
     return { success: false, canRetry: false, retryAfter: null, action: 'max_retries_exceeded' };
   }
   ```

   e. Roll back state if configured:
   ```typescript
   if (config?.rollbackOnError !== false) {
     const checkpoint = getLatestCheckpoint();
     if (checkpoint) {
       const rollbackResult = rollbackToCheckpoint(checkpoint.id);
       if (!rollbackResult.success) {
         // Rollback failed, but we can still try recovery
       }
     } else {
       // No checkpoint, continue without rollback
       return { success: true, canRetry: true, retryAfter: cooldownEnd, action: 'no_checkpoint' };
     }
   }
   ```

   f. Clear Ralph Loop state to allow retry:
   ```typescript
   clearRalphLoopState();
   ```

   g. Set cooldown:
   ```typescript
   const cooldownMs = config?.cooldownMs ?? DEFAULT_COOLDOWN_MS;
   const cooldownEnd = new Date(Date.now() + cooldownMs).toISOString();
   setRecoveryState({ cooldownUntil: cooldownEnd, isRecovering: true });
   ```

   h. Emit event and return result:
   ```typescript
   emitEvent({
     type: 'rollback_initiated',
     payload: { error: error.message, phase: context.phase, plan: context.plan, retryAfter: cooldownEnd },
     source: 'recovery',
   });

   return { success: true, canRetry: true, retryAfter: cooldownEnd, action: 'rolled_back' };
   ```

IMPORTANT: Only roll back .ultraplan/state/ directory, NEVER source code. The existing CheckpointManager already enforces this.
  </action>
  <verify>
```bash
npm run build 2>&1 | grep -E "(error|warning)" || echo "Build clean"
```
Test recovery state management:
```bash
node -e "
const { getRecoveryState, setRecoveryState, canRetry, clearRecoveryState } = require('./dist/recovery/rollback.js');

// Clear any existing state
clearRecoveryState();

// Test default state
const initial = getRecoveryState();
console.log('Initial isRecovering:', initial.isRecovering === false);
console.log('Initial errorCount:', initial.errorCount === 0);

// Test state update
setRecoveryState({ errorCount: 1, lastError: 'test error' });
const updated = getRecoveryState();
console.log('Updated errorCount:', updated.errorCount === 1);

// Test canRetry (no cooldown)
console.log('Can retry (no cooldown):', canRetry() === true);

// Cleanup
clearRecoveryState();
"
```
  </verify>
  <done>
- getRecoveryState returns current state or default
- setRecoveryState persists partial updates
- canRetry checks errorCount and cooldown
- handleError performs rollback, clears Ralph Loop state, sets cooldown
- Events emitted for ralph_loop_failed and rollback_initiated
- Build passes with no TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Create recovery module exports</name>
  <files>src/recovery/index.ts, src/index.ts</files>
  <action>
**src/recovery/index.ts** - Module exports:

```typescript
/**
 * Error Recovery Module
 *
 * Provides error recovery with git rollback integration:
 * - Cooldown timer to prevent rapid retry loops
 * - Checkpoint rollback to restore state on error
 * - Ralph Loop state clearing for retry
 * - Event emission for tracking recovery actions
 *
 * Recovery flow:
 * 1. Error occurs during Ralph Loop
 * 2. handleError() called with error and context
 * 3. State rolled back to last checkpoint (if available)
 * 4. Ralph Loop state cleared
 * 5. Cooldown set before retry allowed
 * 6. canRetry() returns true after cooldown
 */

export * from './types.js';
export * from './rollback.js';
```

**src/index.ts** - Update main entry point:
- Add export for recovery module: `export * from './recovery/index.js';`
- Ensure recovery functions are accessible from main API

Create directory structure if needed:
```bash
mkdir -p src/recovery
```
  </action>
  <verify>
```bash
npm run build 2>&1 | grep -E "(error|warning)" || echo "Build clean"
```
Verify exports from main index:
```bash
node -e "
const api = require('./dist/index.js');
const fns = [
  'DEFAULT_COOLDOWN_MS',
  'DEFAULT_MAX_RETRIES',
  'RECOVERY_STATE_FILE',
  'getRecoveryState',
  'setRecoveryState',
  'clearRecoveryState',
  'canRetry',
  'handleError'
];
fns.forEach(fn => console.log(fn + ':', typeof api[fn]));
"
```
  </verify>
  <done>
- All recovery functions exported from src/recovery/index.ts
- All functions accessible from main src/index.ts
- Directory structure created: src/recovery/
- JSDoc explains recovery flow
- Build passes with no TypeScript errors
  </done>
</task>

</tasks>

<verification>
1. Build check: `npm run build` succeeds with exit code 0
2. Exports check: All recovery functions accessible from main index
3. State management: getRecoveryState, setRecoveryState, clearRecoveryState work correctly
4. Cooldown: canRetry respects cooldown period and max retries
5. Rollback integration: handleError calls getLatestCheckpoint and rollbackToCheckpoint
6. Ralph Loop integration: handleError calls clearRalphLoopState
7. Events: ralph_loop_failed and rollback_initiated events emitted
</verification>

<success_criteria>
- src/recovery/ module created with types, rollback, index files
- Recovery state persisted to .ultraplan/state/recovery.json
- handleError performs checkpoint rollback and clears Ralph Loop state
- Cooldown timer prevents rapid retries (5s default)
- Max retries limit enforced (3 default)
- Events emitted for tracking (ralph_loop_failed, rollback_initiated)
- All functions exported from main src/index.ts
- npm run build passes with 0 errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-opencode-reimplementation/05-04-SUMMARY.md`
</output>

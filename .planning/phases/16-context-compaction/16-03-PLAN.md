---
phase: 16-context-compaction
plan: 03
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - src/context/auto-compaction.ts
  - src/context/fresh-start.ts
  - src/context/index.ts
  - .claude/commands/ultraplan-fresh-start.md
autonomous: true

must_haves:
  truths:
    - "Auto-compaction triggers at 80% context usage"
    - "Fresh-start command can accept compacted context"
    - "Compacted context enables seamless continuation"
    - "Session can resume from snapshot without data loss"
  artifacts:
    - path: "src/context/auto-compaction.ts"
      provides: "AutoCompactionManager with trigger and snapshot"
      exports: ["AutoCompactionManager", "triggerAutoCompaction"]
    - path: "src/context/fresh-start.ts"
      provides: "Fresh start context injection"
      exports: ["prepareFreshStart", "injectCompactedContext"]
    - path: ".claude/commands/ultraplan-fresh-start.md"
      provides: "Slash command for fresh start with context"
  key_links:
    - from: "src/context/auto-compaction.ts"
      to: "src/context/compactor.ts"
      via: "import compactWithCoreInfo"
      pattern: "compactWithCoreInfo"
    - from: "src/context/fresh-start.ts"
      to: "src/context/compactor.ts"
      via: "import restoreContext"
      pattern: "restoreContext"
---

<objective>
Implement auto-compaction trigger and enhanced /fresh-start command.

Purpose: Enable automatic context compaction at 80% usage and seamless session continuation
Output: AutoCompactionManager for trigger logic, enhanced fresh-start with context injection
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@src/context/compactor.ts
@src/context/advanced-monitor.ts (from 16-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AutoCompactionManager</name>
  <files>src/context/auto-compaction.ts</files>
  <action>
Create src/context/auto-compaction.ts:

1. Import dependencies:
   - compactWithCoreInfo, saveContextSnapshot from compactor
   - collectContext from collector
   - emitEvent from state/event-system

2. Create AutoCompactionManager class:
```typescript
export class AutoCompactionManager {
  private triggered: boolean = false;
  private snapshotPath: string | null = null;

  constructor(
    private planningDir: string = '.planning',
    private snapshotDir: string = '.omc/snapshots'
  ) {}

  /**
   * Check if compaction should trigger (called by monitor)
   */
  shouldTrigger(usageRatio: number, threshold: number = 0.80): boolean {
    return !this.triggered && usageRatio >= threshold;
  }

  /**
   * Execute auto-compaction
   * Returns snapshot path for fresh-start
   */
  async trigger(currentPlanId?: string): Promise<string> {
    if (this.triggered) {
      throw new Error('Auto-compaction already triggered this session');
    }

    // 1. Collect current context
    const ctx = collectContext({ planId: currentPlanId, planningDir: this.planningDir });

    // 2. Compact with core info extraction
    const compacted = compactWithCoreInfo(ctx, { planningDir: this.planningDir });

    // 3. Save snapshot
    this.snapshotPath = saveContextSnapshot(compacted, { snapshotDir: this.snapshotDir });

    // 4. Emit event for orchestrator
    emitEvent({
      type: 'auto_compaction_complete',
      payload: {
        snapshotPath: this.snapshotPath,
        compressionRatio: compacted.compressionRatio,
        originalTokens: compacted.originalTokens,
        compactedTokens: compacted.compactedTokens,
      },
      source: 'auto-compaction-manager',
    });

    this.triggered = true;
    return this.snapshotPath;
  }

  /**
   * Get snapshot path for fresh-start command
   */
  getSnapshotPath(): string | null {
    return this.snapshotPath;
  }

  /**
   * Reset for new session
   */
  reset(): void {
    this.triggered = false;
    this.snapshotPath = null;
  }
}
```

3. Export factory function:
```typescript
export function createAutoCompactionManager(options?: {
  planningDir?: string;
  snapshotDir?: string;
}): AutoCompactionManager {
  return new AutoCompactionManager(options?.planningDir, options?.snapshotDir);
}
```
  </action>
  <verify>npm run build -- --filter=./src/context/auto-compaction.ts passes</verify>
  <done>AutoCompactionManager triggers compaction, saves snapshot, emits event</done>
</task>

<task type="auto">
  <name>Task 2: Implement fresh-start context injection</name>
  <files>src/context/fresh-start.ts, src/context/index.ts</files>
  <action>
Create src/context/fresh-start.ts:

1. Import from compactor: restoreContext, formatCompactedContext, CompactedContext

2. Implement prepareFreshStart:
```typescript
export interface FreshStartContext {
  /** Formatted context for prompt injection */
  prompt: string;
  /** Raw compacted context */
  compacted: CompactedContext;
  /** Resume instructions */
  instructions: string;
}

/**
 * Prepare context for fresh-start continuation
 */
export function prepareFreshStart(
  snapshotId: string = 'latest',
  options?: { snapshotDir?: string }
): FreshStartContext | null {
  const compacted = restoreContext(snapshotId, options);
  if (!compacted) return null;

  const prompt = formatCompactedContext(compacted);
  const instructions = generateResumeInstructions(compacted);

  return { prompt, compacted, instructions };
}
```

3. Implement generateResumeInstructions:
```typescript
function generateResumeInstructions(compacted: CompactedContext): string {
  const lines = [
    '## Resume Instructions',
    '',
    `Continue from Phase ${compacted.phaseState.phaseNumber} - ${compacted.phaseState.phaseName}`,
  ];

  if (compacted.activeTask) {
    lines.push(`Current task: ${compacted.activeTask.planId} (${compacted.activeTask.status})`);
  }

  if (compacted.issues.length > 0) {
    lines.push('');
    lines.push('**Unresolved issues to address:**');
    compacted.issues.forEach(i => lines.push(`- ${i}`));
  }

  lines.push('');
  lines.push('**Next action:** Read the current PLAN.md and continue execution.');

  return lines.join('\n');
}
```

4. Implement injectCompactedContext for orchestrator use:
```typescript
/**
 * Generate complete prompt prefix with compacted context
 */
export function injectCompactedContext(
  snapshotId: string = 'latest',
  options?: { snapshotDir?: string }
): string {
  const freshStart = prepareFreshStart(snapshotId, options);
  if (!freshStart) {
    return '# No context snapshot available\n\nStarting fresh session.';
  }

  return [
    freshStart.prompt,
    '',
    freshStart.instructions,
  ].join('\n');
}
```

Update src/context/index.ts:
- Export AutoCompactionManager, createAutoCompactionManager
- Export prepareFreshStart, injectCompactedContext, FreshStartContext
  </action>
  <verify>npm run build passes, new exports available</verify>
  <done>prepareFreshStart and injectCompactedContext produce valid prompt context</done>
</task>

<task type="auto">
  <name>Task 3: Create /ultraplan:fresh-start command</name>
  <files>.claude/commands/ultraplan-fresh-start.md</files>
  <action>
Create .claude/commands/ultraplan-fresh-start.md:

```markdown
# /ultraplan:fresh-start

Resume work from a compacted context snapshot.

## Usage

```
/ultraplan:fresh-start [snapshot-id]
```

**Arguments:**
- `snapshot-id` (optional): Specific snapshot to restore. Default: "latest"

## Behavior

1. **Load Snapshot**: Reads compacted context from `.omc/snapshots/`
2. **Inject Context**: Formats preserved information for this session
3. **Show Resume Instructions**: Displays current phase, active task, unresolved issues

## What Gets Restored

- **Architecture Decisions**: Key decisions from previous sessions
- **Unresolved Issues**: Problems that still need attention
- **Current Progress**: Phase, plan, and task state
- **Recent Learnings**: Patterns discovered during execution

## Automatic Trigger

This command runs automatically when:
- Context usage reaches 80%
- AutoCompactionManager triggers compaction
- Orchestrator receives `auto_compaction_complete` event

## Manual Usage

Use when:
- Starting a new session to continue previous work
- Context window is getting full
- Need to reset conversation while preserving progress

## Example

```
/ultraplan:fresh-start 20260201-143022-a1b2
```

Restores specific snapshot and shows resume instructions.

## See Also

- `/ultraplan:execute` - Continue plan execution
- `.omc/snapshots/` - Snapshot storage location
```
  </action>
  <verify>File exists at .claude/commands/ultraplan-fresh-start.md with correct content</verify>
  <done>Command documentation complete with usage, behavior, and examples</done>
</task>

</tasks>

<verification>
- npm run build succeeds
- npm test -- src/context/ passes
- AutoCompactionManager triggers at 80%
- prepareFreshStart produces valid context
- Command file exists and is properly formatted
</verification>

<success_criteria>
1. Auto-compaction triggers automatically at 80% context usage
2. Snapshot saved with all core information preserved
3. /fresh-start command can restore from any snapshot
4. Compacted context enables seamless continuation without data loss
</success_criteria>

<output>
After completion, create `.planning/phases/16-context-compaction/16-03-SUMMARY.md`
</output>

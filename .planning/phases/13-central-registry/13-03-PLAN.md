---
phase: 13-central-registry
plan: 03
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - src/registry/agent-registry.ts
  - src/registry/agent-loader.ts
  - src/registry/index.ts
autonomous: true

must_haves:
  truths:
    - "AgentRegistry loads agent metadata from YAML files"
    - "Agent selection patterns filter which agents are available"
    - "Missing registry directory logs warning but doesn't crash"
    - "Local agent definitions override global with same ID"
    - "Singleton detects config mismatch and throws or provides reset function"
  artifacts:
    - path: "src/registry/agent-loader.ts"
      provides: "Multi-source agent loading logic"
      exports: ["loadAgentsFromSources", "getAgentSources", "matchesAgentPattern"]
    - path: "src/registry/agent-registry.ts"
      provides: "AgentRegistry class for agent metadata management"
      exports: ["AgentRegistry", "getAgentRegistry", "resetAgentRegistry"]
  key_links:
    - from: "src/registry/agent-registry.ts"
      to: "src/registry/agent-loader.ts"
      via: "import loadAgentsFromSources"
      pattern: "loadAgentsFromSources"
    - from: "src/registry/agent-loader.ts"
      to: "src/registry/paths.ts"
      via: "resolveRegistryPath"
      pattern: "getAgentsPath"
---

<objective>
Implement AgentRegistry for managing agent metadata from YAML definitions.

Purpose: Enable agents to be defined as YAML files in the registry, similar to skills. This allows cross-project sharing of custom agent configurations like ThinkTank personas.

Output: AgentRegistry class that loads agent YAML definitions from global and local registries.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-central-registry/13-RESEARCH.md
@src/registry/types.ts
@src/registry/paths.ts
@src/registry/skill-loader.ts
@src/skills/skill-registry.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create agent types and loader</name>
  <files>src/registry/agent-loader.ts</files>
  <action>
Create agent loader with multi-source support (mirrors skill-loader pattern):

```typescript
/**
 * Agent Loader - Multi-source agent loading with load order
 *
 * Loads agent definitions from global registry first (lower loadOrder),
 * then local project (higher loadOrder). Local agents override global.
 */

import { existsSync, readdirSync, readFileSync } from 'fs';
import { join } from 'path';
import matter from 'gray-matter';
import type { RegistrySource, RegistryConfig } from './types.js';
import { getDefaultRegistryPath, getAgentsPath, resolveRegistryPath } from './paths.js';

// Simple YAML parser using gray-matter's engine
function parseYaml(content: string): unknown {
  const result = matter(`---\n${content}\n---`);
  return result.data;
}

/**
 * Agent definition from YAML file
 *
 * Represents metadata about an agent, not the agent implementation.
 * Used for agent discovery, routing, and configuration.
 */
export interface AgentDefinition {
  /** Unique agent identifier (e.g., "thinktank/optimist") */
  id: string;
  /** Human-readable name */
  name: string;
  /** Version string */
  version: string;
  /** Description of agent's purpose */
  description: string;
  /** Agent category (e.g., "thinktank", "development", "analysis") */
  category?: string;
  /** Model routing preferences */
  model_routing?: {
    default: 'opus' | 'sonnet' | 'haiku';
    if_simple?: 'opus' | 'sonnet' | 'haiku';
    if_complex?: 'opus' | 'sonnet' | 'haiku';
  };
  /** Agent capabilities */
  capabilities?: string[];
  /** System prompt template */
  prompt_template?: string;
  /** Context requirements */
  context?: {
    /** Required skills */
    skills?: string[];
    /** Required agents (dependencies) */
    agents?: string[];
  };
  /** Persona traits (for ThinkTank-style agents) */
  persona?: {
    role: string;
    perspective: string;
    communication_style?: string;
  };
}

/**
 * Get agent source directories with load ordering
 *
 * Sources are ordered by loadOrder (ascending - lower numbers loaded first):
 * - Global registry (loadOrder 1): ~/registry/agents/ - loaded first, can be overridden
 * - Local project (loadOrder 2): .ultraplan/agents/ - loaded last, overrides global
 *
 * @param config - Registry configuration
 * @returns Array of registry sources, ordered by loadOrder (ascending)
 */
export function getAgentSources(config?: RegistryConfig): RegistrySource[] {
  const sources: RegistrySource[] = [];

  // Global registry - loaded first (loadOrder 1), can be overridden
  const globalRegistryPath = config?.registry
    ? resolveRegistryPath(config.registry)
    : getDefaultRegistryPath();

  const globalAgentsPath = getAgentsPath(globalRegistryPath);

  if (existsSync(globalRegistryPath)) {
    if (existsSync(globalAgentsPath)) {
      sources.push({
        path: globalAgentsPath,
        loadOrder: 1, // Loaded first, can be overridden
        isGlobal: true,
      });
    } else {
      // Registry exists but agents/ subdirectory doesn't
      console.warn(
        `Registry directory exists but agents/ subdirectory not found: ${globalAgentsPath}`
      );
    }
  }

  // Local project agents - loaded last (loadOrder 2), overrides global
  const localPath = join(process.cwd(), '.ultraplan/agents');
  if (existsSync(localPath)) {
    sources.push({
      path: localPath,
      loadOrder: 2, // Loaded last, overrides earlier
      isGlobal: false,
    });
  }

  // Sort by loadOrder ascending (lower number = loaded first)
  return sources.sort((a, b) => a.loadOrder - b.loadOrder);
}

/**
 * Check if an agent ID matches selection patterns
 *
 * @param agentId - Agent ID to check
 * @param patterns - Selection patterns
 * @returns Whether the agent matches
 */
export function matchesAgentPattern(
  agentId: string,
  patterns: string[] | undefined
): boolean {
  if (!patterns || patterns.length === 0) {
    return true;
  }

  return patterns.some((pattern) => {
    if (pattern === '*') return true;
    if (pattern.endsWith('/*')) {
      const prefix = pattern.slice(0, -2);
      return agentId.startsWith(prefix + '/') || agentId === prefix;
    }
    return agentId === pattern || agentId.endsWith('/' + pattern);
  });
}

/**
 * Load agent from YAML file
 */
function loadAgentFile(filePath: string): AgentDefinition | null {
  try {
    const content = readFileSync(filePath, 'utf-8');
    return parseYaml(content) as AgentDefinition;
  } catch (error) {
    console.warn(`Failed to load agent: ${filePath}`, error);
    return null;
  }
}

/**
 * Load agents from a single directory
 */
function loadAgentsFromDirectory(
  dirPath: string,
  selectionPatterns?: string[]
): Map<string, AgentDefinition> {
  const agents = new Map<string, AgentDefinition>();

  if (!existsSync(dirPath)) {
    return agents;
  }

  try {
    const entries = readdirSync(dirPath, { withFileTypes: true });
    let validYamlCount = 0;

    for (const entry of entries) {
      if (entry.isFile() && entry.name.endsWith('.yaml') && !entry.name.startsWith('_')) {
        // Direct YAML file in agents/
        const filePath = join(dirPath, entry.name);
        const agent = loadAgentFile(filePath);
        if (agent && matchesAgentPattern(agent.id, selectionPatterns)) {
          agents.set(agent.id, agent);
          validYamlCount++;
        }
      } else if (entry.isDirectory() && !entry.name.startsWith('_')) {
        // Subdirectory (e.g., agents/thinktank/)
        const subDir = join(dirPath, entry.name);
        const subFiles = readdirSync(subDir);

        for (const file of subFiles) {
          if (file.endsWith('.yaml') && !file.startsWith('_')) {
            const filePath = join(subDir, file);
            const agent = loadAgentFile(filePath);
            if (agent && matchesAgentPattern(agent.id, selectionPatterns)) {
              agents.set(agent.id, agent);
              validYamlCount++;
            }
          }
        }
      }
    }

    // Log warning if directory exists but has no valid YAML files
    if (validYamlCount === 0) {
      console.warn(
        `Agents directory exists but contains no valid YAML files: ${dirPath}`
      );
    }
  } catch (error) {
    console.warn(`Failed to read agents directory: ${dirPath}`, error);
  }

  return agents;
}

/**
 * Load agents from multiple sources with load order-based merging
 *
 * Agents are loaded from sources in loadOrder (ascending).
 * Later sources (higher loadOrder) override earlier sources.
 *
 * @param sources - Registry sources ordered by loadOrder
 * @param selectionPatterns - Patterns to filter agents
 * @returns Merged map of agent ID to agent definition
 */
export function loadAgentsFromSources(
  sources: RegistrySource[],
  selectionPatterns?: string[]
): Map<string, AgentDefinition> {
  const mergedAgents = new Map<string, AgentDefinition>();

  for (const source of sources) {
    const directoryAgents = loadAgentsFromDirectory(
      source.path,
      selectionPatterns
    );

    for (const [id, agent] of directoryAgents) {
      mergedAgents.set(id, agent);
    }
  }

  return mergedAgents;
}

/**
 * Load agent index from directory
 */
export function loadAgentIndex(dirPath: string): unknown | null {
  const indexPath = join(dirPath, '_index.yaml');

  if (!existsSync(indexPath)) {
    return null;
  }

  try {
    const content = readFileSync(indexPath, 'utf-8');
    return parseYaml(content);
  } catch (error) {
    console.warn(`Failed to load agent index: ${indexPath}`, error);
    return null;
  }
}
```
  </action>
  <verify>
Run `npx tsc --noEmit src/registry/agent-loader.ts` - should compile with no errors.
  </verify>
  <done>
Agent loader compiles and exports AgentDefinition, getAgentSources, matchesAgentPattern, loadAgentsFromSources, loadAgentIndex. Uses loadOrder (not priority). Logs warnings for partial directory structures.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AgentRegistry class with singleton safety</name>
  <files>src/registry/agent-registry.ts</files>
  <action>
Create AgentRegistry following the SkillRegistry pattern with singleton mismatch detection:

```typescript
/**
 * Agent Registry - Central registry for agent definitions
 *
 * Loads agent YAML definitions from global and local registries.
 * Similar pattern to SkillRegistry but for agent metadata.
 */

import * as path from 'path';
import type { RegistryConfig } from './types.js';
import {
  type AgentDefinition,
  getAgentSources,
  loadAgentsFromSources,
  loadAgentIndex,
} from './agent-loader.js';

/** Agent index structure */
interface AgentIndex {
  version: string;
  categories: Record<
    string,
    {
      name: string;
      description: string;
      agents: string[];
    }
  >;
  relationships?: Record<
    string,
    {
      works_with?: string[];
      requires?: string[];
    }
  >;
}

/**
 * Agent Registry Class
 */
export class AgentRegistry {
  private agents: Map<string, AgentDefinition> = new Map();
  private index: AgentIndex | null = null;
  private config: RegistryConfig | undefined;

  constructor(config?: RegistryConfig) {
    this.config = config;
    this.loadAgents();
  }

  /**
   * Load agents from registry sources
   */
  private loadAgents(): void {
    const sources = getAgentSources(this.config);

    if (sources.length === 0) {
      console.warn('No agent sources found');
      return;
    }

    // Load agents with selection patterns
    const patterns = this.config?.use?.agents;
    this.agents = loadAgentsFromSources(sources, patterns);

    // Load and merge indexes
    for (const source of sources) {
      const index = loadAgentIndex(source.path);
      if (index && !this.index) {
        this.index = index as AgentIndex;
      } else if (index && this.index) {
        this.mergeIndex(index as AgentIndex);
      }
    }

    console.log(`Loaded ${this.agents.size} agents from ${sources.length} source(s)`);
  }

  /**
   * Merge agent index from another source.
   *
   * NOTE: This is "last-wins" merging. If both global and local define
   * the same category key, local completely replaces global's category.
   * This is intentional - local overrides should fully replace global
   * definitions for the same key, not merge them additively.
   */
  private mergeIndex(newIndex: AgentIndex): void {
    if (!this.index) {
      this.index = newIndex;
      return;
    }

    if (newIndex.categories) {
      this.index.categories = {
        ...this.index.categories,
        ...newIndex.categories,
      };
    }

    if (newIndex.relationships) {
      this.index.relationships = {
        ...this.index.relationships,
        ...newIndex.relationships,
      };
    }
  }

  /**
   * Get agent by ID
   */
  getAgent(id: string): AgentDefinition | undefined {
    return this.agents.get(id);
  }

  /**
   * Get all agents
   */
  getAllAgents(): AgentDefinition[] {
    return Array.from(this.agents.values());
  }

  /**
   * Get agents by category
   */
  getAgentsByCategory(category: string): AgentDefinition[] {
    return Array.from(this.agents.values()).filter(
      (agent) => agent.category === category
    );
  }

  /**
   * Check if agent exists
   */
  hasAgent(id: string): boolean {
    return this.agents.has(id);
  }

  /**
   * Get agent IDs
   */
  getAgentIds(): string[] {
    return Array.from(this.agents.keys());
  }

  /**
   * Get agents from category in index
   */
  getIndexedAgentsByCategory(category: string): AgentDefinition[] {
    if (!this.index?.categories[category]) {
      return [];
    }
    return this.index.categories[category].agents
      .map((id) => this.agents.get(id))
      .filter((a): a is AgentDefinition => a !== undefined);
  }

  /**
   * Get agents that work with the given agent
   */
  getRelatedAgents(agentId: string): AgentDefinition[] {
    const relationships = this.index?.relationships?.[agentId];
    if (!relationships?.works_with) {
      return [];
    }
    return relationships.works_with
      .map((id) => this.agents.get(id))
      .filter((a): a is AgentDefinition => a !== undefined);
  }
}

// Singleton instance and config tracking
let registryInstance: AgentRegistry | null = null;
let registryInstanceConfig: RegistryConfig | undefined = undefined;

/**
 * Serialize config for comparison
 */
function serializeConfig(config: RegistryConfig | undefined): string {
  if (config === undefined) return 'undefined';
  return JSON.stringify(config);
}

/**
 * Get singleton AgentRegistry instance
 *
 * @param config - Registry configuration
 * @returns Singleton AgentRegistry instance
 * @throws Error if called with different config than existing instance
 */
export function getAgentRegistry(config?: RegistryConfig): AgentRegistry {
  if (!registryInstance) {
    registryInstance = new AgentRegistry(config);
    registryInstanceConfig = config;
    return registryInstance;
  }

  // Check for config mismatch
  const existingConfigStr = serializeConfig(registryInstanceConfig);
  const newConfigStr = serializeConfig(config);

  if (existingConfigStr !== newConfigStr) {
    throw new Error(
      `AgentRegistry singleton config mismatch. ` +
      `Existing config: ${existingConfigStr}, ` +
      `New config: ${newConfigStr}. ` +
      `Call resetAgentRegistry() first to reinitialize with new config.`
    );
  }

  return registryInstance;
}

/**
 * Reset singleton registry instance
 *
 * Call this to clear the cached instance before reinitializing with new config.
 * Useful for testing or when config needs to change at runtime.
 */
export function resetAgentRegistry(): void {
  registryInstance = null;
  registryInstanceConfig = undefined;
}

// Re-export AgentDefinition for convenience
export type { AgentDefinition };
```
  </action>
  <verify>
Run `npx tsc --noEmit src/registry/agent-registry.ts` - should compile with no errors.
  </verify>
  <done>
AgentRegistry class created with getAgent, getAllAgents, getAgentsByCategory, hasAgent, getAgentIds, getIndexedAgentsByCategory, getRelatedAgents methods. Singleton detects config mismatch and throws. resetAgentRegistry() provided. mergeIndex has JSDoc explaining last-wins behavior.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update registry index exports</name>
  <files>src/registry/index.ts</files>
  <action>
Add agent-loader and agent-registry exports to the registry module.

NOTE: This task modifies the same file as 13-02 Task 3. Since 13-02 and 13-03 are both in Wave 2, ensure this appends to the file AFTER skill-loader exports have been added.

Append to existing src/registry/index.ts (after skill-loader exports):

```typescript
// Agent loader
export {
  type AgentDefinition,
  getAgentSources,
  loadAgentsFromSources,
  matchesAgentPattern,
  loadAgentIndex,
} from './agent-loader.js';

// Agent registry
export {
  AgentRegistry,
  getAgentRegistry,
  resetAgentRegistry,
} from './agent-registry.js';
```
  </action>
  <verify>
Run `npx tsc --noEmit src/registry/index.ts` - should compile with no errors.
  </verify>
  <done>
Registry module exports all agent-loader and agent-registry functions and types.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes with no TypeScript errors
2. AgentRegistry can be initialized with RegistryConfig
3. Agents load from global registry first, local second
4. Selection patterns filter which agents are loaded
5. ThinkTank-style agents with persona field can be loaded
6. Singleton throws on config mismatch, resetAgentRegistry() allows re-initialization
7. mergeIndex JSDoc documents last-wins behavior
</verification>

<success_criteria>
- [ ] src/registry/agent-loader.ts created with AgentDefinition type using loadOrder
- [ ] src/registry/agent-registry.ts created with AgentRegistry class
- [ ] AgentRegistry supports multi-source loading
- [ ] Selection patterns work for agents (thinktank/*, etc.)
- [ ] Persona field supported for ThinkTank agents
- [ ] Singleton config mismatch throws Error with helpful message
- [ ] resetAgentRegistry() function exported and documented
- [ ] mergeIndex() has JSDoc explaining last-wins merge semantics
- [ ] Missing subdirectories log warnings
- [ ] `npm run build` passes
</success_criteria>

<output>
After completion, create `.planning/phases/13-central-registry/13-03-SUMMARY.md`
</output>

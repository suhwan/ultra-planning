---
phase: 13-central-registry
plan: 04
type: execute
wave: 3
depends_on: ["13-02", "13-03"]
files_modified:
  - .ultraplan/config.json
  - src/config/types.ts
  - src/config/loader.ts
  - src/skills/skill-injector.ts
autonomous: true

must_haves:
  truths:
    - "config.json accepts registry path and use.agents/use.skills patterns"
    - "SkillInjector uses RegistryConfig from config.json"
    - "ThinkTank skill injection works with global registry skills"
    - "Project can select subset of global skills via patterns"
  artifacts:
    - path: "src/config/types.ts"
      provides: "Extended ProjectConfig type with registry fields"
      exports: ["ProjectConfig", "RegistrySettings"]
    - path: "src/config/loader.ts"
      provides: "Config loading with registry settings"
      exports: ["loadProjectConfig", "getRegistryConfig"]
    - path: ".ultraplan/config.json"
      provides: "Example config with registry settings"
      contains: "registry"
  key_links:
    - from: "src/skills/skill-injector.ts"
      to: "src/config/loader.ts"
      via: "getRegistryConfig"
      pattern: "getRegistryConfig"
    - from: "src/config/loader.ts"
      to: "src/registry/types.ts"
      via: "RegistryConfig type"
      pattern: "RegistryConfig"
---

<objective>
Extend config.json schema and integrate registry configuration with skill injection.

Purpose: Allow projects to specify which agents/skills to use from the global registry via config.json, enabling project-specific customization of the available toolset.

Output: Extended config schema, config loader, and integrated skill injection.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-central-registry/13-RESEARCH.md
@.ultraplan/config.json
@src/registry/types.ts
@src/skills/skill-injector.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create config types with registry settings</name>
  <files>src/config/types.ts</files>
  <action>
Create config type definitions that extend the current config.json schema:

```typescript
/**
 * Project Configuration Types
 *
 * Extended configuration for Ultra Planner projects including
 * registry settings for cross-project skill/agent sharing.
 */

import type { RegistryConfig } from '../registry/types.js';

/**
 * Model routing profile configuration
 */
export interface ModelRoutingProfile {
  /** Profile description */
  description: string;
  /** Model routing by task type */
  routing: {
    research: 'opus' | 'sonnet' | 'haiku';
    planning: 'opus' | 'sonnet' | 'haiku';
    execution: 'opus' | 'sonnet' | 'haiku';
    verification: 'opus' | 'sonnet' | 'haiku';
    simple_tasks: 'opus' | 'sonnet' | 'haiku';
  };
  /** Agent tier selection */
  agents: {
    'build-fixer': string;
    'security-reviewer': string;
    'code-reviewer': string;
  };
}

/**
 * Execution settings
 */
export interface ExecutionSettings {
  /** Automatically fix build errors */
  autoFixBuildErrors: boolean;
  /** Run security review automatically */
  autoSecurityReview: boolean;
  /** Run code review automatically */
  autoCodeReview: boolean;
  /** Maximum build fix attempts */
  maxBuildFixAttempts: number;
  /** Enable TDD mode */
  enableTDD: boolean;
}

/**
 * Verification settings
 */
export interface VerificationSettings {
  /** Maximum ralplan iterations */
  ralplanMaxIterations: number;
  /** Architect leniency (0-1) */
  architectLeniency: number;
  /** Require security pass before completion */
  requireSecurityPass: boolean;
}

/**
 * Registry settings for cross-project sharing
 */
export interface RegistrySettings {
  /** Path to global registry (default: ~/registry) */
  registry?: string;
  /** Selection patterns for agents and skills */
  use?: {
    /** Glob patterns for agent selection */
    agents?: string[];
    /** Glob patterns for skill selection */
    skills?: string[];
  };
}

/**
 * Complete project configuration
 */
export interface ProjectConfig {
  /** Config version */
  version: string;
  /** Execution mode (interactive, batch, autopilot) */
  mode: 'interactive' | 'batch' | 'autopilot';
  /** Planning depth */
  depth: 'quick' | 'standard' | 'comprehensive';
  /** Enable parallelization */
  parallelization: boolean;
  /** Maximum parallel workers */
  max_workers: number;
  /** Commit planning docs */
  commit_docs: boolean;

  /** Active model profile name */
  modelProfile: string;
  /** Available model profiles */
  profiles: Record<string, ModelRoutingProfile>;

  /** Execution settings */
  execution: ExecutionSettings;

  /** Verification settings */
  verification: VerificationSettings;

  /** Registry settings (optional, new in v4) */
  registry?: RegistrySettings;
}

/**
 * Convert RegistrySettings to RegistryConfig for use with registries
 */
export function toRegistryConfig(settings?: RegistrySettings): RegistryConfig | undefined {
  if (!settings) {
    return undefined;
  }

  return {
    registry: settings.registry,
    use: settings.use,
  };
}

/**
 * Default registry settings
 */
export const DEFAULT_REGISTRY_SETTINGS: RegistrySettings = {
  registry: '~/registry',
  use: {
    agents: ['*'],
    skills: ['*'],
  },
};
```
  </action>
  <verify>
Run `npx tsc --noEmit src/config/types.ts` - should compile with no errors.
  </verify>
  <done>
Config types compile with ProjectConfig, RegistrySettings, and toRegistryConfig function.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create config loader with registry support</name>
  <files>src/config/loader.ts</files>
  <action>
Create config loader that reads config.json and provides registry config.

IMPORTANT: Use ESM imports at the top of the file (NOT CommonJS require()).

```typescript
/**
 * Config Loader - Load and parse project configuration
 *
 * Reads .ultraplan/config.json and provides typed access to settings.
 */

import { existsSync, readFileSync } from 'fs';
import { join } from 'path';
import { homedir } from 'os';
import type { RegistryConfig } from '../registry/types.js';
import {
  type ProjectConfig,
  type RegistrySettings,
  toRegistryConfig,
  DEFAULT_REGISTRY_SETTINGS,
} from './types.js';

/** Config file path relative to project root */
const CONFIG_FILE = '.ultraplan/config.json';

/** Cached config instance */
let cachedConfig: ProjectConfig | null = null;

/**
 * Load project configuration from .ultraplan/config.json
 *
 * @param projectRoot - Project root directory (default: cwd)
 * @returns Parsed project config or null if not found
 */
export function loadProjectConfig(projectRoot?: string): ProjectConfig | null {
  const root = projectRoot || process.cwd();
  const configPath = join(root, CONFIG_FILE);

  if (!existsSync(configPath)) {
    console.warn(`Config file not found: ${configPath}`);
    return null;
  }

  try {
    const content = readFileSync(configPath, 'utf-8');
    const config = JSON.parse(content) as ProjectConfig;
    cachedConfig = config;
    return config;
  } catch (error) {
    console.warn(`Failed to load config: ${configPath}`, error);
    return null;
  }
}

/**
 * Get cached config or load if not cached
 *
 * @param projectRoot - Project root directory
 * @returns Cached or loaded config
 */
export function getProjectConfig(projectRoot?: string): ProjectConfig | null {
  if (cachedConfig) {
    return cachedConfig;
  }
  return loadProjectConfig(projectRoot);
}

/**
 * Get registry configuration from project config
 *
 * Returns RegistryConfig suitable for SkillRegistry/AgentRegistry.
 * Falls back to defaults if no registry settings in config.
 *
 * @param projectRoot - Project root directory
 * @returns RegistryConfig or undefined
 */
export function getRegistryConfig(projectRoot?: string): RegistryConfig | undefined {
  const config = getProjectConfig(projectRoot);

  if (config?.registry) {
    return toRegistryConfig(config.registry);
  }

  // Check if global registry exists, use defaults if so
  const defaultGlobalPath = join(homedir(), 'registry');
  if (existsSync(defaultGlobalPath)) {
    return toRegistryConfig(DEFAULT_REGISTRY_SETTINGS);
  }

  return undefined;
}

/**
 * Get registry settings from config
 *
 * @param projectRoot - Project root directory
 * @returns Registry settings or defaults
 */
export function getRegistrySettings(projectRoot?: string): RegistrySettings {
  const config = getProjectConfig(projectRoot);
  return config?.registry || DEFAULT_REGISTRY_SETTINGS;
}

/**
 * Clear config cache (for testing)
 */
export function clearConfigCache(): void {
  cachedConfig = null;
}

/**
 * Check if project has registry configuration
 */
export function hasRegistryConfig(projectRoot?: string): boolean {
  const config = getProjectConfig(projectRoot);
  return !!config?.registry;
}
```
  </action>
  <verify>
Run `npx tsc --noEmit src/config/loader.ts` - should compile with no errors.
  </verify>
  <done>
Config loader compiles with loadProjectConfig, getProjectConfig, getRegistryConfig, getRegistrySettings functions. Uses ESM imports throughout (no require()).
  </done>
</task>

<task type="auto">
  <name>Task 3: Update skill-injector to use registry config</name>
  <files>src/skills/skill-injector.ts</files>
  <action>
Modify skill-injector.ts to automatically use registry config when available:

After the existing imports, add:
```typescript
import { getRegistryConfig } from '../config/loader.js';
```

Modify the `injectSkills` function to use registry config. Find the line:
```typescript
const registry = getSkillRegistry();
```

And change it to:
```typescript
const registryConfig = getRegistryConfig();
const registry = getSkillRegistry(registryConfig);
```

Also update `injectSpecificSkills` function similarly:
```typescript
export function injectSpecificSkills(
  skillIds: string[],
  agentId: string,
  basePrompt: string
): SkillInjection {
  const registryConfig = getRegistryConfig();
  const registry = getSkillRegistry(registryConfig);
  // ... rest of function unchanged
}
```

This ensures that when skills are injected, they come from the configured registry (global + local with patterns applied).
  </action>
  <verify>
1. Run `npx tsc --noEmit src/skills/skill-injector.ts` - should compile
2. Run `npm run build` - full build should pass
  </verify>
  <done>
Skill injector uses getRegistryConfig() to load skills from configured registry paths.
  </done>
</task>

<task type="auto">
  <name>Task 4: Update config.json with registry example</name>
  <files>.ultraplan/config.json</files>
  <action>
Add registry settings to the existing config.json file. Read the current config and add the new `registry` field:

Add after the `verification` block:

```json
  "registry": {
    "registry": "~/registry",
    "use": {
      "agents": ["*"],
      "skills": ["*"]
    }
  }
```

The complete file should look like:
```json
{
  "version": "3.1.1",
  "mode": "interactive",
  "depth": "standard",
  "parallelization": true,
  "max_workers": 5,
  "commit_docs": true,

  "modelProfile": "balanced",
  "profiles": {
    ... existing profiles ...
  },

  "execution": {
    ... existing execution settings ...
  },

  "verification": {
    ... existing verification settings ...
  },

  "registry": {
    "registry": "~/registry",
    "use": {
      "agents": ["*"],
      "skills": ["*"]
    }
  }
}
```

This enables the global registry with all agents and skills selected.
  </action>
  <verify>
1. Validate JSON syntax: `cat .ultraplan/config.json | python3 -m json.tool > /dev/null`
2. Check registry field exists: `grep -q '"registry"' .ultraplan/config.json && echo "OK"`
  </verify>
  <done>
config.json includes registry settings with default values.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes with no TypeScript errors
2. config.json has valid registry settings
3. SkillInjector automatically uses registry config when loading skills
4. Projects can customize agent/skill selection via use.agents and use.skills patterns
5. ThinkTank skill injection works when thinktank skills are in ~/registry/skills/
</verification>

<success_criteria>
- [ ] src/config/types.ts created with ProjectConfig and RegistrySettings
- [ ] src/config/loader.ts created with getRegistryConfig function using ESM imports
- [ ] src/skills/skill-injector.ts uses getRegistryConfig()
- [ ] .ultraplan/config.json includes registry settings
- [ ] Selection patterns (["*"], ["thinktank/*"]) work correctly
- [ ] `npm run build` passes
</success_criteria>

<output>
After completion, create `.planning/phases/13-central-registry/13-04-SUMMARY.md`
</output>

---
phase: 13-central-registry
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - src/skills/skill-registry.ts
  - src/registry/skill-loader.ts
autonomous: true

must_haves:
  truths:
    - "SkillRegistry loads skills from global registry first, then local (local overrides)"
    - "Missing registry directory logs warning but doesn't crash"
    - "Skill IDs from local registry override same IDs from global registry"
    - "Glob patterns filter which skills are loaded"
    - "Singleton detects config mismatch and throws or provides reset function"
  artifacts:
    - path: "src/registry/skill-loader.ts"
      provides: "Multi-source skill loading logic"
      exports: ["loadSkillsFromSources", "getSkillSources", "matchesSelectionPattern"]
    - path: "src/skills/skill-registry.ts"
      provides: "Enhanced SkillRegistry with multi-source support"
      contains: "loadFromSources"
  key_links:
    - from: "src/skills/skill-registry.ts"
      to: "src/registry/skill-loader.ts"
      via: "import loadSkillsFromSources"
      pattern: "loadSkillsFromSources"
    - from: "src/registry/skill-loader.ts"
      to: "src/registry/paths.ts"
      via: "resolveRegistryPath"
      pattern: "resolveRegistryPath"
---

<objective>
Extend SkillRegistry to support multi-source loading from global registry and local project.

Purpose: Enable skills to be shared across projects via ~/registry/skills/ while allowing project-local overrides in .ultraplan/skills/. This is the core of the cross-project sharing feature.

Output: Enhanced SkillRegistry that loads from multiple sources with load order.
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-central-registry/13-RESEARCH.md
@src/skills/skill-registry.ts
@src/registry/types.ts
@src/registry/paths.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create skill loader for multi-source loading</name>
  <files>src/registry/skill-loader.ts</files>
  <action>
Create a skill loader that handles multi-source loading with load order:

```typescript
/**
 * Skill Loader - Multi-source skill loading with load order
 *
 * Loads skills from global registry first (lower loadOrder), then local
 * project (higher loadOrder). Local skills override global skills with same ID.
 */

import { existsSync, readdirSync, readFileSync, statSync } from 'fs';
import { join } from 'path';
import matter from 'gray-matter';
import type { SkillDefinition } from '../skills/skill-registry.js';
import type { RegistrySource, RegistryConfig } from './types.js';
import {
  resolveRegistryPath,
  getDefaultRegistryPath,
  getSkillsPath,
} from './paths.js';

// Simple YAML parser using gray-matter's engine (same as skill-registry.ts)
function parseYaml(content: string): unknown {
  const result = matter(`---\n${content}\n---`);
  return result.data;
}

/**
 * Get skill source directories with load ordering
 *
 * Sources are ordered by loadOrder (ascending - lower numbers loaded first):
 * - Global registry (loadOrder 1): ~/registry/skills/ - loaded first, can be overridden
 * - Local project (loadOrder 2): .ultraplan/skills/ - loaded last, overrides global
 *
 * @param config - Registry configuration
 * @returns Array of registry sources, ordered by loadOrder (ascending)
 */
export function getSkillSources(config?: RegistryConfig): RegistrySource[] {
  const sources: RegistrySource[] = [];

  // Global registry - loaded first (loadOrder 1), can be overridden
  const globalRegistryPath = config?.registry
    ? resolveRegistryPath(config.registry)
    : getDefaultRegistryPath();

  const globalSkillsPath = getSkillsPath(globalRegistryPath);

  if (existsSync(globalRegistryPath)) {
    if (existsSync(globalSkillsPath)) {
      sources.push({
        path: globalSkillsPath,
        loadOrder: 1, // Loaded first, can be overridden
        isGlobal: true,
      });
    } else {
      // Registry exists but skills/ subdirectory doesn't
      console.warn(
        `Registry directory exists but skills/ subdirectory not found: ${globalSkillsPath}`
      );
    }
  }

  // Local project skills - loaded last (loadOrder 2), overrides global
  const localPath = join(process.cwd(), '.ultraplan/skills');
  if (existsSync(localPath)) {
    sources.push({
      path: localPath,
      loadOrder: 2, // Loaded last, overrides earlier
      isGlobal: false,
    });
  }

  // Sort by loadOrder ascending (lower number = loaded first)
  return sources.sort((a, b) => a.loadOrder - b.loadOrder);
}

/**
 * Check if a skill ID matches selection patterns
 *
 * Supports glob-like patterns:
 * - "thinktank/*" matches "thinktank/risk-analysis", "thinktank/market-research"
 * - "development/build-fix" matches exactly
 * - "*" matches everything
 *
 * @param skillId - Skill ID to check (e.g., "thinktank/risk-analysis")
 * @param patterns - Array of selection patterns
 * @returns Whether the skill matches any pattern
 */
export function matchesSelectionPattern(
  skillId: string,
  patterns: string[] | undefined
): boolean {
  // If no patterns specified, include all skills
  if (!patterns || patterns.length === 0) {
    return true;
  }

  return patterns.some((pattern) => {
    // Wildcard pattern
    if (pattern === '*') {
      return true;
    }

    // Category wildcard: "thinktank/*"
    if (pattern.endsWith('/*')) {
      const prefix = pattern.slice(0, -2);
      return skillId.startsWith(prefix + '/') || skillId === prefix;
    }

    // Exact match or suffix match
    return skillId === pattern || skillId.endsWith('/' + pattern);
  });
}

/**
 * Load skill from YAML file
 *
 * @param filePath - Path to skill YAML file
 * @returns Parsed skill definition or null on error
 */
function loadSkillFile(filePath: string): SkillDefinition | null {
  try {
    const content = readFileSync(filePath, 'utf-8');
    return parseYaml(content) as SkillDefinition;
  } catch (error) {
    console.warn(`Failed to load skill: ${filePath}`, error);
    return null;
  }
}

/**
 * Load skills from a single directory
 *
 * @param dirPath - Directory containing skill YAML files
 * @param selectionPatterns - Patterns to filter skills
 * @returns Map of skill ID to skill definition
 */
function loadSkillsFromDirectory(
  dirPath: string,
  selectionPatterns?: string[]
): Map<string, SkillDefinition> {
  const skills = new Map<string, SkillDefinition>();

  if (!existsSync(dirPath)) {
    return skills;
  }

  try {
    const files = readdirSync(dirPath);
    let validYamlCount = 0;

    for (const file of files) {
      if (file.endsWith('.yaml') && !file.startsWith('_')) {
        const filePath = join(dirPath, file);
        const skill = loadSkillFile(filePath);

        if (skill && matchesSelectionPattern(skill.id, selectionPatterns)) {
          skills.set(skill.id, skill);
          validYamlCount++;
        }
      }
    }

    // Log warning if directory exists but has no valid YAML files
    if (validYamlCount === 0) {
      console.warn(
        `Skills directory exists but contains no valid YAML files: ${dirPath}`
      );
    }
  } catch (error) {
    console.warn(`Failed to read skills directory: ${dirPath}`, error);
  }

  return skills;
}

/**
 * Load skills from multiple sources with load order-based merging
 *
 * Skills are loaded from sources in loadOrder (ascending).
 * Later sources (higher loadOrder) override earlier sources.
 *
 * @param sources - Registry sources ordered by loadOrder
 * @param selectionPatterns - Patterns to filter skills
 * @returns Merged map of skill ID to skill definition
 */
export function loadSkillsFromSources(
  sources: RegistrySource[],
  selectionPatterns?: string[]
): Map<string, SkillDefinition> {
  const mergedSkills = new Map<string, SkillDefinition>();

  // Load in loadOrder (ascending): global first (1), then local (2)
  // This means local skills will override global skills with same ID
  for (const source of sources) {
    const directorySkills = loadSkillsFromDirectory(
      source.path,
      selectionPatterns
    );

    // Merge - later entries override earlier (last write wins)
    for (const [id, skill] of directorySkills) {
      mergedSkills.set(id, skill);
    }
  }

  return mergedSkills;
}

/**
 * Load skill index from directory
 *
 * @param dirPath - Directory containing _index.yaml
 * @returns Parsed index or null
 */
export function loadSkillIndex(dirPath: string): unknown | null {
  const indexPath = join(dirPath, '_index.yaml');

  if (!existsSync(indexPath)) {
    return null;
  }

  try {
    const content = readFileSync(indexPath, 'utf-8');
    return parseYaml(content);
  } catch (error) {
    console.warn(`Failed to load skill index: ${indexPath}`, error);
    return null;
  }
}
```
  </action>
  <verify>
Run `npx tsc --noEmit src/registry/skill-loader.ts` - should compile with no errors.
  </verify>
  <done>
Skill loader compiles and exports getSkillSources, matchesSelectionPattern, loadSkillsFromSources, loadSkillIndex functions. Uses loadOrder (not priority). Logs warnings for partial directory structures.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend SkillRegistry with multi-source support and singleton safety</name>
  <files>src/skills/skill-registry.ts</files>
  <action>
Modify SkillRegistry to use the new multi-source loader. The key changes are:

1. Add optional `config` parameter to constructor accepting RegistryConfig
2. Add `loadFromSources()` method that uses skill-loader
3. Keep backward compatibility - single `skillsDir` parameter still works
4. Update `loadSkills()` to call `loadFromSources()` when config is provided
5. Add singleton config mismatch detection and resetSkillRegistry() function

Changes to make (preserve existing code, add new functionality):

After the existing imports, add:
```typescript
import type { RegistryConfig } from '../registry/types.js';
import {
  getSkillSources,
  loadSkillsFromSources,
  loadSkillIndex,
} from '../registry/skill-loader.js';
```

Add private config property:
```typescript
private config: RegistryConfig | undefined;
```

Modify the constructor to accept optional config:
```typescript
constructor(skillsDirOrConfig?: string | RegistryConfig) {
  if (typeof skillsDirOrConfig === 'string') {
    // Legacy mode: single directory
    this.skillsDir = skillsDirOrConfig;
    this.config = undefined;
  } else if (skillsDirOrConfig) {
    // New mode: registry config
    this.config = skillsDirOrConfig;
    this.skillsDir = path.join(process.cwd(), '.ultraplan/skills');
  } else {
    // Default: local skills only
    this.skillsDir = path.join(process.cwd(), '.ultraplan/skills');
    this.config = undefined;
  }
  this.loadSkills();
}
```

Update loadSkills() to check for config:
```typescript
private loadSkills(): void {
  if (this.config) {
    this.loadFromSources();
    return;
  }
  // ... existing single-directory loading code ...
}
```

Add new loadFromSources() method:
```typescript
/**
 * Load skills from multiple registry sources
 * Global registry loaded first, local overrides
 */
private loadFromSources(): void {
  const sources = getSkillSources(this.config);

  if (sources.length === 0) {
    console.warn('No skill sources found');
    return;
  }

  // Load skills with selection patterns
  const patterns = this.config?.use?.skills;
  this.skills = loadSkillsFromSources(sources, patterns);

  // Load and merge indexes from all sources
  for (const source of sources) {
    const index = loadSkillIndex(source.path);
    if (index && !this.index) {
      this.index = index as SkillIndex;
    } else if (index && this.index) {
      // Merge: combine categories and relationships
      this.mergeIndex(index as SkillIndex);
    }
  }

  console.log(`Loaded ${this.skills.size} skills from ${sources.length} source(s)`);
}

/**
 * Merge skill index from another source.
 *
 * NOTE: This is "last-wins" merging. If both global and local define
 * the same category key, local completely replaces global's category.
 * This is intentional - local overrides should fully replace global
 * definitions for the same key, not merge them additively.
 *
 * Example:
 * - Global defines categories: { planning: {...}, analysis: {...} }
 * - Local defines categories: { planning: {...} }
 * - Result: planning is local's version, analysis is global's version
 */
private mergeIndex(newIndex: SkillIndex): void {
  if (!this.index) {
    this.index = newIndex;
    return;
  }

  // Merge categories (last-wins for same key)
  if (newIndex.categories) {
    this.index.categories = {
      ...this.index.categories,
      ...newIndex.categories,
    };
  }

  // Merge relationships (last-wins for same key)
  if (newIndex.relationships) {
    this.index.relationships = {
      ...this.index.relationships,
      ...newIndex.relationships,
    };
  }

  // Merge auto_selection (last-wins for same key)
  if (newIndex.auto_selection) {
    this.index.auto_selection = {
      ...this.index.auto_selection,
      ...newIndex.auto_selection,
    };
  }

  // Merge agent_defaults (last-wins for same key)
  if (newIndex.agent_defaults) {
    this.index.agent_defaults = {
      ...this.index.agent_defaults,
      ...newIndex.agent_defaults,
    };
  }
}
```

Update singleton storage to track config and add mismatch detection:
```typescript
// Singleton instance and config tracking
let registryInstance: SkillRegistry | null = null;
let registryInstanceConfig: string | RegistryConfig | undefined = undefined;

/**
 * Serialize config for comparison
 */
function serializeConfig(config: string | RegistryConfig | undefined): string {
  if (config === undefined) return 'undefined';
  if (typeof config === 'string') return `string:${config}`;
  return JSON.stringify(config);
}

/**
 * Get singleton SkillRegistry instance
 *
 * @param skillsDirOrConfig - Skills directory path or RegistryConfig
 * @returns Singleton SkillRegistry instance
 * @throws Error if called with different config than existing instance
 */
export function getSkillRegistry(skillsDirOrConfig?: string | RegistryConfig): SkillRegistry {
  if (!registryInstance) {
    registryInstance = new SkillRegistry(skillsDirOrConfig);
    registryInstanceConfig = skillsDirOrConfig;
    return registryInstance;
  }

  // Check for config mismatch
  const existingConfigStr = serializeConfig(registryInstanceConfig);
  const newConfigStr = serializeConfig(skillsDirOrConfig);

  if (existingConfigStr !== newConfigStr) {
    throw new Error(
      `SkillRegistry singleton config mismatch. ` +
      `Existing config: ${existingConfigStr}, ` +
      `New config: ${newConfigStr}. ` +
      `Call resetSkillRegistry() first to reinitialize with new config.`
    );
  }

  return registryInstance;
}

/**
 * Reset singleton registry instance
 *
 * Call this to clear the cached instance before reinitializing with new config.
 * Useful for testing or when config needs to change at runtime.
 */
export function resetSkillRegistry(): void {
  registryInstance = null;
  registryInstanceConfig = undefined;
}
```
  </action>
  <verify>
1. Run `npx tsc --noEmit src/skills/skill-registry.ts` - should compile with no errors
2. Run `npm run build` - full build should pass
  </verify>
  <done>
SkillRegistry constructor accepts RegistryConfig, loadFromSources() loads from multi-source with loadOrder, backward compatible with single skillsDir string. Singleton detects config mismatch and throws. resetSkillRegistry() provided. mergeIndex has JSDoc explaining last-wins behavior.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update registry index export</name>
  <files>src/registry/index.ts</files>
  <action>
Add skill-loader exports to the registry module index:

Add to the existing src/registry/index.ts file:

```typescript
// Skill loader
export {
  getSkillSources,
  loadSkillsFromSources,
  matchesSelectionPattern,
  loadSkillIndex,
} from './skill-loader.js';
```
  </action>
  <verify>
Run `npx tsc --noEmit src/registry/index.ts` - should compile with no errors.
  </verify>
  <done>
Registry module exports all skill-loader functions.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes with no TypeScript errors
2. SkillRegistry can be initialized with RegistryConfig:
   ```typescript
   const registry = new SkillRegistry({ registry: '~/registry' });
   ```
3. Skills load from global registry first, local second (local overrides)
4. Selection patterns filter which skills are loaded
5. Missing directories log warnings but don't crash
6. Singleton throws on config mismatch, resetSkillRegistry() allows re-initialization
7. mergeIndex JSDoc documents last-wins behavior
</verification>

<success_criteria>
- [ ] src/registry/skill-loader.ts created with multi-source loading using loadOrder
- [ ] src/skills/skill-registry.ts accepts RegistryConfig
- [ ] SkillRegistry.loadFromSources() loads from global then local
- [ ] Local skills override global skills with same ID
- [ ] Selection patterns work (thinktank/*, development/build-fix)
- [ ] Singleton config mismatch throws Error with helpful message
- [ ] resetSkillRegistry() function exported and documented
- [ ] mergeIndex() has JSDoc explaining last-wins merge semantics
- [ ] Missing subdirectories log warnings
- [ ] `npm run build` passes
</success_criteria>

<output>
After completion, create `.planning/phases/13-central-registry/13-02-SUMMARY.md`
</output>

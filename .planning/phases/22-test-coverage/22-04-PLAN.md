---
phase: 22-test-coverage
plan: 04
type: execute
wave: 4
depends_on: ["22-03"]
files_modified:
  - package.json
  - vitest.config.ts
  - tests/integration/sync-pipeline.test.ts
  - tests/integration/hook-chain.test.ts
autonomous: true

must_haves:
  truths:
    - "@vitest/coverage-v8 is installed as dev dependency"
    - "vitest.config.ts has coverage configuration with thresholds"
    - "package.json has test:coverage script"
    - "Sync pipeline integration test validates end-to-end PLAN.md to Task flow"
    - "Hook chain integration test validates hook execution order"
  artifacts:
    - path: "package.json"
      provides: "test:coverage script added"
      contains: "test:coverage"
    - path: "vitest.config.ts"
      provides: "Coverage configuration with V8 provider and thresholds"
      contains: "coverage"
    - path: "tests/integration/sync-pipeline.test.ts"
      provides: "End-to-end sync pipeline integration test"
      min_lines: 80
    - path: "tests/integration/hook-chain.test.ts"
      provides: "Hook chain execution order integration test"
      min_lines: 60
  key_links:
    - from: "vitest.config.ts"
      to: "@vitest/coverage-v8"
      via: "coverage.provider configuration"
      pattern: "provider.*v8"
    - from: "tests/integration/sync-pipeline.test.ts"
      to: "src/sync/plan-parser.ts"
      via: "imports sync functions"
      pattern: "import.*from.*sync"
---

<objective>
Configure coverage reporting and create integration tests (Wave 4 - Coverage and Integration).

Purpose: Enable code coverage measurement with @vitest/coverage-v8 and create integration tests that validate the interaction between multiple modules. This finalizes the test infrastructure.

Output:
- Updated `package.json` with test:coverage script
- Updated `vitest.config.ts` with coverage configuration
- `tests/integration/sync-pipeline.test.ts` - Sync pipeline integration test
- `tests/integration/hook-chain.test.ts` - Hook chain integration test
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-test-coverage/22-RESEARCH.md

# Current configuration
@package.json - Current scripts and dependencies
@vitest.config.ts - Current vitest configuration

# Existing integration tests for patterns
@tests/integration/context-architect.test.ts - Integration test pattern
@tests/integration/workflow.test.ts - Workflow test pattern
@tests/helpers/temp-dir.ts - Test workspace helpers
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Coverage Dependencies</name>
  <files>package.json</files>
  <action>
Add @vitest/coverage-v8 to devDependencies and add coverage scripts:

1. **Add devDependency:**
   - "@vitest/coverage-v8": "^2.0.0" (matches vitest version)

2. **Add npm scripts:**
   - "test:coverage": "vitest run --coverage"
   - "test:watch": "vitest" (if not already present)
   - "test:ci": "vitest run --coverage --reporter=verbose"

The package.json should have these scripts after update:
```json
{
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage",
    "test:ci": "vitest run --coverage --reporter=verbose",
    "typecheck": "tsc --noEmit",
    "mcp": "node dist/mcp-server.js"
  },
  "devDependencies": {
    "@types/node": "^22.0.0",
    "@types/uuid": "^10.0.0",
    "@vitest/coverage-v8": "^2.0.0",
    "typescript": "^5.7.0",
    "vitest": "^2.0.0"
  }
}
```

After editing, run `npm install` to install the new dependency.
  </action>
  <verify>npm install && npm run test:coverage -- --help</verify>
  <done>Coverage dependency installed and scripts added</done>
</task>

<task type="auto">
  <name>Task 2: Configure Coverage in Vitest</name>
  <files>vitest.config.ts</files>
  <action>
Update vitest.config.ts with comprehensive coverage configuration:

```typescript
import { defineConfig } from 'vitest/config';
import { resolve } from 'path';

export default defineConfig({
  test: {
    include: ['tests/**/*.test.ts', 'src/**/*.test.ts'],
    exclude: ['references/**/*', 'node_modules/**/*'],
    environment: 'node',
    globals: true,
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      reportsDirectory: './coverage',
      include: ['src/**/*.ts'],
      exclude: [
        'src/**/*.test.ts',
        'src/**/*.d.ts',
        'src/**/types.ts',
        'src/**/index.ts',
        'src/**/__mocks__/**',
      ],
      thresholds: {
        global: {
          statements: 50,
          branches: 50,
          functions: 50,
          lines: 50,
        },
      },
      // Don't fail on threshold violations yet - we're building coverage
      thresholds: {
        global: {
          statements: 30,
          branches: 30,
          functions: 30,
          lines: 30,
        },
      },
    },
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, './src'),
    },
  },
});
```

Key configuration points:
1. V8 provider for accurate TypeScript coverage
2. Multiple reporters: text (console), json (CI), html (browsable)
3. Reports directory at ./coverage
4. Exclude test files, type definitions, barrel exports
5. Start with 30% thresholds (achievable with current tests), increase as coverage grows
  </action>
  <verify>npm run test:coverage</verify>
  <done>Coverage configured with V8 provider and threshold reporting</done>
</task>

<task type="auto">
  <name>Task 3: Create Sync Pipeline Integration Test</name>
  <files>tests/integration/sync-pipeline.test.ts</files>
  <action>
Create an end-to-end integration test for the sync pipeline:

```typescript
/**
 * Sync Pipeline Integration Test
 *
 * Tests the complete flow from PLAN.md parsing to Task tool parameter generation.
 */

import { describe, test, expect, beforeEach, afterEach } from 'vitest';
import { writeFileSync, mkdirSync, rmSync } from 'fs';
import { join } from 'path';
import { tmpdir } from 'os';
import { randomUUID } from 'crypto';

// Import sync pipeline functions
import { parsePlanForSync, extractTaskMappings } from '../../src/sync/plan-parser.js';

describe('Sync Pipeline Integration', () => {
  let testDir: string;
  let planPath: string;

  beforeEach(() => {
    // Create unique temp directory for each test
    testDir = join(tmpdir(), `sync-test-${randomUUID()}`);
    mkdirSync(testDir, { recursive: true });
    planPath = join(testDir, '01-01-PLAN.md');
  });

  afterEach(() => {
    // Clean up temp directory
    try {
      rmSync(testDir, { recursive: true, force: true });
    } catch {
      // Ignore cleanup errors
    }
  });

  test('parses PLAN.md and generates task mappings', async () => {
    // Create test PLAN.md
    const planContent = `---
phase: 01-test
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/feature.ts
autonomous: true
must_haves:
  truths:
    - "Feature works"
  artifacts:
    - path: src/feature.ts
      provides: "Test feature"
---

<objective>
Test objective
</objective>

<tasks>
<task type="auto">
  <name>Task 1: Create feature</name>
  <files>src/feature.ts</files>
  <action>Create the feature</action>
  <verify>npm test</verify>
  <done>Feature created</done>
</task>

<task type="auto">
  <name>Task 2: Add tests</name>
  <files>src/feature.test.ts</files>
  <action>Add tests for feature</action>
  <verify>npm test</verify>
  <done>Tests pass</done>
</task>
</tasks>
`;

    writeFileSync(planPath, planContent);

    // Parse plan
    const planData = await parsePlanForSync(planPath);

    // Verify frontmatter extraction
    expect(planData.frontmatter.phase).toBe('01-test');
    expect(planData.frontmatter.plan).toBe(1);
    expect(planData.frontmatter.wave).toBe(1);

    // Verify tasks extracted
    expect(planData.tasks).toHaveLength(2);
    expect(planData.tasks[0].name).toContain('Create feature');
    expect(planData.tasks[1].name).toContain('Add tests');

    // Extract task mappings
    const mappings = extractTaskMappings(planData);

    // Verify mapping generation
    expect(mappings).toHaveLength(2);
    expect(mappings[0].task_id).toBe('01-01-01');
    expect(mappings[1].task_id).toBe('01-01-02');

    // Verify tool params
    expect(mappings[0].tool_params.prompt).toContain('Create feature');
    expect(mappings[0].tool_params.subagent_type).toBeDefined();
    expect(mappings[0].status).toBe('pending');
    expect(mappings[0].wave).toBe(1);
  });

  test('handles checkpoint tasks correctly', async () => {
    const planContent = `---
phase: 02-test
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: []
autonomous: false
must_haves:
  truths:
    - "UI verified"
  artifacts: []
---

<tasks>
<task type="checkpoint:human-verify" gate="blocking">
  <what-built>New UI component</what-built>
  <how-to-verify>Check the component renders correctly</how-to-verify>
  <resume-signal>Type "approved"</resume-signal>
</task>
</tasks>
`;

    writeFileSync(planPath, planContent);

    const planData = await parsePlanForSync(planPath);

    expect(planData.tasks).toHaveLength(1);
    expect(planData.tasks[0].type).toBe('checkpoint:human-verify');

    const mappings = extractTaskMappings(planData);
    expect(mappings[0].type).toBe('checkpoint:human-verify');
    expect(mappings[0].tool_params.prompt).toContain('What Was Built');
  });

  test('generates deterministic task IDs across runs', async () => {
    const planContent = `---
phase: 06-sync
plan: 3
type: execute
wave: 2
depends_on: ["06-02"]
files_modified: []
autonomous: true
must_haves:
  truths: []
  artifacts: []
---

<tasks>
<task type="auto">
  <name>Task 1: Feature A</name>
  <files>a.ts</files>
  <action>Do A</action>
  <verify>test</verify>
  <done>A done</done>
</task>
</tasks>
`;

    writeFileSync(planPath, planContent);

    // Parse twice
    const planData1 = await parsePlanForSync(planPath);
    const planData2 = await parsePlanForSync(planPath);

    const mappings1 = extractTaskMappings(planData1);
    const mappings2 = extractTaskMappings(planData2);

    // Task IDs should be identical
    expect(mappings1[0].task_id).toBe(mappings2[0].task_id);
    expect(mappings1[0].task_id).toBe('06-03-01');
  });
});
```

This test validates:
1. PLAN.md parsing extracts frontmatter correctly
2. Tasks are extracted from XML
3. Task mappings are generated with correct IDs
4. Checkpoint tasks handled correctly
5. Task IDs are deterministic
  </action>
  <verify>npm test -- tests/integration/sync-pipeline.test.ts</verify>
  <done>Sync pipeline integration test passes</done>
</task>

<task type="auto">
  <name>Task 4: Create Hook Chain Integration Test</name>
  <files>tests/integration/hook-chain.test.ts</files>
  <action>
Create an integration test for hook execution chains:

```typescript
/**
 * Hook Chain Integration Test
 *
 * Tests hook registration and execution order across multiple hooks.
 */

import { describe, test, expect, beforeEach, vi } from 'vitest';

// Import hook system components
import { createCategoryRoutingHook } from '../../src/hooks/tool/category-routing.js';
import {
  shouldWarnOnWrite,
  getFileGuardWarning,
} from '../../src/hooks/orchestrator/file-guard.js';
import type { HookContext } from '../../src/hooks/types.js';

describe('Hook Chain Integration', () => {
  let mockContext: HookContext;
  let emitEventMock: ReturnType<typeof vi.fn>;

  beforeEach(() => {
    emitEventMock = vi.fn();
    mockContext = {
      sessionId: 'test-session',
      stateManager: {} as any,
      emitEvent: emitEventMock,
      config: {
        enabledHooks: [],
        disabledHooks: [],
        hookOptions: {},
      },
    };
  });

  describe('Category Routing + File Guard Integration', () => {
    test('category routing processes Task tool calls', async () => {
      const categoryHook = createCategoryRoutingHook(mockContext);
      const handler = categoryHook['tool.execute.before']!;

      // Simulate Task tool call with debugging prompt
      const result = await handler({
        toolName: 'Task',
        params: { prompt: 'Debug the memory leak in auth module' },
        sessionId: 'session-1',
      });

      // Should detect ultrabrain category
      expect(result?.warning).toContain('ultrabrain');
      expect(result?.warning).toContain('opus');
      expect(emitEventMock).toHaveBeenCalledWith(
        expect.objectContaining({
          type: 'category_routing',
          payload: expect.objectContaining({
            category: 'ultrabrain',
          }),
        })
      );
    });

    test('file guard warns on source file writes', () => {
      // Check various paths
      expect(shouldWarnOnWrite('Write', 'src/api.ts')).toBe(true);
      expect(shouldWarnOnWrite('Write', '.planning/STATE.md')).toBe(false);
      expect(shouldWarnOnWrite('Read', 'src/api.ts')).toBe(false);

      // Get warning details
      const result = getFileGuardWarning('Write', 'src/models/user.ts');
      expect(result.shouldWarn).toBe(true);
      expect(result.warning).toContain('DELEGATION REQUIRED');
      expect(result.warning).toContain('src/models/user.ts');
    });

    test('hooks can be chained for multiple validations', async () => {
      // Simulate a write operation that should:
      // 1. Pass category routing (not a Task tool)
      // 2. Trigger file guard warning

      const categoryHook = createCategoryRoutingHook(mockContext);
      const categoryHandler = categoryHook['tool.execute.before']!;

      // Category routing ignores non-Task tools
      const categoryResult = await categoryHandler({
        toolName: 'Write',
        params: { file_path: 'src/api.ts', content: '...' },
        sessionId: 'session-1',
      });
      expect(categoryResult).toBeUndefined();

      // File guard catches the write
      const fileGuardResult = getFileGuardWarning('Write', 'src/api.ts');
      expect(fileGuardResult.shouldWarn).toBe(true);
    });
  });

  describe('Hook Event Emission', () => {
    test('hooks emit events for observability', async () => {
      const categoryHook = createCategoryRoutingHook(mockContext);
      const handler = categoryHook['tool.execute.before']!;

      await handler({
        toolName: 'Task',
        params: { prompt: 'Find the config file' },
        sessionId: 'session-1',
      });

      expect(emitEventMock).toHaveBeenCalledTimes(1);
      const emittedEvent = emitEventMock.mock.calls[0][0];

      expect(emittedEvent.type).toBe('category_routing');
      expect(emittedEvent.source).toBe('hook:category-routing');
      expect(emittedEvent.payload.sessionId).toBe('session-1');
    });

    test('hooks respect logRouting option', async () => {
      const quietHook = createCategoryRoutingHook(mockContext, { logRouting: false });
      const handler = quietHook['tool.execute.before']!;

      await handler({
        toolName: 'Task',
        params: { prompt: 'Find something' },
        sessionId: 'session-1',
      });

      expect(emitEventMock).not.toHaveBeenCalled();
    });
  });

  describe('Hook Configuration', () => {
    test('hooks can be configured with options', async () => {
      // With prompt enhancement
      const enhancingHook = createCategoryRoutingHook(mockContext, { enhancePrompts: true });
      const handler = enhancingHook['tool.execute.before']!;

      const result = await handler({
        toolName: 'Task',
        params: { prompt: 'Debug issue' },
        sessionId: 'session-1',
      });

      // Prompt should be enhanced with category guidance
      expect(result?.params?.prompt).toContain('Category Guidance');
    });
  });
});
```

This test validates:
1. Multiple hooks can process the same tool call
2. Hooks emit observable events
3. Hook configuration affects behavior
4. Hooks cooperate without conflicts
  </action>
  <verify>npm test -- tests/integration/hook-chain.test.ts</verify>
  <done>Hook chain integration test passes</done>
</task>

</tasks>

<verification>
1. `npm install` completes without errors
2. `npm run test:coverage` generates coverage report
3. Coverage report appears in ./coverage directory
4. Integration tests pass: `npm test -- tests/integration/`
5. Coverage thresholds respected (30% minimum)
6. HTML coverage report viewable at coverage/index.html
</verification>

<success_criteria>
1. @vitest/coverage-v8 installed and configured
2. test:coverage script works and generates reports
3. Coverage thresholds set to achievable 30% minimum
4. 2 new integration tests validate cross-module behavior
5. All tests pass with coverage enabled
6. Coverage report shows actual coverage percentages
</success_criteria>

<output>
After completion, create `.planning/phases/22-test-coverage/22-04-SUMMARY.md`
</output>

---
phase: 22-test-coverage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/documents/validation/schemas.test.ts
  - src/documents/xml/task-parser.test.ts
  - src/documents/templates/plan.test.ts
  - src/orchestration/ralplan/orchestrator.test.ts
  - src/orchestration/keywords/patterns.test.ts
autonomous: true

must_haves:
  truths:
    - "Zod schema validation tests verify valid frontmatter passes and invalid throws"
    - "Task XML parser tests cover all task types (auto, checkpoint variants)"
    - "Plan template tests verify frontmatter extraction and content parsing"
    - "Ralplan orchestrator tests verify state transitions and consensus logic"
    - "Keyword patterns tests verify pattern matching for all execution modes"
  artifacts:
    - path: "src/documents/validation/schemas.test.ts"
      provides: "Schema validation tests for PlanFrontmatter, MustHaves, Artifact, KeyLink"
      min_lines: 80
    - path: "src/documents/xml/task-parser.test.ts"
      provides: "XML task parser tests for all task types"
      min_lines: 100
    - path: "src/documents/templates/plan.test.ts"
      provides: "Plan template parsing and generation tests"
      min_lines: 60
    - path: "src/orchestration/ralplan/orchestrator.test.ts"
      provides: "Ralplan orchestrator state and consensus tests"
      min_lines: 80
    - path: "src/orchestration/keywords/patterns.test.ts"
      provides: "Keyword pattern matching tests for all modes"
      min_lines: 60
  key_links:
    - from: "src/documents/validation/schemas.test.ts"
      to: "src/documents/validation/schemas.ts"
      via: "imports schema validators"
      pattern: "import.*from.*schemas"
    - from: "src/documents/xml/task-parser.test.ts"
      to: "src/documents/xml/task-parser.ts"
      via: "imports parseTaskXml, parseTasksSection"
      pattern: "import.*parseTask"
---

<objective>
Create unit tests for core document and orchestration modules (Wave 1 - Foundation Tests).

Purpose: Establish test coverage for the foundational modules that other features depend on. These modules handle PLAN.md parsing, XML task extraction, and orchestration coordination.

Output:
- `src/documents/validation/schemas.test.ts` - Zod schema validation tests
- `src/documents/xml/task-parser.test.ts` - XML task parser tests
- `src/documents/templates/plan.test.ts` - Plan template tests
- `src/orchestration/ralplan/orchestrator.test.ts` - Ralplan orchestrator tests
- `src/orchestration/keywords/patterns.test.ts` - Keyword pattern tests
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-test-coverage/22-RESEARCH.md

# Existing test patterns to follow
@src/complexity/estimator.test.ts - Unit test pattern with describe/it blocks
@src/hooks/tool/category-routing.test.ts - Mocking pattern with vi.fn()

# Source files to test
@src/documents/validation/schemas.ts - Zod schemas for PLAN.md validation
@src/documents/xml/task-parser.ts - XML task parsing functions
@src/documents/templates/plan.ts - Plan template parsing
@src/orchestration/ralplan/orchestrator.ts - Ralplan state machine
@src/orchestration/keywords/patterns.ts - Keyword pattern matching
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Schema Validation Tests</name>
  <files>src/documents/validation/schemas.test.ts</files>
  <action>
Create comprehensive tests for Zod schema validators:

1. **ArtifactSchema tests:**
   - Valid artifact with all fields passes
   - Valid artifact with optional fields omitted passes
   - Invalid artifact (missing required path) throws
   - Invalid artifact (negative min_lines) throws

2. **KeyLinkSchema tests:**
   - Valid key link passes
   - Valid key link without optional pattern passes
   - Invalid key link (missing from/to/via) throws

3. **MustHavesSchema tests:**
   - Valid must_haves with all sections passes
   - Valid must_haves without optional key_links passes
   - Empty truths array fails
   - Empty artifacts array fails

4. **PlanFrontmatterSchema tests:**
   - Valid complete frontmatter passes
   - Valid frontmatter with user_setup passes
   - Invalid wave (0 or negative) throws
   - Invalid type (not execute/tdd) throws
   - Missing required fields throws

5. **Validation function tests:**
   - validatePlanFrontmatter throws on invalid
   - safeParsePlanFrontmatter returns success/error result
   - validateMustHaves validates must_haves section
   - validateArtifact validates single artifact
   - validateKeyLink validates single key link

Use real-world examples from existing PLAN.md files in .planning/phases/.

```typescript
import { describe, it, expect } from 'vitest';
import {
  ArtifactSchema,
  KeyLinkSchema,
  MustHavesSchema,
  PlanFrontmatterSchema,
  validatePlanFrontmatter,
  safeParsePlanFrontmatter,
} from './schemas.js';
```
  </action>
  <verify>npm test -- src/documents/validation/schemas.test.ts</verify>
  <done>All schema validation tests pass, covering valid inputs and error cases</done>
</task>

<task type="auto">
  <name>Task 2: Create XML Task Parser Tests</name>
  <files>src/documents/xml/task-parser.test.ts</files>
  <action>
Create comprehensive tests for XML task parsing:

1. **unescapeXml tests:**
   - Converts &amp; to &
   - Converts &lt; to <
   - Converts &gt; to >
   - Converts &quot; to "
   - Handles multiple entities in one string

2. **parseTaskXml tests for auto tasks:**
   - Parses complete auto task with all fields
   - Parses auto task with comma-separated files
   - Throws on missing <files> tag
   - Throws on missing <action> tag
   - Throws on missing <verify> tag
   - Throws on missing <done> tag
   - Throws on missing type attribute

3. **parseTaskXml tests for checkpoint:human-verify:**
   - Parses complete human-verify task
   - Extracts gate attribute (blocking default)
   - Throws on missing <what-built>
   - Throws on missing <how-to-verify>
   - Throws on missing <resume-signal>

4. **parseTaskXml tests for checkpoint:decision:**
   - Parses complete decision task with options
   - Extracts all option fields (id, name, pros, cons)
   - Throws on missing <decision>
   - Throws on missing <options>
   - Throws on empty options

5. **parseTaskXml tests for checkpoint:human-action:**
   - Parses complete human-action task
   - Throws on missing <action>
   - Throws on missing <instructions>

6. **parseTasksSection tests:**
   - Extracts multiple tasks from <tasks> section
   - Returns empty array for missing <tasks> section
   - Handles mixed task types
   - Re-throws parse errors with context

Use actual XML snippets similar to those in existing PLAN.md files.

```typescript
import { describe, it, expect } from 'vitest';
import { unescapeXml, parseTaskXml, parseTasksSection } from './task-parser.js';
```
  </action>
  <verify>npm test -- src/documents/xml/task-parser.test.ts</verify>
  <done>All XML parser tests pass, covering all task types and error cases</done>
</task>

<task type="auto">
  <name>Task 3: Create Plan Template Tests</name>
  <files>src/documents/templates/plan.test.ts</files>
  <action>
Create tests for plan template parsing (parsePlanMd function):

1. **parsePlanMd frontmatter extraction:**
   - Extracts phase, plan, type, wave from YAML frontmatter
   - Extracts depends_on array
   - Extracts files_modified array
   - Extracts autonomous boolean
   - Extracts must_haves object (truths, artifacts, key_links)
   - Extracts optional user_setup array

2. **parsePlanMd content extraction:**
   - Returns markdown content after frontmatter
   - Preserves <objective> section
   - Preserves <tasks> section
   - Preserves <verification> section

3. **Edge cases:**
   - Handles empty frontmatter gracefully
   - Handles missing optional fields with defaults
   - Handles malformed YAML with error

4. **Integration with task parser:**
   - Content can be passed to parseTasksSection
   - Tasks extracted match frontmatter metadata

Create test fixtures using minimal valid PLAN.md content.

```typescript
import { describe, it, expect } from 'vitest';
import { parsePlanMd } from './plan.js';
```
  </action>
  <verify>npm test -- src/documents/templates/plan.test.ts</verify>
  <done>Plan template tests pass, frontmatter and content extraction verified</done>
</task>

<task type="auto">
  <name>Task 4: Create Ralplan Orchestrator Tests</name>
  <files>src/orchestration/ralplan/orchestrator.test.ts</files>
  <action>
Create tests for the ralplan orchestrator module:

1. **State machine tests (if RalplanState class exists):**
   - Initial state is 'idle'
   - Transitions from idle to planning
   - Transitions from planning to reviewing
   - Transitions from reviewing to consensus
   - Invalid transitions throw/return error

2. **Consensus logic tests:**
   - Requires minimum votes for consensus
   - Handles unanimous approval
   - Handles rejection and re-planning
   - Tracks iteration count

3. **Orchestrator coordination tests:**
   - Spawns planner agent correctly
   - Spawns critic agent for review
   - Collects votes from reviewers
   - Terminates on max iterations

4. **Error handling:**
   - Handles agent timeout
   - Handles conflicting votes
   - Resets state on abort

Check the actual orchestrator.ts implementation to align tests with real functions/classes.
If the module exports functions instead of classes, test those functions directly.

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
// Import actual exports from orchestrator.ts
```
  </action>
  <verify>npm test -- src/orchestration/ralplan/orchestrator.test.ts</verify>
  <done>Ralplan orchestrator tests pass, state transitions and consensus verified</done>
</task>

<task type="auto">
  <name>Task 5: Create Keyword Patterns Tests</name>
  <files>src/orchestration/keywords/patterns.test.ts</files>
  <action>
Create tests for keyword pattern matching:

1. **Mode detection patterns:**
   - "autopilot" triggers autopilot mode
   - "build me" triggers autopilot mode
   - "ulw" or "ultrawork" triggers ultrawork mode
   - "eco" or "ecomode" triggers ecomode mode
   - "ralph" triggers ralph mode
   - "plan this" triggers plan mode

2. **Pattern matching functions:**
   - detectKeywords returns array of matched keywords
   - getPrimaryMode returns dominant mode when multiple detected
   - hasKeyword checks for specific keyword presence

3. **Conflict resolution:**
   - ecomode wins over ultrawork when both present
   - Explicit mode keywords override defaults
   - Generic "fast"/"parallel" defers to config

4. **Edge cases:**
   - Case insensitive matching
   - Partial word boundaries (e.g., "ralph" not "ralphie")
   - Empty string returns no matches
   - Multiple keywords in one message

Check patterns.ts exports and test the actual exported functions.

```typescript
import { describe, it, expect } from 'vitest';
// Import actual exports from patterns.ts
```
  </action>
  <verify>npm test -- src/orchestration/keywords/patterns.test.ts</verify>
  <done>Keyword pattern tests pass, all mode detection patterns verified</done>
</task>

</tasks>

<verification>
1. `npm test -- src/documents/` - All document tests pass
2. `npm test -- src/orchestration/ralplan/` - Ralplan tests pass
3. `npm test -- src/orchestration/keywords/` - Keyword tests pass
4. `npm run build` - No TypeScript errors in test files
5. Test files follow existing patterns from estimator.test.ts
</verification>

<success_criteria>
1. 5 new test files created with comprehensive coverage
2. Each test file has 60+ lines of tests
3. Tests cover both happy paths and error cases
4. All tests pass when run individually and together
5. Tests use existing patterns (describe/it/expect from vitest)
6. No mocking external services - pure unit tests
</success_criteria>

<output>
After completion, create `.planning/phases/22-test-coverage/22-01-SUMMARY.md`
</output>

---
phase: 03-gsd-integration
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/git/types.ts
  - src/git/commit.ts
  - src/git/index.ts
  - src/index.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Task completion triggers atomic commit with specific files"
    - "Commit message follows conventional format (type(scope): description)"
    - "Only specified files are staged (never git add .)"
    - "Commit fails gracefully if files not modified"
  artifacts:
    - path: "src/git/types.ts"
      provides: "Git operation types"
      exports: ["TaskCommitInput", "CommitResult", "CommitType"]
      min_lines: 30
    - path: "src/git/commit.ts"
      provides: "Atomic commit implementation"
      exports: ["commitTaskAtomically", "getGitStatus"]
      min_lines: 80
    - path: "src/git/index.ts"
      provides: "Git module exports"
      min_lines: 10
  key_links:
    - from: "src/git/commit.ts"
      to: "simple-git"
      via: "import for git operations"
      pattern: "import.*simple-git"
    - from: "src/index.ts"
      to: "src/git/index.ts"
      via: "re-export git module"
      pattern: "export.*git"
---

<objective>
Implement atomic commit pattern for task completion.

Purpose: Enable automatic commits after each task completes, creating a recoverable history of changes with conventional commit messages.
Output: Git integration module with atomic commit capability using simple-git library.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Reference git patterns
@references/get-shit-done/get-shit-done/references/git-integration.md

# Existing checkpoint module (for state context)
@src/state/checkpoint.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install simple-git and create git types</name>
  <files>package.json, src/git/types.ts</files>
  <action>
Install simple-git:
```bash
npm install simple-git
```

Create src/git/types.ts:

```typescript
/** Conventional commit types */
export type CommitType =
  | 'feat'     // New feature
  | 'fix'      // Bug fix
  | 'test'     // Tests
  | 'refactor' // Code restructuring
  | 'perf'     // Performance
  | 'chore'    // Maintenance
  | 'docs'     // Documentation
  | 'style';   // Formatting

/** Input for atomic task commit */
export interface TaskCommitInput {
  type: CommitType;
  /** Phase identifier (e.g., '03') */
  phase: string;
  /** Plan number (e.g., '01') */
  plan: string;
  /** Brief description of what was done */
  description: string;
  /** Bullet points for commit body */
  bulletPoints: string[];
  /** Files to stage (exact paths) */
  files: string[];
}

/** Result of commit operation */
export interface CommitResult {
  success: boolean;
  /** Git commit hash (if successful) */
  hash?: string;
  /** Error message (if failed) */
  error?: string;
}

/** Git status summary */
export interface GitStatusSummary {
  modified: string[];
  created: string[];
  deleted: string[];
  staged: string[];
  notStaged: string[];
}
```
  </action>
  <verify>npm ls simple-git && npx tsc --noEmit src/git/types.ts</verify>
  <done>simple-git installed, types compile</done>
</task>

<task type="auto">
  <name>Task 2: Implement atomic commit function</name>
  <files>src/git/commit.ts</files>
  <action>
Create src/git/commit.ts:

```typescript
import simpleGit, { SimpleGit } from 'simple-git';
import type { TaskCommitInput, CommitResult, GitStatusSummary } from './types.js';

/**
 * Get current git status summary
 */
export async function getGitStatus(cwd?: string): Promise<GitStatusSummary> {
  const git: SimpleGit = simpleGit(cwd);
  const status = await git.status();

  return {
    modified: status.modified,
    created: status.not_added,
    deleted: status.deleted,
    staged: status.staged,
    notStaged: [...status.modified, ...status.not_added].filter(f => !status.staged.includes(f))
  };
}

/**
 * Commit task changes atomically
 *
 * NEVER uses git add . - only stages specified files
 * Validates files exist in git status before staging
 */
export async function commitTaskAtomically(
  input: TaskCommitInput,
  cwd?: string
): Promise<CommitResult> {
  const git: SimpleGit = simpleGit(cwd);

  try {
    // Get current status
    const status = await git.status();
    const allChanges = [
      ...status.modified,
      ...status.not_added,
      ...status.created,
      ...status.deleted
    ];

    // Validate all specified files have changes
    const missingFiles = input.files.filter(f => !allChanges.includes(f));
    if (missingFiles.length > 0) {
      return {
        success: false,
        error: `Files not found in git status: ${missingFiles.join(', ')}`
      };
    }

    // Stage only specified files (CRITICAL: never git add .)
    for (const file of input.files) {
      await git.add(file);
    }

    // Build conventional commit message
    const header = `${input.type}(${input.phase}-${input.plan}): ${input.description}`;
    const body = input.bulletPoints.length > 0
      ? '\n\n' + input.bulletPoints.map(bp => `- ${bp}`).join('\n')
      : '';
    const message = header + body;

    // Commit
    const result = await git.commit(message);

    return {
      success: true,
      hash: result.commit
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error)
    };
  }
}
```

Key safety measures:
1. NEVER use git add . or git add -A
2. Validate files exist in git status before staging
3. Return clear error if files not modified
4. Use conventional commit format: type(scope): description
  </action>
  <verify>npx tsc --noEmit src/git/commit.ts</verify>
  <done>Commit function compiles, implements all safety measures</done>
</task>

<task type="auto">
  <name>Task 3: Create git module index and integrate</name>
  <files>src/git/index.ts, src/index.ts</files>
  <action>
Create src/git/index.ts:
```typescript
export * from './types.js';
export { commitTaskAtomically, getGitStatus } from './commit.js';
```

Update src/index.ts:
- Add: export * from './git/index.js';

Ensure all exports use .js extension for ESM compatibility.
  </action>
  <verify>npx tsc --noEmit && npm run build</verify>
  <done>Git module exports accessible from main entry point, build succeeds</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds
- [ ] simple-git installed in dependencies
- [ ] commitTaskAtomically() validates files before staging
- [ ] Conventional commit format correct
- [ ] All exports accessible from src/index.ts
</verification>

<success_criteria>
- All tasks completed
- Atomic commit stages only specified files
- Commit message follows conventional format
- Error handling for missing/unmodified files
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-gsd-integration/03-04-SUMMARY.md`
</output>

---
phase: 06-claude-tasks-sync
plan: 2
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/sync/task-mapper.ts
  - src/sync/dependency-map.ts
  - src/sync/index.ts
autonomous: true

must_haves:
  truths:
    - "TaskMapping objects convert to valid Task tool invocations"
    - "Wave dependencies correctly map to blockedBy arrays"
    - "All plans in a phase can be processed together"
  artifacts:
    - path: "src/sync/task-mapper.ts"
      provides: "Task tool invocation generation"
      exports: ["createTaskInvocation", "createTaskInvocations", "TaskInvocation"]
      min_lines: 50
    - path: "src/sync/dependency-map.ts"
      provides: "Wave to blockedBy conversion"
      exports: ["mapWaveToBlockedBy", "buildDependencyMap", "DependencyMap"]
      min_lines: 40
  key_links:
    - from: "src/sync/task-mapper.ts"
      to: "src/sync/types.ts"
      via: "import TaskMapping, TaskToolParams"
      pattern: "TaskMapping|TaskToolParams"
    - from: "src/sync/dependency-map.ts"
      to: "src/sync/plan-parser.ts"
      via: "uses extractTaskMappings output"
      pattern: "TaskMapping"
---

<objective>
Implement PLAN.md to Task tool invocation conversion and wave dependency mapping

Purpose: Enable automatic Task creation from PLAN.md with correct dependency ordering
Output: task-mapper.ts and dependency-map.ts in src/sync/
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-claude-tasks-sync/06-RESEARCH.md

# From Plan 06-01
@src/sync/types.ts
@src/sync/plan-parser.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement task mapper</name>
  <files>src/sync/task-mapper.ts</files>
  <action>
Create task-mapper.ts to convert TaskMapping to Task tool invocations:

1. Define TaskInvocation interface:
   - tool_name: 'Task' (literal)
   - tool_input: TaskToolParams
   - task_id: string (for tracking)
   - blocked_by: string[] (task IDs this is blocked by)

2. createTaskInvocation(mapping: TaskMapping, blockedBy?: string[]): TaskInvocation
   - Create TaskInvocation from TaskMapping
   - Use mapping.tool_params directly
   - Add blocked_by from parameter (defaults to [])
   - Include task_id for correlation

3. createTaskInvocations(mappings: TaskMapping[], dependencyMap: DependencyMap): TaskInvocation[]
   - Process array of TaskMappings
   - Look up blockedBy from dependencyMap for each task
   - Return array of TaskInvocations in execution order (sorted by wave, then task index)

4. determineSubagentType(taskType: TaskType): string
   - 'auto' -> 'oh-my-claudecode:executor'
   - 'checkpoint:human-verify' -> 'oh-my-claudecode:verifier'
   - 'checkpoint:decision' -> 'oh-my-claudecode:architect'
   - 'checkpoint:human-action' -> 'oh-my-claudecode:executor'

Import TaskMapping, TaskToolParams from './types.js', DependencyMap from './dependency-map.js' (type-only import to avoid circular).
  </action>
  <verify>npx tsc --noEmit src/sync/task-mapper.ts</verify>
  <done>createTaskInvocations produces valid Task tool invocation objects</done>
</task>

<task type="auto">
  <name>Task 2: Implement wave dependency mapper</name>
  <files>src/sync/dependency-map.ts</files>
  <action>
Create dependency-map.ts to convert wave numbers to blockedBy task IDs:

1. Define DependencyMap type:
   - Record&lt;string, string[]&gt; - task_id -> array of blocking task_ids

2. buildDependencyMap(allMappings: TaskMapping[]): DependencyMap
   - Group tasks by wave number
   - For each task in wave N:
     - blocked_by = all task IDs from waves 1 to N-1
   - Return map from task_id to blocking task_ids
   - Tasks in wave 1 have empty blockedBy

3. mapWaveToBlockedBy(taskWave: number, allMappings: TaskMapping[]): string[]
   - Filter mappings where wave &lt; taskWave
   - Return array of task_ids
   - Utility function for single-task lookup

4. getExecutionOrder(mappings: TaskMapping[]): TaskMapping[]
   - Sort by wave (ascending), then by plan number, then by task index in plan
   - Returns mappings in execution order
   - Useful for sequential execution

Example:
- Wave 1 tasks: 06-01-01, 06-01-02 -> blockedBy: []
- Wave 2 tasks: 06-02-01, 06-03-01 -> blockedBy: ['06-01-01', '06-01-02']

Import TaskMapping from './types.js'.
  </action>
  <verify>npx tsc --noEmit src/sync/dependency-map.ts</verify>
  <done>buildDependencyMap correctly maps wave dependencies to blockedBy arrays</done>
</task>

<task type="auto">
  <name>Task 3: Update sync module exports</name>
  <files>src/sync/index.ts</files>
  <action>
Update index.ts to include new exports:

Add re-exports from './task-mapper.js':
- TaskInvocation (type)
- createTaskInvocation
- createTaskInvocations
- determineSubagentType

Add re-exports from './dependency-map.js':
- DependencyMap (type)
- buildDependencyMap
- mapWaveToBlockedBy
- getExecutionOrder

Organize exports by category with comments:
// Types
// Plan Parser
// Task Mapper
// Dependency Mapping
  </action>
  <verify>npx tsc --noEmit src/sync/index.ts</verify>
  <done>All task-mapper and dependency-map exports available from src/sync</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] src/sync/task-mapper.ts exists with TaskInvocation creation
- [ ] src/sync/dependency-map.ts exists with wave mapping
- [ ] src/sync/index.ts updated with new exports
- [ ] npx tsc --noEmit passes for all files
- [ ] No circular dependency issues between files
</verification>

<success_criteria>

- TaskInvocation matches Claude Task tool schema
- createTaskInvocations produces correctly ordered invocations
- buildDependencyMap correctly computes blockedBy from waves
- Wave 1 tasks have empty blockedBy, higher waves block on lower
- All functions are type-safe with no errors

</success_criteria>

<output>
After completion, create `.planning/phases/06-claude-tasks-sync/06-02-SUMMARY.md`
</output>

---
phase: 08-integration-testing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/integration/error-recovery.test.ts
  - tests/helpers/mock-error.ts
autonomous: true

must_haves:
  truths:
    - "Error recovery tests run and pass via `npm test`"
    - "Tests verify checkpoint creation before risky operations"
    - "Tests verify state rollback on error"
    - "Tests verify cooldown timer prevents immediate retry"
    - "Tests verify max retries exceeded stops retry loop"
  artifacts:
    - path: "tests/integration/error-recovery.test.ts"
      provides: "Error recovery test suite"
      min_lines: 80
    - path: "tests/helpers/mock-error.ts"
      provides: "Error injection utilities"
      exports: ["createRecoverableError", "createFatalError"]
  key_links:
    - from: "tests/integration/error-recovery.test.ts"
      to: "src/recovery/rollback.ts"
      via: "import handleError"
      pattern: "import.*handleError.*from"
    - from: "tests/integration/error-recovery.test.ts"
      to: "src/state/checkpoint.ts"
      via: "import checkpoint functions"
      pattern: "import.*(createCheckpoint|getLatestCheckpoint).*from"
    - from: "tests/integration/error-recovery.test.ts"
      to: "src/loops/ralph/state.ts"
      via: "import ralph state"
      pattern: "import.*RalphLoop.*from"
---

<objective>
Create error recovery integration tests for rollback and retry scenarios

Purpose: Verify the error recovery system handles failures gracefully, rolls back state to checkpoints, respects cooldown timers, and stops after max retries.
Output: Working error recovery test suite that validates the robustness of the Ralph Loop error handling.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-integration-testing/08-RESEARCH.md

# Key source modules to test
@src/recovery/rollback.ts
@src/recovery/types.ts
@src/state/checkpoint.ts
@src/state/state-manager.ts
@src/loops/ralph/state.ts
@src/state/event-system.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error injection helper</name>
  <files>tests/helpers/mock-error.ts</files>
  <action>
Create error injection utilities for testing recovery scenarios:

1. Export `createRecoverableError(message: string)`:
   - Returns Error instance with recoverable metadata
   - Example: `new Error(message)` with optional `recoverable: true` property

2. Export `createFatalError(message: string)`:
   - Returns Error instance marked as non-recoverable
   - Example: `new Error(message)` with `fatal: true` property

3. Export `simulateFailure(fn: () => Promise<void>, error: Error)`:
   - Wrapper that executes fn then throws error
   - Useful for simulating mid-execution failures

4. Export `MockRecoveryConfig`:
   - Type and factory for recovery config with testable values
   - Short cooldown (100ms) for fast tests
   - Low max retries (2) for quick iteration
  </action>
  <verify>`npx tsc --noEmit tests/helpers/mock-error.ts` passes</verify>
  <done>Mock error helper exports utilities for injecting test failures</done>
</task>

<task type="auto">
  <name>Task 2: Create error recovery integration tests</name>
  <files>tests/integration/error-recovery.test.ts</files>
  <action>
Create comprehensive error recovery tests:

1. **Test Suite: Checkpoint Recovery**
   - Test: "should create checkpoint before execution"
     - Setup workspace with initial state
     - Call `createCheckpoint()`
     - Verify checkpoint file exists in `.ultraplan/state/checkpoints/`
     - Verify checkpoint contains current state snapshot
   - Test: "should restore checkpoint on rollback"
     - Create checkpoint, modify state, call `rollbackToCheckpoint()`
     - Verify state matches original checkpoint values

2. **Test Suite: Error Handling**
   - Test: "should increment error count on handleError"
     - Call `handleError()` with mock error and context
     - Verify recovery state shows errorCount = 1
     - Call again, verify errorCount = 2
   - Test: "should emit rollback_initiated event"
     - Setup event listener (poll events after handleError)
     - Call `handleError()`
     - Verify event with type 'rollback_initiated' was emitted
   - Test: "should clear Ralph Loop state on error"
     - Set Ralph Loop state to active
     - Call `handleError()`
     - Verify Ralph Loop state cleared (allows retry)

3. **Test Suite: Retry Logic**
   - Test: "should allow retry when under max retries"
     - Set errorCount = 1, maxRetries = 3
     - Verify `canRetry()` returns true
   - Test: "should block retry when max retries exceeded"
     - Set errorCount = 3, maxRetries = 3
     - Verify `canRetry()` returns false
   - Test: "should emit ralph_loop_failed when max retries exceeded"
     - Call handleError repeatedly until max retries
     - Verify event type 'ralph_loop_failed' with reason 'max_retries'

4. **Test Suite: Cooldown Timer**
   - Test: "should block retry during cooldown"
     - Set cooldownUntil to future timestamp
     - Verify `canRetry()` returns false
   - Test: "should allow retry after cooldown expires"
     - Set cooldownUntil to past timestamp
     - Verify `canRetry()` returns true

Use temp workspace for each test, cleanup in afterEach.
Use short cooldowns (100ms) to avoid slow tests.
Mock Date.now() or use real time with short waits.
  </action>
  <verify>`npm test` runs and error recovery tests pass</verify>
  <done>Error recovery tests pass, covering checkpoints, error handling, retry logic, and cooldown</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm test` passes with all error recovery tests green
- [ ] Tests verify checkpoint creation and restoration
- [ ] Tests verify error count increment and max retry detection
- [ ] Tests verify cooldown timer blocks/allows retries
- [ ] Tests verify events emitted (rollback_initiated, ralph_loop_failed)
</verification>

<success_criteria>

- Error recovery test suite exists at `tests/integration/error-recovery.test.ts`
- Mock error helper exists at `tests/helpers/mock-error.ts`
- `npm test` runs successfully with all tests passing
- Tests validate: checkpoints, error handling, retry logic, cooldown timers
</success_criteria>

<output>
After completion, create `.planning/phases/08-integration-testing/08-02-SUMMARY.md`
</output>

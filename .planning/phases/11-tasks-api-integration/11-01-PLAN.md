---
phase: 11-tasks-api-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tasks/types.ts
  - src/tasks/api.ts
  - src/tasks/registry.ts
  - src/tasks/index.ts
autonomous: true

must_haves:
  truths:
    - "TaskCreate wrapper accepts TaskToolParams and returns Claude Task ID"
    - "Registry stores mapping between internal task IDs and Claude Task IDs"
    - "Registry can persist/restore from PLAN.md frontmatter"
  artifacts:
    - path: "src/tasks/types.ts"
      provides: "Claude Tasks API type definitions"
      exports: ["ClaudeTaskId", "TaskCreateParams", "TaskCreateResult", "TaskUpdateParams", "TaskListEntry"]
    - path: "src/tasks/api.ts"
      provides: "TaskCreate wrapper function"
      exports: ["createTask"]
    - path: "src/tasks/registry.ts"
      provides: "Task ID registry with frontmatter persistence"
      exports: ["TaskRegistry", "createTaskRegistry"]
    - path: "src/tasks/index.ts"
      provides: "Module exports"
      exports: ["createTask", "TaskRegistry", "createTaskRegistry"]
  key_links:
    - from: "src/tasks/api.ts"
      to: "TaskToolParams from src/sync/types.ts"
      via: "imports for type compatibility"
      pattern: "import.*TaskToolParams.*from.*sync"
    - from: "src/tasks/registry.ts"
      to: "PLAN.md frontmatter"
      via: "gray-matter for persistence"
      pattern: "matter\\("
---

<objective>
Implement TaskCreate API wrapper and Task ID registry for Claude Tasks integration.

Purpose: Enable plan execution to register tasks with Claude Tasks API, providing visual tracking in Claude UI. The registry maintains mapping between our deterministic task IDs (e.g., "06-01-01") and Claude's assigned task IDs (e.g., "1", "2").

Output: Working api.ts with createTask() function and registry.ts with TaskRegistry class that persists to PLAN.md frontmatter.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-tasks-api/11-RESEARCH.md

# Existing sync module (Phase 6 foundation)
@src/sync/types.ts
@src/sync/task-mapper.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Tasks API types and TaskCreate wrapper</name>
  <files>src/tasks/types.ts, src/tasks/api.ts</files>
  <action>
Create `src/tasks/types.ts` with Claude Tasks API type definitions:

```typescript
// ClaudeTaskId - mapping between our ID and Claude's ID
interface ClaudeTaskId {
  internal: string;  // Our format: "06-01-01"
  claude: string;    // Claude's format: "1", "2", etc.
}

// TaskCreate parameters (what we send)
interface TaskCreateParams {
  subject: string;       // Task title (max ~50 chars)
  description: string;   // Full task description
  activeForm?: string;   // Spinner text during execution
}

// TaskCreate result (what Claude returns)
interface TaskCreateResult {
  id: string;           // Claude's task ID
  subject: string;
  status: 'pending' | 'in_progress' | 'completed';
}

// TaskUpdate parameters
interface TaskUpdateParams {
  taskId: string;
  owner?: string;
  status?: 'pending' | 'in_progress' | 'completed';
  addBlockedBy?: string[];
  metadata?: Record<string, unknown>;
}

// TaskList entry
interface TaskListEntry {
  id: string;
  subject: string;
  status: 'pending' | 'in_progress' | 'completed';
  blockedBy?: string[];
  owner?: string;
}
```

Create `src/tasks/api.ts` with TaskCreate wrapper:

```typescript
import type { TaskToolParams } from '../sync/types.js';
import type { TaskCreateParams, TaskCreateResult } from './types.js';

/**
 * Create a task in Claude Tasks.
 *
 * NOTE: This function generates the TaskCreate tool invocation structure.
 * The actual tool call happens via Claude's tool execution system.
 *
 * @param params - Task creation parameters
 * @returns TaskCreateResult structure (actual ID assigned by Claude runtime)
 */
export function createTask(params: TaskCreateParams): { tool: 'TaskCreate'; params: TaskCreateParams } {
  return {
    tool: 'TaskCreate',
    params: {
      subject: params.subject.slice(0, 50),  // Enforce max length
      description: params.description,
      ...(params.activeForm && { activeForm: params.activeForm }),
    },
  };
}

/**
 * Create task from TaskToolParams (from sync module)
 */
export function createTaskFromToolParams(
  toolParams: TaskToolParams
): { tool: 'TaskCreate'; params: TaskCreateParams } {
  return createTask({
    subject: toolParams.description,
    description: toolParams.prompt,
    activeForm: `Executing: ${toolParams.description}`,
  });
}
```

IMPORTANT: The actual TaskCreate call is a Claude Code tool, not a function we can call directly. These functions create the invocation structure that the orchestrator will use to invoke the tool.
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors in src/tasks/types.ts and src/tasks/api.ts
  </verify>
  <done>
Types compile cleanly, createTask and createTaskFromToolParams functions export correctly
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Task ID registry with frontmatter persistence</name>
  <files>src/tasks/registry.ts, src/tasks/index.ts</files>
  <action>
Create `src/tasks/registry.ts` with TaskRegistry class:

```typescript
import { readFile, writeFile } from 'fs/promises';
import matter from 'gray-matter';
import type { ClaudeTaskId } from './types.js';

/**
 * Registry for mapping internal task IDs to Claude Task IDs.
 *
 * Persists to PLAN.md frontmatter under `claude_task_ids` field.
 * This allows task mappings to survive session restarts.
 */
export class TaskRegistry {
  private registry: Map<string, string> = new Map();
  private planPath: string;

  constructor(planPath: string) {
    this.planPath = planPath;
  }

  /**
   * Register a task ID mapping
   */
  register(internalId: string, claudeId: string): void {
    this.registry.set(internalId, claudeId);
  }

  /**
   * Get Claude Task ID for internal ID
   */
  getClaudeId(internalId: string): string | undefined {
    return this.registry.get(internalId);
  }

  /**
   * Get internal ID for Claude Task ID (reverse lookup)
   */
  getInternalId(claudeId: string): string | undefined {
    for (const [internal, claude] of this.registry) {
      if (claude === claudeId) return internal;
    }
    return undefined;
  }

  /**
   * Check if internal ID is registered
   */
  has(internalId: string): boolean {
    return this.registry.has(internalId);
  }

  /**
   * Get all registered mappings
   */
  getAll(): ClaudeTaskId[] {
    return Array.from(this.registry.entries()).map(([internal, claude]) => ({
      internal,
      claude,
    }));
  }

  /**
   * Load registry from PLAN.md frontmatter
   */
  async load(): Promise<void> {
    try {
      const content = await readFile(this.planPath, 'utf-8');
      const parsed = matter(content);
      const claudeTaskIds = parsed.data.claude_task_ids as Record<string, string> | undefined;

      if (claudeTaskIds) {
        this.registry = new Map(Object.entries(claudeTaskIds));
      }
    } catch (error) {
      // File doesn't exist or can't be read - start with empty registry
      this.registry = new Map();
    }
  }

  /**
   * Save registry to PLAN.md frontmatter
   */
  async save(): Promise<void> {
    const content = await readFile(this.planPath, 'utf-8');
    const parsed = matter(content);

    // Update frontmatter with registry
    parsed.data.claude_task_ids = Object.fromEntries(this.registry);

    const updated = matter.stringify(parsed.content, parsed.data);
    await writeFile(this.planPath, updated, 'utf-8');
  }

  /**
   * Clear all registrations (for session reset)
   */
  clear(): void {
    this.registry.clear();
  }

  /**
   * Get count of registered tasks
   */
  get size(): number {
    return this.registry.size;
  }
}

/**
 * Create and optionally load a TaskRegistry
 */
export async function createTaskRegistry(
  planPath: string,
  loadExisting: boolean = true
): Promise<TaskRegistry> {
  const registry = new TaskRegistry(planPath);
  if (loadExisting) {
    await registry.load();
  }
  return registry;
}
```

Create `src/tasks/index.ts` module exports:

```typescript
// Types
export type {
  ClaudeTaskId,
  TaskCreateParams,
  TaskCreateResult,
  TaskUpdateParams,
  TaskListEntry,
} from './types.js';

// API functions
export { createTask, createTaskFromToolParams } from './api.js';

// Registry
export { TaskRegistry, createTaskRegistry } from './registry.js';
```
  </action>
  <verify>
Run `npx tsc --noEmit` - all src/tasks/* files compile without errors.
Run `npm test -- --testPathPattern=tasks` if tests exist, otherwise manual verification.
  </verify>
  <done>
TaskRegistry class implemented with load/save/register methods. Module exports all types and functions correctly.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - no TypeScript errors
2. `ls src/tasks/` shows: types.ts, api.ts, registry.ts, index.ts
3. Import test: `node -e "import('./dist/tasks/index.js').then(m => console.log(Object.keys(m)))"`
</verification>

<success_criteria>
- [ ] src/tasks/types.ts defines all Claude Tasks API types
- [ ] src/tasks/api.ts exports createTask() and createTaskFromToolParams()
- [ ] src/tasks/registry.ts exports TaskRegistry with load/save/register
- [ ] src/tasks/index.ts re-exports all public API
- [ ] All files compile without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/11-tasks-api-integration/11-01-SUMMARY.md`
</output>

---
phase: 11-tasks-api-integration
plan: 03
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - src/tasks/api.ts
  - src/tasks/status.ts
  - src/tasks/progress.ts
  - src/tasks/index.ts
autonomous: true

must_haves:
  truths:
    - "Task status changes sync to Claude Tasks via TaskUpdate"
    - "TaskList retrieves current task state for progress display"
    - "Progress can be formatted for human-readable output"
  artifacts:
    - path: "src/tasks/api.ts"
      provides: "listTasks function for TaskList"
      exports: ["createTask", "createTaskFromToolParams", "updateTask", "listTasks"]
    - path: "src/tasks/status.ts"
      provides: "Status synchronization between execution state and Claude Tasks"
      exports: ["syncTaskStatus", "markInProgress", "markCompleted", "markFailed"]
    - path: "src/tasks/progress.ts"
      provides: "Progress visualization from TaskList"
      exports: ["getProgress", "formatProgress", "formatTaskList"]
  key_links:
    - from: "src/tasks/status.ts"
      to: "src/sync/status-sync.ts"
      via: "updates both Claude Tasks and PLAN.md"
      pattern: "import.*from.*sync/status-sync"
    - from: "src/tasks/status.ts"
      to: "src/tasks/registry.ts"
      via: "maps internal IDs for TaskUpdate"
      pattern: "registry\\.getClaudeId"
---

<objective>
Implement TaskUpdate status synchronization and TaskList progress visualization.

Purpose: Execution state changes (pending -> in_progress -> completed) must sync to Claude Tasks for visual tracking. TaskList provides progress visibility during plan execution.

Output: Working status.ts for state synchronization and progress.ts for TaskList-based progress display.
</objective>

<context>
@.planning/PROJECT.md
@.planning/phases/11-tasks-api/11-RESEARCH.md

# Phase 6 status infrastructure
@src/sync/status-sync.ts
@src/sync/types.ts

# Plan 11-01 outputs
@src/tasks/types.ts
@src/tasks/api.ts
@src/tasks/registry.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add listTasks to api.ts and create status.ts</name>
  <files>src/tasks/api.ts, src/tasks/status.ts</files>
  <action>
Add listTasks function to `src/tasks/api.ts`:

```typescript
/**
 * List all tasks in Claude Tasks.
 *
 * NOTE: Generates TaskList tool invocation structure.
 * Actual tool call happens via Claude's tool execution system.
 *
 * @returns TaskList invocation
 */
export function listTasks(): { tool: 'TaskList'; params: Record<string, never> } {
  return {
    tool: 'TaskList',
    params: {},
  };
}
```

Create `src/tasks/status.ts`:

```typescript
import type { TaskRegistry } from './registry.js';
import type { TaskStatus } from '../sync/types.js';
import { updateTask } from './api.js';
import {
  markTaskInProgress as markPlanInProgress,
  markTaskComplete as markPlanComplete,
  markTaskFailed as markPlanFailed,
} from '../sync/status-sync.js';
import type { TaskUpdateParams } from './types.js';

/**
 * Router state to Claude Tasks status mapping
 *
 * Maps execution states to Claude Tasks API status values.
 */
type RouterState = 'pending' | 'executing' | 'verifying' | 'done' | 'failed';
type ClaudeTaskStatus = 'pending' | 'in_progress' | 'completed';

const STATE_MAP: Record<RouterState, ClaudeTaskStatus> = {
  pending: 'pending',
  executing: 'in_progress',
  verifying: 'in_progress',  // Still executing during verification
  done: 'completed',
  failed: 'pending',  // Failed tasks reset to pending (retry possible)
};

/**
 * Tool invocation result for status updates
 */
export interface StatusUpdateResult {
  tool: 'TaskUpdate';
  params: TaskUpdateParams;
  internalId: string;
}

/**
 * Sync task status to Claude Tasks
 *
 * Creates TaskUpdate invocation to synchronize execution state.
 * Does NOT update PLAN.md - use the specific mark* functions for dual sync.
 *
 * @param internalId - Our task ID
 * @param state - Router execution state
 * @param registry - TaskRegistry for ID lookup
 * @param metadata - Optional metadata to include
 * @returns StatusUpdateResult or null if task not registered
 */
export function syncTaskStatus(
  internalId: string,
  state: RouterState,
  registry: TaskRegistry,
  metadata?: Record<string, unknown>
): StatusUpdateResult | null {
  const claudeTaskId = registry.getClaudeId(internalId);
  if (!claudeTaskId) {
    console.warn(`Cannot sync status: task ${internalId} not registered`);
    return null;
  }

  const claudeStatus = STATE_MAP[state];

  const invocation = updateTask({
    taskId: claudeTaskId,
    status: claudeStatus,
    ...(state === 'executing' && { owner: 'executor' }),
    ...(metadata && { metadata }),
  });

  return {
    ...invocation,
    internalId,
  };
}

/**
 * Mark task as in progress (dual sync: Claude Tasks + PLAN.md)
 *
 * @param internalId - Our task ID
 * @param planPath - Path to PLAN.md for status sync
 * @param registry - TaskRegistry for ID lookup
 * @param agentId - Optional agent ID for resumption
 */
export async function markInProgress(
  internalId: string,
  planPath: string,
  registry: TaskRegistry,
  agentId?: string
): Promise<StatusUpdateResult | null> {
  // Update PLAN.md
  await markPlanInProgress(planPath, internalId, agentId);

  // Generate Claude Tasks update
  return syncTaskStatus(internalId, 'executing', registry, {
    startedAt: new Date().toISOString(),
    ...(agentId && { agentId }),
  });
}

/**
 * Mark task as completed (dual sync: Claude Tasks + PLAN.md)
 *
 * @param internalId - Our task ID
 * @param planPath - Path to PLAN.md for status sync
 * @param registry - TaskRegistry for ID lookup
 * @param evidence - Optional completion evidence
 */
export async function markCompleted(
  internalId: string,
  planPath: string,
  registry: TaskRegistry,
  evidence?: string
): Promise<StatusUpdateResult | null> {
  // Update PLAN.md
  await markPlanComplete(planPath, internalId);

  // Generate Claude Tasks update
  return syncTaskStatus(internalId, 'done', registry, {
    completedAt: new Date().toISOString(),
    ...(evidence && { evidence }),
  });
}

/**
 * Mark task as failed (dual sync: Claude Tasks + PLAN.md)
 *
 * @param internalId - Our task ID
 * @param planPath - Path to PLAN.md for status sync
 * @param registry - TaskRegistry for ID lookup
 * @param error - Error message
 */
export async function markFailed(
  internalId: string,
  planPath: string,
  registry: TaskRegistry,
  error: string
): Promise<StatusUpdateResult | null> {
  // Update PLAN.md
  await markPlanFailed(planPath, internalId, error);

  // Generate Claude Tasks update (reset to pending for retry)
  return syncTaskStatus(internalId, 'failed', registry, {
    failedAt: new Date().toISOString(),
    error,
    retryable: true,
  });
}

/**
 * Bulk status check - get status for multiple tasks
 *
 * @param internalIds - Array of task IDs to check
 * @param registry - TaskRegistry for ID lookup
 * @returns Map of internal ID -> registered status
 */
export function checkRegistrationStatus(
  internalIds: string[],
  registry: TaskRegistry
): Map<string, boolean> {
  const status = new Map<string, boolean>();
  for (const id of internalIds) {
    status.set(id, registry.has(id));
  }
  return status;
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` - api.ts and status.ts compile without errors.
Check imports: `grep "import.*from.*sync" src/tasks/status.ts` shows sync module integration.
  </verify>
  <done>
listTasks() added to api.ts. status.ts provides dual sync to both Claude Tasks and PLAN.md via existing status-sync.ts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create progress.ts for TaskList visualization</name>
  <files>src/tasks/progress.ts, src/tasks/index.ts</files>
  <action>
Create `src/tasks/progress.ts`:

```typescript
import type { TaskListEntry } from './types.js';
import { listTasks } from './api.js';

/**
 * Progress statistics from TaskList
 */
export interface ProgressStats {
  total: number;
  completed: number;
  inProgress: number;
  pending: number;
  blocked: number;
  percentComplete: number;
}

/**
 * Calculate progress statistics from task list
 *
 * @param tasks - Array of TaskListEntry from TaskList
 * @returns Progress statistics
 */
export function calculateProgress(tasks: TaskListEntry[]): ProgressStats {
  const total = tasks.length;

  if (total === 0) {
    return {
      total: 0,
      completed: 0,
      inProgress: 0,
      pending: 0,
      blocked: 0,
      percentComplete: 100,  // Empty plan is "complete"
    };
  }

  const completed = tasks.filter(t => t.status === 'completed').length;
  const inProgress = tasks.filter(t => t.status === 'in_progress').length;
  const blocked = tasks.filter(t =>
    t.status === 'pending' && t.blockedBy && t.blockedBy.length > 0
  ).length;
  const pending = tasks.filter(t =>
    t.status === 'pending' && (!t.blockedBy || t.blockedBy.length === 0)
  ).length;

  return {
    total,
    completed,
    inProgress,
    pending,
    blocked,
    percentComplete: Math.round((completed / total) * 100),
  };
}

/**
 * Generate TaskList invocation for progress query
 */
export function getProgress(): { tool: 'TaskList'; params: Record<string, never> } {
  return listTasks();
}

/**
 * Format progress bar string
 *
 * @param stats - Progress statistics
 * @param width - Bar width in characters (default 20)
 * @returns Formatted progress bar
 */
export function formatProgressBar(stats: ProgressStats, width: number = 20): string {
  const filled = Math.round((stats.completed / stats.total) * width);
  const inProg = Math.round((stats.inProgress / stats.total) * width);
  const empty = width - filled - inProg;

  const bar = '█'.repeat(filled) + '▓'.repeat(inProg) + '░'.repeat(Math.max(0, empty));
  return `[${bar}] ${stats.percentComplete}%`;
}

/**
 * Format progress for display
 *
 * @param stats - Progress statistics
 * @returns Multi-line progress summary
 */
export function formatProgress(stats: ProgressStats): string {
  const lines = [
    formatProgressBar(stats),
    '',
    `Total: ${stats.total} tasks`,
    `  ✓ Completed: ${stats.completed}`,
    `  ▸ In Progress: ${stats.inProgress}`,
    `  ○ Pending: ${stats.pending}`,
  ];

  if (stats.blocked > 0) {
    lines.push(`  ⊘ Blocked: ${stats.blocked}`);
  }

  return lines.join('\n');
}

/**
 * Format single task entry for display
 *
 * @param task - TaskListEntry
 * @returns Formatted task line
 */
export function formatTaskEntry(task: TaskListEntry): string {
  const statusIcon = {
    completed: '✓',
    in_progress: '▸',
    pending: '○',
  }[task.status];

  let line = `#${task.id} [${statusIcon}] ${task.subject}`;

  if (task.owner) {
    line += ` (owner: ${task.owner})`;
  }

  if (task.blockedBy && task.blockedBy.length > 0) {
    line += ` [blocked by #${task.blockedBy.join(', #')}]`;
  }

  return line;
}

/**
 * Format full task list for display
 *
 * @param tasks - Array of TaskListEntry
 * @returns Multi-line task list
 */
export function formatTaskList(tasks: TaskListEntry[]): string {
  if (tasks.length === 0) {
    return 'No tasks registered.';
  }

  const stats = calculateProgress(tasks);
  const header = formatProgress(stats);
  const divider = '─'.repeat(40);
  const taskLines = tasks.map(formatTaskEntry);

  return [header, '', divider, '', ...taskLines].join('\n');
}

/**
 * Check if all tasks are complete
 *
 * @param tasks - Array of TaskListEntry
 * @returns true if all tasks have completed status
 */
export function isAllComplete(tasks: TaskListEntry[]): boolean {
  return tasks.length > 0 && tasks.every(t => t.status === 'completed');
}

/**
 * Get tasks that are ready to execute (pending, not blocked)
 *
 * @param tasks - Array of TaskListEntry
 * @returns Tasks that can be executed now
 */
export function getReadyTasks(tasks: TaskListEntry[]): TaskListEntry[] {
  return tasks.filter(t =>
    t.status === 'pending' && (!t.blockedBy || t.blockedBy.length === 0)
  );
}

/**
 * Get tasks currently in progress
 *
 * @param tasks - Array of TaskListEntry
 * @returns Tasks currently being executed
 */
export function getActiveTasks(tasks: TaskListEntry[]): TaskListEntry[] {
  return tasks.filter(t => t.status === 'in_progress');
}
```

Update `src/tasks/index.ts` to include all new exports:

```typescript
// Types
export type {
  ClaudeTaskId,
  TaskCreateParams,
  TaskCreateResult,
  TaskUpdateParams,
  TaskListEntry,
} from './types.js';

// API functions
export {
  createTask,
  createTaskFromToolParams,
  updateTask,
  createDependencyUpdate,
  listTasks,
} from './api.js';

// Registry
export { TaskRegistry, createTaskRegistry } from './registry.js';

// Dependencies
export {
  setTaskDependencies,
  generateTaskCreations,
  generateDependencyUpdates,
  preparePlanRegistration,
} from './dependencies.js';
export type { TaskToolInvocation } from './dependencies.js';

// Status
export {
  syncTaskStatus,
  markInProgress,
  markCompleted,
  markFailed,
  checkRegistrationStatus,
} from './status.js';
export type { StatusUpdateResult } from './status.js';

// Progress
export {
  calculateProgress,
  getProgress,
  formatProgressBar,
  formatProgress,
  formatTaskEntry,
  formatTaskList,
  isAllComplete,
  getReadyTasks,
  getActiveTasks,
} from './progress.js';
export type { ProgressStats } from './progress.js';
```
  </action>
  <verify>
Run `npx tsc --noEmit` - all src/tasks/* files compile without errors.
Check comprehensive exports: `grep "export" src/tasks/index.ts | wc -l` should show 20+ exports.
  </verify>
  <done>
progress.ts provides TaskList-based progress visualization with formatting utilities. Complete module exports all functions and types.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - no TypeScript errors
2. `ls src/tasks/` shows: types.ts, api.ts, registry.ts, dependencies.ts, status.ts, progress.ts, index.ts
3. All exports available: `grep "export" src/tasks/index.ts`
4. Build succeeds: `npm run build`
</verification>

<success_criteria>
- [ ] listTasks() added to api.ts
- [ ] status.ts imports from sync/status-sync.ts for dual sync
- [ ] markInProgress/markCompleted/markFailed update both Claude Tasks and PLAN.md
- [ ] progress.ts calculates stats from TaskListEntry array
- [ ] formatProgress() and formatTaskList() provide human-readable output
- [ ] getReadyTasks() filters pending, non-blocked tasks
- [ ] All files compile without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/11-tasks-api-integration/11-03-SUMMARY.md`
</output>

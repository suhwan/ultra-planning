---
phase: 11-tasks-api-integration
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - src/tasks/api.ts
  - src/tasks/dependencies.ts
  - src/tasks/index.ts
autonomous: true

must_haves:
  truths:
    - "Wave N tasks are blocked by ALL Wave 1..N-1 tasks"
    - "Dependencies are set via TaskUpdate(addBlockedBy) after task creation"
    - "Dependency setting uses Claude Task IDs from registry, not internal IDs"
  artifacts:
    - path: "src/tasks/api.ts"
      provides: "updateTask function for status and dependencies"
      exports: ["createTask", "createTaskFromToolParams", "updateTask"]
    - path: "src/tasks/dependencies.ts"
      provides: "Dependency wiring for wave-based execution"
      exports: ["setTaskDependencies", "registerPlanTasks"]
  key_links:
    - from: "src/tasks/dependencies.ts"
      to: "src/sync/dependency-map.ts"
      via: "imports buildDependencyMap"
      pattern: "import.*buildDependencyMap.*from.*sync"
    - from: "src/tasks/dependencies.ts"
      to: "src/tasks/registry.ts"
      via: "maps internal IDs to Claude IDs"
      pattern: "registry\\.getClaudeId"
---

<objective>
Implement blockedBy dependency wiring for Claude Tasks integration.

Purpose: Wave-based dependencies from PLAN.md must be converted to blockedBy arrays in Claude Tasks. This ensures tasks in Wave 2 are blocked until all Wave 1 tasks complete, providing visual dependency tracking in Claude UI.

Output: Working dependencies.ts with setTaskDependencies() and registerPlanTasks() that properly wire wave-based dependencies using TaskUpdate(addBlockedBy).
</objective>

<context>
@.planning/PROJECT.md
@.planning/phases/11-tasks-api/11-RESEARCH.md

# Phase 6 dependency infrastructure
@src/sync/dependency-map.ts
@src/sync/task-mapper.ts

# Plan 11-01 outputs
@src/tasks/types.ts
@src/tasks/api.ts
@src/tasks/registry.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add updateTask function to api.ts</name>
  <files>src/tasks/api.ts</files>
  <action>
Extend `src/tasks/api.ts` to include updateTask function:

```typescript
import type { TaskUpdateParams } from './types.js';

/**
 * Update a task in Claude Tasks.
 *
 * NOTE: Generates TaskUpdate tool invocation structure.
 * Actual tool call happens via Claude's tool execution system.
 *
 * Key use cases:
 * - Set dependencies: updateTask({ taskId, addBlockedBy: [...] })
 * - Start task: updateTask({ taskId, status: 'in_progress', owner: 'executor' })
 * - Complete task: updateTask({ taskId, status: 'completed' })
 *
 * @param params - Task update parameters
 */
export function updateTask(params: TaskUpdateParams): { tool: 'TaskUpdate'; params: TaskUpdateParams } {
  // Validate taskId is present
  if (!params.taskId) {
    throw new Error('TaskUpdate requires taskId');
  }

  return {
    tool: 'TaskUpdate',
    params: {
      taskId: params.taskId,
      ...(params.owner && { owner: params.owner }),
      ...(params.status && { status: params.status }),
      ...(params.addBlockedBy && params.addBlockedBy.length > 0 && {
        addBlockedBy: params.addBlockedBy,
      }),
      ...(params.metadata && { metadata: params.metadata }),
    },
  };
}

/**
 * Create dependency update for a task
 *
 * Convenience function for setting blockedBy dependencies.
 */
export function createDependencyUpdate(
  taskId: string,
  blockedBy: string[]
): { tool: 'TaskUpdate'; params: TaskUpdateParams } {
  return updateTask({
    taskId,
    addBlockedBy: blockedBy,
  });
}
```

Add exports to the existing functions in api.ts.
  </action>
  <verify>
Run `npx tsc --noEmit` - api.ts compiles without errors.
Check exports: `grep -E "export function" src/tasks/api.ts` shows createTask, createTaskFromToolParams, updateTask, createDependencyUpdate
  </verify>
  <done>
updateTask and createDependencyUpdate functions added to api.ts, all functions export correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create dependencies.ts with wave-to-blockedBy wiring</name>
  <files>src/tasks/dependencies.ts, src/tasks/index.ts</files>
  <action>
Create `src/tasks/dependencies.ts`:

```typescript
import type { TaskMapping } from '../sync/types.js';
import type { TaskInvocation } from '../sync/task-mapper.js';
import { buildDependencyMap, getExecutionOrder } from '../sync/dependency-map.js';
import { createTaskInvocations } from '../sync/task-mapper.js';
import { createTask, createTaskFromToolParams, updateTask } from './api.js';
import type { TaskRegistry } from './registry.js';
import type { TaskCreateParams, TaskUpdateParams } from './types.js';

/**
 * Tool invocation result for batch operations
 */
export interface TaskToolInvocation {
  tool: 'TaskCreate' | 'TaskUpdate';
  params: TaskCreateParams | TaskUpdateParams;
  internalId: string;  // Our task ID for correlation
}

/**
 * Set dependencies for a task using registry lookup
 *
 * Converts internal task IDs to Claude Task IDs via registry,
 * then creates TaskUpdate invocation with addBlockedBy.
 *
 * @param internalId - Our task ID (e.g., "06-02-01")
 * @param internalBlockedBy - Array of internal task IDs that block this task
 * @param registry - TaskRegistry for ID mapping
 * @returns TaskUpdate invocation or null if no valid dependencies
 */
export function setTaskDependencies(
  internalId: string,
  internalBlockedBy: string[],
  registry: TaskRegistry
): TaskToolInvocation | null {
  // Get Claude Task ID for target task
  const claudeTaskId = registry.getClaudeId(internalId);
  if (!claudeTaskId) {
    console.warn(`Cannot set dependencies: task ${internalId} not registered`);
    return null;
  }

  // Map internal blockedBy IDs to Claude Task IDs
  const claudeBlockedBy = internalBlockedBy
    .map(id => registry.getClaudeId(id))
    .filter((id): id is string => id !== undefined);

  // No valid dependencies to set
  if (claudeBlockedBy.length === 0) {
    return null;
  }

  const invocation = updateTask({
    taskId: claudeTaskId,
    addBlockedBy: claudeBlockedBy,
  });

  return {
    ...invocation,
    internalId,
  };
}

/**
 * Generate all task registrations for a plan
 *
 * Creates TaskCreate invocations for all tasks, sorted by wave.
 * CRITICAL: Tasks must be created in wave order so that Wave N
 * tasks can reference Wave 1..N-1 tasks in their dependencies.
 *
 * @param mappings - TaskMappings from plan parser
 * @returns Array of TaskCreate invocations in wave order
 */
export function generateTaskCreations(
  mappings: TaskMapping[]
): TaskToolInvocation[] {
  // Sort by wave for proper creation order
  const sorted = getExecutionOrder(mappings);

  return sorted.map(mapping => ({
    tool: 'TaskCreate' as const,
    params: {
      subject: mapping.tool_params.description.slice(0, 50),
      description: mapping.tool_params.prompt,
      activeForm: `Executing: ${mapping.tool_params.description}`,
    },
    internalId: mapping.task_id,
  }));
}

/**
 * Generate all dependency updates for a plan
 *
 * Creates TaskUpdate(addBlockedBy) invocations for tasks with dependencies.
 * MUST be called AFTER all tasks are created and registered.
 *
 * @param mappings - TaskMappings from plan parser
 * @param registry - TaskRegistry with Claude Task ID mappings
 * @returns Array of TaskUpdate invocations for dependencies
 */
export function generateDependencyUpdates(
  mappings: TaskMapping[],
  registry: TaskRegistry
): TaskToolInvocation[] {
  // Build wave-based dependency map (internal IDs)
  const depMap = buildDependencyMap(mappings);

  const updates: TaskToolInvocation[] = [];

  for (const mapping of mappings) {
    const blockedBy = depMap[mapping.task_id] || [];

    if (blockedBy.length > 0) {
      const invocation = setTaskDependencies(
        mapping.task_id,
        blockedBy,
        registry
      );

      if (invocation) {
        updates.push(invocation);
      }
    }
  }

  return updates;
}

/**
 * Full plan registration workflow
 *
 * Returns both creation and dependency invocations.
 * Caller must:
 * 1. Execute all TaskCreate invocations
 * 2. Register returned IDs in registry
 * 3. Execute all TaskUpdate invocations for dependencies
 *
 * @param mappings - TaskMappings from plan parser
 * @returns Tuple of [create invocations, dependency generator function]
 */
export function preparePlanRegistration(
  mappings: TaskMapping[]
): {
  creates: TaskToolInvocation[];
  generateDependencies: (registry: TaskRegistry) => TaskToolInvocation[];
} {
  const creates = generateTaskCreations(mappings);

  return {
    creates,
    generateDependencies: (registry: TaskRegistry) =>
      generateDependencyUpdates(mappings, registry),
  };
}
```

Update `src/tasks/index.ts` to include new exports:

```typescript
// Add to existing exports:
export {
  setTaskDependencies,
  generateTaskCreations,
  generateDependencyUpdates,
  preparePlanRegistration,
} from './dependencies.js';

export type { TaskToolInvocation } from './dependencies.js';
```
  </action>
  <verify>
Run `npx tsc --noEmit` - dependencies.ts compiles without errors.
Check imports work: `grep -E "import.*from.*sync" src/tasks/dependencies.ts` shows sync module imports.
  </verify>
  <done>
dependencies.ts implements wave-to-blockedBy mapping using existing sync infrastructure. preparePlanRegistration provides clean workflow for task registration.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - no TypeScript errors
2. `grep "export" src/tasks/index.ts` shows all new exports
3. Import chain: dependencies.ts -> sync/dependency-map.ts -> TaskMapping types
</verification>

<success_criteria>
- [ ] updateTask() function added to api.ts
- [ ] dependencies.ts imports buildDependencyMap from sync module
- [ ] setTaskDependencies() maps internal IDs to Claude IDs via registry
- [ ] generateTaskCreations() returns tasks sorted by wave
- [ ] generateDependencyUpdates() creates TaskUpdate invocations with addBlockedBy
- [ ] preparePlanRegistration() provides clean workflow API
- [ ] All files compile without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/11-tasks-api-integration/11-02-SUMMARY.md`
</output>

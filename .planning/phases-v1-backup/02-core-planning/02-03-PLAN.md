---
phase: 02-core-planning
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - .claude/agents/ultraplan-planner.md
autonomous: true

must_haves:
  truths:
    - "Planner can generate PLAN.md with task breakdowns"
    - "Tasks have all required XML elements (name, files, action, verify, done)"
    - "Wave numbers are pre-computed from dependencies"
    - "must_haves are derived using goal-backward methodology"
  artifacts:
    - path: ".claude/agents/ultraplan-planner.md"
      provides: "Complete planner agent with PLAN.md generation"
      contains: "PLAN.md Generation"
      min_lines: 450
  key_links:
    - from: ".claude/agents/ultraplan-planner.md"
      to: ".claude/skills/ultraplan/templates/plan.md"
      via: "Template reference for PLAN.md generation"
      pattern: "templates/plan"
    - from: ".claude/agents/ultraplan-planner.md"
      to: ".claude/skills/ultraplan/references/schemas.md"
      via: "Schema validation for frontmatter and XML"
      pattern: "references/schemas"
---

<objective>
Add PLAN.md generation logic with task breakdown, wave assignment, and must_haves derivation.

Purpose: Complete the Planner's document generation capability by enabling granular task planning with dependency-aware wave assignment.

Output: Extended `.claude/agents/ultraplan-planner.md` with PLAN.md generation section
</objective>

<execution_context>
@/home/ubuntu/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-planning/02-RESEARCH.md
@.planning/phases/02-core-planning/02-02-SUMMARY.md
@.claude/skills/ultraplan/templates/plan.md
@.claude/skills/ultraplan/references/schemas.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add PLAN.md Generation Section</name>
  <files>.claude/agents/ultraplan-planner.md</files>
  <action>
Add PLAN.md generation logic:

1. Generation Trigger:
```markdown
## PHASE 3: PLAN GENERATION

Triggered when:
- User says "plan phase X"
- Starting execution of a phase
- After PROJECT/ROADMAP approval for first phase

### When to Generate PLAN.md

- Generate PLAN.md for ONE phase at a time
- Just-in-time planning: Plan phase N when ready to execute it
- Don't pre-plan all phases (learning from earlier phases improves later plans)
```

2. Task Decomposition Process:
```markdown
### Task Decomposition

For each phase, break into tasks:

1. **Identify Deliverables**: What must exist when phase completes?
2. **Group by Concern**: Related files/features together
3. **Size Check**: Each task should take 15-60 min Claude time
4. **Dependency Mapping**:
   - What does each task NEED? (inputs)
   - What does each task CREATE? (outputs)
   - Can tasks run independently?

### Task Anatomy

Every task has FOUR required fields:

<task type="auto">
  <name>Task N: {action_oriented_name}</name>
  <files>{specific_file_paths}</files>
  <action>{detailed_implementation_steps}</action>
  <verify>{command_to_prove_completion}</verify>
  <done>{acceptance_criteria}</done>
</task>

### Task Sizing Rules

| Duration | Action |
|----------|--------|
| < 15 min | Too small — combine with related task |
| 15-60 min | Right size — single focused unit |
| > 60 min | Too large — split into smaller tasks |

Each plan should have 2-3 tasks maximum (~50% context budget)
```

3. Specificity Examples:
```markdown
### Specificity Requirements

Tasks must be specific enough for clean execution:

| TOO VAGUE | JUST RIGHT |
|-----------|------------|
| "Add authentication" | "Add JWT auth with 15-min access token, store in httpOnly cookie" |
| "Create the API" | "Create POST /api/projects accepting {name, desc}, return 201" |
| "Style the dashboard" | "Add Tailwind grid (3 cols lg, 1 mobile), card shadows" |

The test: Could a different Claude instance execute without clarifying questions?
```
  </action>
  <verify>
grep -c "PLAN.md Generation" .claude/agents/ultraplan-planner.md
grep -c "Task Decomposition" .claude/agents/ultraplan-planner.md
grep -c "Task Anatomy" .claude/agents/ultraplan-planner.md
  </verify>
  <done>PLAN.md generation section with task decomposition rules and specificity examples</done>
</task>

<task type="auto">
  <name>Task 2: Add Wave Assignment and Dependency Logic</name>
  <files>.claude/agents/ultraplan-planner.md</files>
  <action>
Add wave assignment logic:

1. Dependency Graph Construction:
```markdown
### Building the Dependency Graph

For each task, record:
- **needs**: What must exist before this runs (files, types, prior outputs)
- **creates**: What this task produces (files, types, exports)

### Wave Assignment Algorithm

```
waves = {}  # task_id -> wave_number

for each task in dependency_order:
  if task.needs is empty:
    task.wave = 1
  else:
    task.wave = max(waves[dep] for dep in task.needs) + 1

  waves[task.id] = task.wave
```

### Wave Assignment Rules

| Situation | Wave Assignment |
|-----------|-----------------|
| No dependencies | Wave 1 |
| Depends only on Wave 1 | Wave 2 |
| File conflict with Wave N task | Wave N+1 |
| Checkpoint in plan | Makes plan autonomous: false |
```

2. Parallelization Optimization:
```markdown
### Vertical Slices vs Horizontal Layers

PREFER vertical slices:
```
Plan 01: User feature (model + API + UI)
Plan 02: Product feature (model + API + UI)
Plan 03: Order feature (model + API + UI)
```
Result: All three can run in parallel (Wave 1)

AVOID horizontal layers:
```
Plan 01: Create all models
Plan 02: Create all APIs
Plan 03: Create all UIs
```
Result: Fully sequential (02 needs 01, 03 needs 02)
```

3. File Ownership Rules:
```markdown
### File Ownership for Parallel Execution

Exclusive file ownership prevents conflicts:

```yaml
# Plan 01 frontmatter
files_modified: [src/models/user.ts, src/api/users.ts]

# Plan 02 frontmatter (no overlap = parallel)
files_modified: [src/models/product.ts, src/api/products.ts]
```

No overlap → can run parallel (same wave)
Overlap → later plan depends on earlier (sequential waves)
```
  </action>
  <verify>
grep -c "Wave Assignment" .claude/agents/ultraplan-planner.md
grep -c "Dependency Graph" .claude/agents/ultraplan-planner.md
grep -c "Vertical Slices" .claude/agents/ultraplan-planner.md
  </verify>
  <done>Wave assignment with dependency analysis and parallelization optimization</done>
</task>

<task type="auto">
  <name>Task 3: Add must_haves Derivation Section</name>
  <files>.claude/agents/ultraplan-planner.md</files>
  <action>
Add must_haves derivation using goal-backward methodology:

1. must_haves Structure:
```markdown
### must_haves Derivation (Goal-Backward)

Every PLAN.md frontmatter includes must_haves:

```yaml
must_haves:
  truths:
    - "Observable behavior 1"
    - "Observable behavior 2"
  artifacts:
    - path: "src/component.tsx"
      provides: "What this provides"
      contains: "Pattern that must exist"
  key_links:
    - from: "source.ts"
      to: "target.ts"
      via: "Connection type"
      pattern: "regex to verify"
```

### Derivation Process

1. **State the Goal** (outcome, not task)
   - Take from phase goal in ROADMAP.md
   - Reframe as "What must be TRUE?"

2. **Derive Observable Truths** (3-7)
   - From USER perspective
   - Verifiable by using the application

3. **Derive Required Artifacts**
   - For each truth: "What must EXIST?"
   - Specific file paths

4. **Identify Key Links**
   - Critical connections between artifacts
   - Where things are most likely to break
```

2. Common Failures to Avoid:
```markdown
### must_haves Anti-Patterns

| WRONG | RIGHT |
|-------|-------|
| Truths too vague: "User can use chat" | Specific: "User can see messages", "User can send" |
| Artifacts abstract: "Auth module" | Specific: "src/app/api/auth/login/route.ts" |
| Missing wiring: "Has component" | With connection: "Component fetches from /api/X" |
```
  </action>
  <verify>
grep -c "must_haves" .claude/agents/ultraplan-planner.md
grep -c "Goal-Backward" .claude/agents/ultraplan-planner.md
grep -c "Observable Truths" .claude/agents/ultraplan-planner.md
  </verify>
  <done>must_haves derivation with goal-backward methodology and anti-patterns</done>
</task>

</tasks>

<verification>
1. PLAN.md generation section: `grep "PLAN.md Generation" .claude/agents/ultraplan-planner.md`
2. Task decomposition rules: `grep "Task Decomposition" .claude/agents/ultraplan-planner.md`
3. Wave assignment algorithm: `grep "Wave Assignment" .claude/agents/ultraplan-planner.md`
4. must_haves derivation: `grep "must_haves" .claude/agents/ultraplan-planner.md`
5. Goal-backward methodology: `grep "Goal-Backward" .claude/agents/ultraplan-planner.md`
6. File length: `wc -l .claude/agents/ultraplan-planner.md` (should be >= 450)
</verification>

<success_criteria>
- [ ] PLAN.md generation section with trigger conditions
- [ ] Task decomposition process with sizing rules
- [ ] Task anatomy with all four required fields
- [ ] Specificity examples showing vague vs specific
- [ ] Wave assignment algorithm documented
- [ ] Dependency graph construction explained
- [ ] Vertical slices preferred over horizontal layers
- [ ] File ownership rules for parallelization
- [ ] must_haves derivation using goal-backward
- [ ] Anti-patterns for common mistakes
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-planning/02-03-SUMMARY.md`
</output>
